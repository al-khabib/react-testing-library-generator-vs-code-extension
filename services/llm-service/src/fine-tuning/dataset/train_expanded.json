[
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface AccordionItemProps {\n  title: string;\n  children: React.ReactNode;\n  isOpen?: boolean;\n  onToggle?: () => void;\n}\n\nexport interface AccordionProps extends React.HTMLAttributes<HTMLDivElement> {\n  items: AccordionItemProps[];\n  allowMultiple?: boolean;\n}\n\nconst AccordionItem: React.FC<AccordionItemProps> = ({ \n  title, \n  children, \n  isOpen = false, \n  onToggle \n}) => {\n  return (\n    <div className=\"accordion-item\">\n      <button\n        className=\"accordion-header\"\n        onClick={onToggle}\n        aria-expanded={isOpen}\n      >\n        {title}\n      </button>\n      {isOpen && (\n        <div className=\"accordion-content\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport const Accordion = React.forwardRef<HTMLDivElement, AccordionProps>(\n  ({ items, allowMultiple = false, className, ...rest }, ref) => {\n    const [openItems, setOpenItems] = React.useState<string[]>([]);\n\n    const toggleItem = (title: string) => {\n      setOpenItems(prev => {\n        if (allowMultiple) {\n          return prev.includes(title)\n            ? prev.filter(item => item !== title)\n            : [...prev, title];\n        } else {\n          return prev.includes(title) ? [] : [title];\n        }\n      });\n    };\n\n    return (\n      <div\n        {...rest}\n        ref={ref}\n        className={[\"accordion\", className].filter(Boolean).join(\" \")}\n      >\n        {items.map((item) => (\n          <AccordionItem\n            key={item.title}\n            title={item.title}\n            isOpen={openItems.includes(item.title)}\n            onToggle={() => toggleItem(item.title)}\n          >\n            {item.children}\n          </AccordionItem>\n        ))}\n      </div>\n    );\n  }\n);\nAccordion.displayName = \"Accordion\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Accordion } from \"../Accordion\";\n\nconst mockItems = [\n  { title: \"Item 1\", children: <div>Content 1</div> },\n  { title: \"Item 2\", children: <div>Content 2</div> }\n];\n\ntest(\"renders accordion items\", () => {\n  render(<Accordion items={mockItems} />);\n  expect(screen.getByText(\"Item 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Item 2\")).toBeInTheDocument();\n});\n\ntest(\"toggles accordion item\", async () => {\n  const user = userEvent.setup();\n  render(<Accordion items={mockItems} />);\n\n  const button = screen.getByRole(\"button\", { name: /item 1/i });\n  await user.click(button);\n\n  expect(screen.getByText(\"Content 1\")).toBeInTheDocument();\n  expect(button).toHaveAttribute(\"aria-expanded\", \"true\");\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface AccordionItemProps {\n  title: string;\n  children: React.ReactNode;\n  isOpen?: boolean;\n  onToggle?: () => void;\n}\n\nexport interface AccordionProps extends React.HTMLAttributes<HTMLDivElement> {\n  items: AccordionItemProps[];\n  allowMultiple?: boolean;\n}\n\nconst AccordionItem: React.FC<AccordionItemProps> = ({ \n  title, \n  children, \n  isOpen = false, \n  onToggle \n}) => {\n  return (\n    <div className=\"accordion-item\">\n      <button\n        className=\"accordion-header\"\n        onClick={onToggle}\n        aria-expanded={isOpen}\n      >\n        {title}\n      </button>\n      {isOpen && (\n        <div className=\"accordion-content\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport const Accordion = React.forwardRef<HTMLDivElement, AccordionProps>(\n  ({ items, allowMultiple = false, className, ...rest }, ref) => {\n    const [openItems, setOpenItems] = React.useState<string[]>([]);\n\n    const toggleItem = (title: string) => {\n      setOpenItems(prev => {\n        if (allowMultiple) {\n          return prev.includes(title)\n            ? prev.filter(item => item !== title)\n            : [...prev, title];\n        } else {\n          return prev.includes(title) ? [] : [title];\n        }\n      });\n    };\n\n    return (\n      <div\n        {...rest}\n        ref={ref}\n        className={[\"accordion\", className].filter(Boolean).join(\" \")}\n      >\n        {items.map((item) => (\n          <AccordionItem\n            key={item.title}\n            title={item.title}\n            isOpen={openItems.includes(item.title)}\n            onToggle={() => toggleItem(item.title)}\n          >\n            {item.children}\n          </AccordionItem>\n        ))}\n      </div>\n    );\n  }\n);\nAccordion.displayName = \"Accordion\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Accordion } from \"../Accordion\";\n\nconst mockItems = [\n  { title: \"Item 1\", children: <div>Content 1</div> },\n  { title: \"Item 2\", children: <div>Content 2</div> }\n];\n\ntest(\"renders accordion items\", () => {\n  render(<Accordion items={mockItems} />);\n  expect(screen.getByText(\"Item 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Item 2\")).toBeInTheDocument();\n});\n\ntest(\"toggles accordion item\", async () => {\n  const user = userEvent.setup();\n  render(<Accordion items={mockItems} />);\n\n  const button = screen.getByRole(\"button\", { name: /item 1/i });\n  await user.click(button);\n\n  expect(screen.getByText(\"Content 1\")).toBeInTheDocument();\n  expect(button).toHaveAttribute(\"aria-expanded\", \"true\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface AccordionItemProps {\n  title: string;\n  children: React.ReactNode;\n  isOpen?: boolean;\n  onToggle?: () => void;\n}\n\nexport interface AccordionProps extends React.HTMLAttributes<HTMLDivElement> {\n  items: AccordionItemProps[];\n  allowMultiple?: boolean;\n}\n\nconst AccordionItem: React.FC<AccordionItemProps> = ({ \n  title, \n  children, \n  isOpen = false, \n  onToggle \n}) => {\n  return (\n    <div className=\"accordion-item\">\n      <button\n        className=\"accordion-header\"\n        onClick={onToggle}\n        aria-expanded={isOpen}\n      >\n        {title}\n      </button>\n      {isOpen && (\n        <div className=\"accordion-content\">\n          {children}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport const Accordion = React.forwardRef<HTMLDivElement, AccordionProps>(\n  ({ items, allowMultiple = false, className, ...rest }, ref) => {\n    const [openItems, setOpenItems] = React.useState<string[]>([]);\n\n    const toggleItem = (title: string) => {\n      setOpenItems(prev => {\n        if (allowMultiple) {\n          return prev.includes(title)\n            ? prev.filter(item => item !== title)\n            : [...prev, title];\n        } else {\n          return prev.includes(title) ? [] : [title];\n        }\n      });\n    };\n\n    return (\n      <div\n        {...rest}\n        ref={ref}\n        className={[\"accordion\", className].filter(Boolean).join(\" \")}\n      >\n        {items.map((item) => (\n          <AccordionItem\n            key={item.title}\n            title={item.title}\n            isOpen={openItems.includes(item.title)}\n            onToggle={() => toggleItem(item.title)}\n          >\n            {item.children}\n          </AccordionItem>\n        ))}\n      </div>\n    );\n  }\n);\nAccordion.displayName = \"Accordion\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Accordion } from \"../Accordion\";\n\nconst mockItems = [\n  { title: \"Item 1\", children: <div>Content 1</div> },\n  { title: \"Item 2\", children: <div>Content 2</div> }\n];\n\ntest(\"renders accordion items\", () => {\n  render(<Accordion items={mockItems} />);\n  expect(screen.getByText(\"Item 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Item 2\")).toBeInTheDocument();\n});\n\ntest(\"toggles accordion item\", async () => {\n  const user = userEvent.setup();\n  render(<Accordion items={mockItems} />);\n\n  const button = screen.getByRole(\"button\", { name: /item 1/i });\n  await user.click(button);\n\n  expect(screen.getByText(\"Content 1\")).toBeInTheDocument();\n  expect(button).toHaveAttribute(\"aria-expanded\", \"true\");\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\ntype AlertVariant = \"info\" | \"success\" | \"warning\" | \"error\";\n\nexport interface AlertProps extends React.HTMLAttributes<HTMLDivElement> {\n    variant?: AlertVariant;\n    title?: string;\n    closable?: boolean;\n    onClose?: () => void;\n    icon?: React.ReactNode;\n}\n\nconst classesByVariant: Record<AlertVariant, string> = {\n    info: \"alert alert-info\",\n    success: \"alert alert-success\",\n    warning: \"alert alert-warning\",\n    error: \"alert alert-error\",\n};\n\nexport const Alert = React.forwardRef<HTMLDivElement, AlertProps>(\n    ({ variant = \"info\", title, closable = false, onClose, icon, className, children, ...rest }, ref) => {\n        const classes = `${classesByVariant[variant]} ${className || \"\"}`.trim();\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                role=\"alert\"\n            >\n                <div className=\"alert-content\">\n                    {icon && <div className=\"alert-icon\">{icon}</div>}\n                    <div className=\"alert-body\">\n                        {title && <div className=\"alert-title\">{title}</div>}\n                        {children && <div className=\"alert-message\">{children}</div>}\n                    </div>\n                    {closable && (\n                        <button\n                            className=\"alert-close\"\n                            onClick={onClose}\n                            aria-label=\"Close alert\"\n                            type=\"button\"\n                        >\n                            ×\n                        </button>\n                    )}\n                </div>\n            </div>\n        );\n    }\n);\nAlert.displayName = \"Alert\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Alert } from \"../Alert\";\n\ntest(\"renders with message\", () => {\n    render(<Alert>This is an alert message</Alert>);\n    expect(screen.getByRole(\"alert\")).toHaveTextContent(\"This is an alert message\");\n});\n\ntest(\"renders with title and message\", () => {\n    render(<Alert title=\"Success\">Operation completed successfully</Alert>);\n    expect(screen.getByText(\"Success\")).toBeInTheDocument();\n    expect(screen.getByText(\"Operation completed successfully\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Alert variant=\"error\">Error message</Alert>);\n    expect(screen.getByRole(\"alert\")).toHaveClass(\"alert\", \"alert-error\");\n});\n\ntest(\"shows close button when closable\", () => {\n    const onClose = vi.fn();\n    render(<Alert closable onClose={onClose}>Closable alert</Alert>);\n    expect(screen.getByLabelText(\"Close alert\")).toBeInTheDocument();\n});\n\ntest(\"calls onClose when close button clicked\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(<Alert closable onClose={onClose}>Closable alert</Aler t>);\n\n    await user.click(screen.getByLabelText(\"Close alert\"));\n    expect(onClose).toHaveBeenCalledTimes(1);\n});\n\ntest(\"renders with icon\", () => {\n    render(<Alert icon={<span>!</span>}>Alert with icon</Alert>);\n    expect(screen.getByText(\"!\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\ntype AlertVariant = \"info\" | \"success\" | \"warning\" | \"error\";\n\nexport interface AlertProps extends React.HTMLAttributes<HTMLDivElement> {\n    variant?: AlertVariant;\n    title?: string;\n    closable?: boolean;\n    onClose?: () => void;\n    icon?: React.ReactNode;\n}\n\nconst classesByVariant: Record<AlertVariant, string> = {\n    info: \"alert alert-info\",\n    success: \"alert alert-success\",\n    warning: \"alert alert-warning\",\n    error: \"alert alert-error\",\n};\n\nexport const Alert = React.forwardRef<HTMLDivElement, AlertProps>(\n    ({ variant = \"info\", title, closable = false, onClose, icon, className, children, ...rest }, ref) => {\n        const classes = `${classesByVariant[variant]} ${className || \"\"}`.trim();\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                role=\"alert\"\n            >\n                <div className=\"alert-content\">\n                    {icon && <div className=\"alert-icon\">{icon}</div>}\n                    <div className=\"alert-body\">\n                        {title && <div className=\"alert-title\">{title}</div>}\n                        {children && <div className=\"alert-message\">{children}</div>}\n                    </div>\n                    {closable && (\n                        <button\n                            className=\"alert-close\"\n                            onClick={onClose}\n                            aria-label=\"Close alert\"\n                            type=\"button\"\n                        >\n                            ×\n                        </button>\n                    )}\n                </div>\n            </div>\n        );\n    }\n);\nAlert.displayName = \"Alert\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Alert } from \"../Alert\";\n\ntest(\"renders with message\", () => {\n    render(<Alert>This is an alert message</Alert>);\n    expect(screen.getByRole(\"alert\")).toHaveTextContent(\"This is an alert message\");\n});\n\ntest(\"renders with title and message\", () => {\n    render(<Alert title=\"Success\">Operation completed successfully</Alert>);\n    expect(screen.getByText(\"Success\")).toBeInTheDocument();\n    expect(screen.getByText(\"Operation completed successfully\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Alert variant=\"error\">Error message</Alert>);\n    expect(screen.getByRole(\"alert\")).toHaveClass(\"alert\", \"alert-error\");\n});\n\ntest(\"shows close button when closable\", () => {\n    const onClose = vi.fn();\n    render(<Alert closable onClose={onClose}>Closable alert</Alert>);\n    expect(screen.getByLabelText(\"Close alert\")).toBeInTheDocument();\n});\n\ntest(\"calls onClose when close button clicked\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(<Alert closable onClose={onClose}>Closable alert</Aler t>);\n\n    await user.click(screen.getByLabelText(\"Close alert\"));\n    expect(onClose).toHaveBeenCalledTimes(1);\n});\n\ntest(\"renders with icon\", () => {\n    render(<Alert icon={<span>!</span>}>Alert with icon</Alert>);\n    expect(screen.getByText(\"!\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\ntype AlertVariant = \"info\" | \"success\" | \"warning\" | \"error\";\n\nexport interface AlertProps extends React.HTMLAttributes<HTMLDivElement> {\n    variant?: AlertVariant;\n    title?: string;\n    closable?: boolean;\n    onClose?: () => void;\n    icon?: React.ReactNode;\n}\n\nconst classesByVariant: Record<AlertVariant, string> = {\n    info: \"alert alert-info\",\n    success: \"alert alert-success\",\n    warning: \"alert alert-warning\",\n    error: \"alert alert-error\",\n};\n\nexport const Alert = React.forwardRef<HTMLDivElement, AlertProps>(\n    ({ variant = \"info\", title, closable = false, onClose, icon, className, children, ...rest }, ref) => {\n        const classes = `${classesByVariant[variant]} ${className || \"\"}`.trim();\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                role=\"alert\"\n            >\n                <div className=\"alert-content\">\n                    {icon && <div className=\"alert-icon\">{icon}</div>}\n                    <div className=\"alert-body\">\n                        {title && <div className=\"alert-title\">{title}</div>}\n                        {children && <div className=\"alert-message\">{children}</div>}\n                    </div>\n                    {closable && (\n                        <button\n                            className=\"alert-close\"\n                            onClick={onClose}\n                            aria-label=\"Close alert\"\n                            type=\"button\"\n                        >\n                            ×\n                        </button>\n                    )}\n                </div>\n            </div>\n        );\n    }\n);\nAlert.displayName = \"Alert\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Alert } from \"../Alert\";\n\ntest(\"renders with message\", () => {\n    render(<Alert>This is an alert message</Alert>);\n    expect(screen.getByRole(\"alert\")).toHaveTextContent(\"This is an alert message\");\n});\n\ntest(\"renders with title and message\", () => {\n    render(<Alert title=\"Success\">Operation completed successfully</Alert>);\n    expect(screen.getByText(\"Success\")).toBeInTheDocument();\n    expect(screen.getByText(\"Operation completed successfully\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Alert variant=\"error\">Error message</Alert>);\n    expect(screen.getByRole(\"alert\")).toHaveClass(\"alert\", \"alert-error\");\n});\n\ntest(\"shows close button when closable\", () => {\n    const onClose = vi.fn();\n    render(<Alert closable onClose={onClose}>Closable alert</Alert>);\n    expect(screen.getByLabelText(\"Close alert\")).toBeInTheDocument();\n});\n\ntest(\"calls onClose when close button clicked\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(<Alert closable onClose={onClose}>Closable alert</Aler t>);\n\n    await user.click(screen.getByLabelText(\"Close alert\"));\n    expect(onClose).toHaveBeenCalledTimes(1);\n});\n\ntest(\"renders with icon\", () => {\n    render(<Alert icon={<span>!</span>}>Alert with icon</Alert>);\n    expect(screen.getByText(\"!\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nconst getInitials = (name: string) => {\n  const [firstName, lastName] = name.split(\" \");\n  return firstName && lastName\n    ? `${firstName.charAt(0)}${lastName.charAt(0)}`\n    : firstName.charAt(0);\n};\n\ntype AvatarSize = \"sm\" | \"md\" | \"lg\";\n\nexport interface AvatarProps extends React.HTMLAttributes<HTMLSpanElement> {\n  src?: string;\n  alt?: string;\n  fallback?: React.ReactNode;\n  size?: AvatarSize;\n}\n\nexport const Avatar = React.forwardRef<HTMLSpanElement, AvatarProps>(\n  ({ src, alt, fallback, size = \"md\", className, ...rest }, ref) => {\n    const [hasError, setHasError] = React.useState(false);\n\n    const handleError = () => {\n      setHasError(true);\n    };\n\n    const showImage = src && !hasError;\n    let fallbackContent = fallback;\n\n    if (!fallbackContent && alt) {\n      fallbackContent = getInitials(alt);\n    } else if (!fallbackContent) {\n      fallbackContent = \"?\";\n    }\n    \n    const classes = `avatar avatar-${size} ${className || \"\"}`.trim();\n\n    return (\n      <span\n        {...rest}\n        ref={ref}\n        className={classes}\n        role=\"img\"\n        aria-label={alt}\n      >\n        {showImage ? (\n          <img src={src} alt=\"\" onError={handleError} />\n        ) : (\n          <span className=\"avatar-fallback\">{fallbackContent}</span>\n        )}\n      </span>\n    );\n  }\n);\nAvatar.displayName = \"Avatar\";",
    "output": "import { render, screen, fireEvent } from \"@testing-library/react\";\nimport { Avatar } from \"../Avatar\";\n\ntest(\"renders image when src is provided\", () => {\n    render(<Avatar src=\"https://example.com/avatar.jpg\" alt=\"User avatar\" />);\n    const img = screen.getByRole(\"img\", { name: /user avatar/i });\n    expect(img.querySelector(\"img\")).toHaveAttribute(\"src\", \"https://example.com/avatar.jpg\");\n});\n\ntest(\"shows fallback when image fails to load\", () => {\n    render(<Avatar src=\"invalid-url\" alt=\"John Doe\" />);\n    const avatar = screen.getByRole(\"img\", { name: /john doe/i });\n    const img = avatar.querySelector(\"img\");\n\n    if (img) {\n        fireEvent.error(img);\n    }\n\n    expect(screen.getByText(\"J\")).toBeInTheDocument();\n});\n\ntest(\"shows custom fallback\", () => {\n    render(<Avatar fallback=\"AB\" alt=\"User\" />);\n    expect(screen.getByText(\"AB\")).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n    render(<Avatar size=\"lg\" alt=\"Large avatar\" />);\n    expect(screen.getByRole(\"img\")).toHaveClass(\"avatar\", \"avatar-lg\");\n});\n\ntest(\"shows question mark when no alt or fallback\", () => {\n    render(<Avatar />);\n    expect(screen.getByText(\"?\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nconst getInitials = (name: string) => {\n  const [firstName, lastName] = name.split(\" \");\n  return firstName && lastName\n    ? `${firstName.charAt(0)}${lastName.charAt(0)}`\n    : firstName.charAt(0);\n};\n\ntype AvatarSize = \"sm\" | \"md\" | \"lg\";\n\nexport interface AvatarProps extends React.HTMLAttributes<HTMLSpanElement> {\n  src?: string;\n  alt?: string;\n  fallback?: React.ReactNode;\n  size?: AvatarSize;\n}\n\nexport const Avatar = React.forwardRef<HTMLSpanElement, AvatarProps>(\n  ({ src, alt, fallback, size = \"md\", className, ...rest }, ref) => {\n    const [hasError, setHasError] = React.useState(false);\n\n    const handleError = () => {\n      setHasError(true);\n    };\n\n    const showImage = src && !hasError;\n    let fallbackContent = fallback;\n\n    if (!fallbackContent && alt) {\n      fallbackContent = getInitials(alt);\n    } else if (!fallbackContent) {\n      fallbackContent = \"?\";\n    }\n    \n    const classes = `avatar avatar-${size} ${className || \"\"}`.trim();\n\n    return (\n      <span\n        {...rest}\n        ref={ref}\n        className={classes}\n        role=\"img\"\n        aria-label={alt}\n      >\n        {showImage ? (\n          <img src={src} alt=\"\" onError={handleError} />\n        ) : (\n          <span className=\"avatar-fallback\">{fallbackContent}</span>\n        )}\n      </span>\n    );\n  }\n);\nAvatar.displayName = \"Avatar\";",
    "output": "import { render, screen, fireEvent } from \"@testing-library/react\";\nimport { Avatar } from \"../Avatar\";\n\ntest(\"renders image when src is provided\", () => {\n    render(<Avatar src=\"https://example.com/avatar.jpg\" alt=\"User avatar\" />);\n    const img = screen.getByRole(\"img\", { name: /user avatar/i });\n    expect(img.querySelector(\"img\")).toHaveAttribute(\"src\", \"https://example.com/avatar.jpg\");\n});\n\ntest(\"shows fallback when image fails to load\", () => {\n    render(<Avatar src=\"invalid-url\" alt=\"John Doe\" />);\n    const avatar = screen.getByRole(\"img\", { name: /john doe/i });\n    const img = avatar.querySelector(\"img\");\n\n    if (img) {\n        fireEvent.error(img);\n    }\n\n    expect(screen.getByText(\"J\")).toBeInTheDocument();\n});\n\ntest(\"shows custom fallback\", () => {\n    render(<Avatar fallback=\"AB\" alt=\"User\" />);\n    expect(screen.getByText(\"AB\")).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n    render(<Avatar size=\"lg\" alt=\"Large avatar\" />);\n    expect(screen.getByRole(\"img\")).toHaveClass(\"avatar\", \"avatar-lg\");\n});\n\ntest(\"shows question mark when no alt or fallback\", () => {\n    render(<Avatar />);\n    expect(screen.getByText(\"?\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nconst getInitials = (name: string) => {\n  const [firstName, lastName] = name.split(\" \");\n  return firstName && lastName\n    ? `${firstName.charAt(0)}${lastName.charAt(0)}`\n    : firstName.charAt(0);\n};\n\ntype AvatarSize = \"sm\" | \"md\" | \"lg\";\n\nexport interface AvatarProps extends React.HTMLAttributes<HTMLSpanElement> {\n  src?: string;\n  alt?: string;\n  fallback?: React.ReactNode;\n  size?: AvatarSize;\n}\n\nexport const Avatar = React.forwardRef<HTMLSpanElement, AvatarProps>(\n  ({ src, alt, fallback, size = \"md\", className, ...rest }, ref) => {\n    const [hasError, setHasError] = React.useState(false);\n\n    const handleError = () => {\n      setHasError(true);\n    };\n\n    const showImage = src && !hasError;\n    let fallbackContent = fallback;\n\n    if (!fallbackContent && alt) {\n      fallbackContent = getInitials(alt);\n    } else if (!fallbackContent) {\n      fallbackContent = \"?\";\n    }\n    \n    const classes = `avatar avatar-${size} ${className || \"\"}`.trim();\n\n    return (\n      <span\n        {...rest}\n        ref={ref}\n        className={classes}\n        role=\"img\"\n        aria-label={alt}\n      >\n        {showImage ? (\n          <img src={src} alt=\"\" onError={handleError} />\n        ) : (\n          <span className=\"avatar-fallback\">{fallbackContent}</span>\n        )}\n      </span>\n    );\n  }\n);\nAvatar.displayName = \"Avatar\";",
    "output": "import { render, screen, fireEvent } from \"@testing-library/react\";\nimport { Avatar } from \"../Avatar\";\n\ntest(\"renders image when src is provided\", () => {\n    render(<Avatar src=\"https://example.com/avatar.jpg\" alt=\"User avatar\" />);\n    const img = screen.getByRole(\"img\", { name: /user avatar/i });\n    expect(img.querySelector(\"img\")).toHaveAttribute(\"src\", \"https://example.com/avatar.jpg\");\n});\n\ntest(\"shows fallback when image fails to load\", () => {\n    render(<Avatar src=\"invalid-url\" alt=\"John Doe\" />);\n    const avatar = screen.getByRole(\"img\", { name: /john doe/i });\n    const img = avatar.querySelector(\"img\");\n\n    if (img) {\n        fireEvent.error(img);\n    }\n\n    expect(screen.getByText(\"J\")).toBeInTheDocument();\n});\n\ntest(\"shows custom fallback\", () => {\n    render(<Avatar fallback=\"AB\" alt=\"User\" />);\n    expect(screen.getByText(\"AB\")).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n    render(<Avatar size=\"lg\" alt=\"Large avatar\" />);\n    expect(screen.getByRole(\"img\")).toHaveClass(\"avatar\", \"avatar-lg\");\n});\n\ntest(\"shows question mark when no alt or fallback\", () => {\n    render(<Avatar />);\n    expect(screen.getByText(\"?\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\ntype BadgeVariant = \"default\" | \"success\" | \"warning\" | \"error\" | \"info\";\ntype BadgeSize = \"sm\" | \"md\" | \"lg\";\n\nexport interface BadgeProps extends React.HTMLAttributes<HTMLSpanElement> {\n    variant?: BadgeVariant;\n    size?: BadgeSize;\n    children: React.ReactNode;\n}\n\nconst classesByVariant: Record<BadgeVariant, string> = {\n    default: \"badge badge-default\",\n    success: \"badge badge-success\",\n    warning: \"badge badge-warning\",\n    error: \"badge badge-error\",\n    info: \"badge badge-info\",\n};\n\nconst classesBySize: Record<BadgeSize, string> = {\n    sm: \"badge-sm\",\n    md: \"badge-md\",\n    lg: \"badge-lg\",\n};\n\nexport const Badge = React.forwardRef<HTMLSpanElement, BadgeProps>(\n    ({ variant = \"default\", size = \"md\", className, children, ...rest }, ref) => {\n        const classes = `${classesByVariant[variant]} ${classesBySize[size]} ${className || \"\"}`.trim();\n\n        return (\n            <span\n                {...rest}\n                ref={ref}\n                className={classes}\n            >\n                {children}\n            </span>\n        );\n    }\n);\nBadge.displayName = \"Badge\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Badge } from \"../Badge\";\n\ntest(\"renders with children\", () => {\n    render(<Badge>New</Badge>);\n    expect(screen.getByText(\"New\")).toBeInTheDocument();\n});\n\ntest(\"applies default variant and size classes\", () => {\n    render(<Badge>Default</Badge>);\n    const badge = screen.getByText(\"Default\");\n    expect(badge).toHaveClass(\"badge\", \"badge-default\", \"badge-md\");\n});\n\ntest(\"applies custom variant class\", () => {\n    render(<Badge variant=\"success\">Success</Badge>);\n    expect(screen.getByText(\"Success\")).toHaveClass(\"badge\", \"badge-success\");\n});\n\ntest(\"applies custom size class\", () => {\n    render(<Badge size=\"lg\">Large</Badge>);\n    expect(screen.getByText(\"Large\")).toHaveClass(\"badge-lg\");\n});\n\ntest(\"forwards additional props\", () => {\n    render(<Badge data-testid=\"custom-badge\">Test</Badge>);\n    expect(screen.getByTestId(\"custom-badge\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\ntype BadgeVariant = \"default\" | \"success\" | \"warning\" | \"error\" | \"info\";\ntype BadgeSize = \"sm\" | \"md\" | \"lg\";\n\nexport interface BadgeProps extends React.HTMLAttributes<HTMLSpanElement> {\n    variant?: BadgeVariant;\n    size?: BadgeSize;\n    children: React.ReactNode;\n}\n\nconst classesByVariant: Record<BadgeVariant, string> = {\n    default: \"badge badge-default\",\n    success: \"badge badge-success\",\n    warning: \"badge badge-warning\",\n    error: \"badge badge-error\",\n    info: \"badge badge-info\",\n};\n\nconst classesBySize: Record<BadgeSize, string> = {\n    sm: \"badge-sm\",\n    md: \"badge-md\",\n    lg: \"badge-lg\",\n};\n\nexport const Badge = React.forwardRef<HTMLSpanElement, BadgeProps>(\n    ({ variant = \"default\", size = \"md\", className, children, ...rest }, ref) => {\n        const classes = `${classesByVariant[variant]} ${classesBySize[size]} ${className || \"\"}`.trim();\n\n        return (\n            <span\n                {...rest}\n                ref={ref}\n                className={classes}\n            >\n                {children}\n            </span>\n        );\n    }\n);\nBadge.displayName = \"Badge\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Badge } from \"../Badge\";\n\ntest(\"renders with children\", () => {\n    render(<Badge>New</Badge>);\n    expect(screen.getByText(\"New\")).toBeInTheDocument();\n});\n\ntest(\"applies default variant and size classes\", () => {\n    render(<Badge>Default</Badge>);\n    const badge = screen.getByText(\"Default\");\n    expect(badge).toHaveClass(\"badge\", \"badge-default\", \"badge-md\");\n});\n\ntest(\"applies custom variant class\", () => {\n    render(<Badge variant=\"success\">Success</Badge>);\n    expect(screen.getByText(\"Success\")).toHaveClass(\"badge\", \"badge-success\");\n});\n\ntest(\"applies custom size class\", () => {\n    render(<Badge size=\"lg\">Large</Badge>);\n    expect(screen.getByText(\"Large\")).toHaveClass(\"badge-lg\");\n});\n\ntest(\"forwards additional props\", () => {\n    render(<Badge data-testid=\"custom-badge\">Test</Badge>);\n    expect(screen.getByTestId(\"custom-badge\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\ntype BadgeVariant = \"default\" | \"success\" | \"warning\" | \"error\" | \"info\";\ntype BadgeSize = \"sm\" | \"md\" | \"lg\";\n\nexport interface BadgeProps extends React.HTMLAttributes<HTMLSpanElement> {\n    variant?: BadgeVariant;\n    size?: BadgeSize;\n    children: React.ReactNode;\n}\n\nconst classesByVariant: Record<BadgeVariant, string> = {\n    default: \"badge badge-default\",\n    success: \"badge badge-success\",\n    warning: \"badge badge-warning\",\n    error: \"badge badge-error\",\n    info: \"badge badge-info\",\n};\n\nconst classesBySize: Record<BadgeSize, string> = {\n    sm: \"badge-sm\",\n    md: \"badge-md\",\n    lg: \"badge-lg\",\n};\n\nexport const Badge = React.forwardRef<HTMLSpanElement, BadgeProps>(\n    ({ variant = \"default\", size = \"md\", className, children, ...rest }, ref) => {\n        const classes = `${classesByVariant[variant]} ${classesBySize[size]} ${className || \"\"}`.trim();\n\n        return (\n            <span\n                {...rest}\n                ref={ref}\n                className={classes}\n            >\n                {children}\n            </span>\n        );\n    }\n);\nBadge.displayName = \"Badge\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Badge } from \"../Badge\";\n\ntest(\"renders with children\", () => {\n    render(<Badge>New</Badge>);\n    expect(screen.getByText(\"New\")).toBeInTheDocument();\n});\n\ntest(\"applies default variant and size classes\", () => {\n    render(<Badge>Default</Badge>);\n    const badge = screen.getByText(\"Default\");\n    expect(badge).toHaveClass(\"badge\", \"badge-default\", \"badge-md\");\n});\n\ntest(\"applies custom variant class\", () => {\n    render(<Badge variant=\"success\">Success</Badge>);\n    expect(screen.getByText(\"Success\")).toHaveClass(\"badge\", \"badge-success\");\n});\n\ntest(\"applies custom size class\", () => {\n    render(<Badge size=\"lg\">Large</Badge>);\n    expect(screen.getByText(\"Large\")).toHaveClass(\"badge-lg\");\n});\n\ntest(\"forwards additional props\", () => {\n    render(<Badge data-testid=\"custom-badge\">Test</Badge>);\n    expect(screen.getByTestId(\"custom-badge\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface BreadcrumbItem {\n    label: string;\n    href?: string;\n    onClick?: () => void;\n}\n\nexport interface BreadcrumbProps extends React.HTMLAttributes<HTMLElement> {\n    items: BreadcrumbItem[];\n    separator?: React.ReactNode;\n    maxItems?: number;\n}\n\nexport const Breadcrumb = React.forwardRef<HTMLElement, BreadcrumbProps>(\n    ({ items, separator = \"/\", maxItems, className, ...rest }, ref) => {\n        const classes = `breadcrumb ${className || \"\"}`.trim();\n\n        const displayItems = maxItems && items.length > maxItems\n            ? [\n                items[0],\n                { label: \"...\", href: undefined, onClick: undefined },\n                ...items.slice(-(maxItems - 2))\n            ]\n            : items;\n\n        return (\n            <nav {...rest} ref={ref} className={classes} aria-label=\"Breadcrumb\">\n                <ol className=\"breadcrumb-list\">\n                    {displayItems.map((item, index) => {\n                        const isLast = index === displayItems.length - 1;\n                        const isEllipsis = item.label === \"...\";\n\n                        return (\n                            <li key={index} className=\"breadcrumb-item\">\n                                {isEllipsis ? (\n                                    <span className=\"breadcrumb-ellipsis\" aria-hidden=\"true\">\n                                        {item.label}\n                                    </span>\n                                ) : isLast ? (\n                                    <span className=\"breadcrumb-current\" aria-current=\"page\">\n                                        {item.label}\n                                    </span>\n                                ) : item.href ? (\n                                    <a href={item.href} className=\"breadcrumb-link\">\n                                        {item.label}\n                                    </a>\n                                ) : (\n                                    <button\n                                        type=\"button\"\n                                        className=\"breadcrumb-button\"\n                                        onClick={item.onClick}\n                                    >\n                                        {item.label}\n                                    </button>\n                                )}\n                                {!isLast && (\n                                    <span className=\"breadcrumb-separator\" aria-hidden=\"true\">\n                                        {separator}\n                                    </span>\n                                )}\n                            </li>\n                        );\n                    })}\n                </ol>\n            </nav>\n        );\n    }\n);\nBreadcrumb.displayName = \"Breadcrumb\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Breadcrumb } from \"../Breadcrumb\";\n\nconst mockItems = [\n    { label: \"Home\", href: \"/\" },\n    { label: \"Products\", href: \"/products\" },\n    { label: \"Shoes\", onClick: vi.fn() },\n    { label: \"Current Page\" },\n];\n\ntest(\"renders breadcrumb items\", () => {\n    render(<Breadcrumb items={mockItems} />);\n    expect(screen.getByText(\"Home\")).toBeInTheDocument();\n    expect(screen.getByText(\"Products\")).toBeInTheDocument();\n    expect(screen.getByText(\"Shoes\")).toBeInTheDocument();\n    expect(screen.getByText(\"Current Page\")).toBeInTheDocument();\n});\n\ntest(\"renders links for items with href\", () => {\n    render(<Breadcrumb items={mockItems} />);\n    const homeLink = screen.getByRole(\"link\", { name: \"Home\" });\n    expect(homeLink).toHaveAttribute(\"href\", \"/\");\n});\n\ntest(\"renders buttons for items with onClick\", async () => {\n    const user = userEvent.setup();\n    const onClick = vi.fn();\n    const items = [{ label: \"Clickable\", onClick }];\n\n    render(<Breadcrumb items={items} />);\n    const button = screen.getByRole(\"button\", { name: \"Clickable\" });\n\n    await user.click(button);\n    expect(onClick).toHaveBeenCalledTimes(1);\n});\n\ntest(\"marks last item as current\", () => {\n    render(<Breadcrumb items={mockItems} />);\n    const currentItem = screen.getByText(\"Current Page\");\n    expect(currentItem).toHaveAttribute(\"aria-current\", \"page\");\n});\n\ntest(\"shows custom separator\", () => {\n    render(<Breadcrumb items={mockItems} separator=\">\" />);\n    expect(screen.getAllByText(\">\")).toHaveLength(3);\n});\n\ntest(\"truncates items when maxItems is set\", () => {\n    const manyItems = [\n        { label: \"Item 1\" },\n        { label: \"Item 2\" },\n        { label: \"Item 3\" },\n        { label: \"Item 4\" },\n        { label: \"Item 5\" },\n    ];\n\n    render(<Breadcrumb items={manyItems} maxItems={4} />);\n    expect(screen.getByText(\"Item 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"...\")).toBeInTheDocument();\n    expect(screen.getByText(\"Item 4\")).toBeInTheDocument();\n    expect(screen.getByText(\"Item 5\")).toBeInTheDocument();\n    expect(screen.queryByText(\"Item 2\")).not.toBeInTheDocument();\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface BreadcrumbItem {\n    label: string;\n    href?: string;\n    onClick?: () => void;\n}\n\nexport interface BreadcrumbProps extends React.HTMLAttributes<HTMLElement> {\n    items: BreadcrumbItem[];\n    separator?: React.ReactNode;\n    maxItems?: number;\n}\n\nexport const Breadcrumb = React.forwardRef<HTMLElement, BreadcrumbProps>(\n    ({ items, separator = \"/\", maxItems, className, ...rest }, ref) => {\n        const classes = `breadcrumb ${className || \"\"}`.trim();\n\n        const displayItems = maxItems && items.length > maxItems\n            ? [\n                items[0],\n                { label: \"...\", href: undefined, onClick: undefined },\n                ...items.slice(-(maxItems - 2))\n            ]\n            : items;\n\n        return (\n            <nav {...rest} ref={ref} className={classes} aria-label=\"Breadcrumb\">\n                <ol className=\"breadcrumb-list\">\n                    {displayItems.map((item, index) => {\n                        const isLast = index === displayItems.length - 1;\n                        const isEllipsis = item.label === \"...\";\n\n                        return (\n                            <li key={index} className=\"breadcrumb-item\">\n                                {isEllipsis ? (\n                                    <span className=\"breadcrumb-ellipsis\" aria-hidden=\"true\">\n                                        {item.label}\n                                    </span>\n                                ) : isLast ? (\n                                    <span className=\"breadcrumb-current\" aria-current=\"page\">\n                                        {item.label}\n                                    </span>\n                                ) : item.href ? (\n                                    <a href={item.href} className=\"breadcrumb-link\">\n                                        {item.label}\n                                    </a>\n                                ) : (\n                                    <button\n                                        type=\"button\"\n                                        className=\"breadcrumb-button\"\n                                        onClick={item.onClick}\n                                    >\n                                        {item.label}\n                                    </button>\n                                )}\n                                {!isLast && (\n                                    <span className=\"breadcrumb-separator\" aria-hidden=\"true\">\n                                        {separator}\n                                    </span>\n                                )}\n                            </li>\n                        );\n                    })}\n                </ol>\n            </nav>\n        );\n    }\n);\nBreadcrumb.displayName = \"Breadcrumb\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Breadcrumb } from \"../Breadcrumb\";\n\nconst mockItems = [\n    { label: \"Home\", href: \"/\" },\n    { label: \"Products\", href: \"/products\" },\n    { label: \"Shoes\", onClick: vi.fn() },\n    { label: \"Current Page\" },\n];\n\ntest(\"renders breadcrumb items\", () => {\n    render(<Breadcrumb items={mockItems} />);\n    expect(screen.getByText(\"Home\")).toBeInTheDocument();\n    expect(screen.getByText(\"Products\")).toBeInTheDocument();\n    expect(screen.getByText(\"Shoes\")).toBeInTheDocument();\n    expect(screen.getByText(\"Current Page\")).toBeInTheDocument();\n});\n\ntest(\"renders links for items with href\", () => {\n    render(<Breadcrumb items={mockItems} />);\n    const homeLink = screen.getByRole(\"link\", { name: \"Home\" });\n    expect(homeLink).toHaveAttribute(\"href\", \"/\");\n});\n\ntest(\"renders buttons for items with onClick\", async () => {\n    const user = userEvent.setup();\n    const onClick = vi.fn();\n    const items = [{ label: \"Clickable\", onClick }];\n\n    render(<Breadcrumb items={items} />);\n    const button = screen.getByRole(\"button\", { name: \"Clickable\" });\n\n    await user.click(button);\n    expect(onClick).toHaveBeenCalledTimes(1);\n});\n\ntest(\"marks last item as current\", () => {\n    render(<Breadcrumb items={mockItems} />);\n    const currentItem = screen.getByText(\"Current Page\");\n    expect(currentItem).toHaveAttribute(\"aria-current\", \"page\");\n});\n\ntest(\"shows custom separator\", () => {\n    render(<Breadcrumb items={mockItems} separator=\">\" />);\n    expect(screen.getAllByText(\">\")).toHaveLength(3);\n});\n\ntest(\"truncates items when maxItems is set\", () => {\n    const manyItems = [\n        { label: \"Item 1\" },\n        { label: \"Item 2\" },\n        { label: \"Item 3\" },\n        { label: \"Item 4\" },\n        { label: \"Item 5\" },\n    ];\n\n    render(<Breadcrumb items={manyItems} maxItems={4} />);\n    expect(screen.getByText(\"Item 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"...\")).toBeInTheDocument();\n    expect(screen.getByText(\"Item 4\")).toBeInTheDocument();\n    expect(screen.getByText(\"Item 5\")).toBeInTheDocument();\n    expect(screen.queryByText(\"Item 2\")).not.toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface BreadcrumbItem {\n    label: string;\n    href?: string;\n    onClick?: () => void;\n}\n\nexport interface BreadcrumbProps extends React.HTMLAttributes<HTMLElement> {\n    items: BreadcrumbItem[];\n    separator?: React.ReactNode;\n    maxItems?: number;\n}\n\nexport const Breadcrumb = React.forwardRef<HTMLElement, BreadcrumbProps>(\n    ({ items, separator = \"/\", maxItems, className, ...rest }, ref) => {\n        const classes = `breadcrumb ${className || \"\"}`.trim();\n\n        const displayItems = maxItems && items.length > maxItems\n            ? [\n                items[0],\n                { label: \"...\", href: undefined, onClick: undefined },\n                ...items.slice(-(maxItems - 2))\n            ]\n            : items;\n\n        return (\n            <nav {...rest} ref={ref} className={classes} aria-label=\"Breadcrumb\">\n                <ol className=\"breadcrumb-list\">\n                    {displayItems.map((item, index) => {\n                        const isLast = index === displayItems.length - 1;\n                        const isEllipsis = item.label === \"...\";\n\n                        return (\n                            <li key={index} className=\"breadcrumb-item\">\n                                {isEllipsis ? (\n                                    <span className=\"breadcrumb-ellipsis\" aria-hidden=\"true\">\n                                        {item.label}\n                                    </span>\n                                ) : isLast ? (\n                                    <span className=\"breadcrumb-current\" aria-current=\"page\">\n                                        {item.label}\n                                    </span>\n                                ) : item.href ? (\n                                    <a href={item.href} className=\"breadcrumb-link\">\n                                        {item.label}\n                                    </a>\n                                ) : (\n                                    <button\n                                        type=\"button\"\n                                        className=\"breadcrumb-button\"\n                                        onClick={item.onClick}\n                                    >\n                                        {item.label}\n                                    </button>\n                                )}\n                                {!isLast && (\n                                    <span className=\"breadcrumb-separator\" aria-hidden=\"true\">\n                                        {separator}\n                                    </span>\n                                )}\n                            </li>\n                        );\n                    })}\n                </ol>\n            </nav>\n        );\n    }\n);\nBreadcrumb.displayName = \"Breadcrumb\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Breadcrumb } from \"../Breadcrumb\";\n\nconst mockItems = [\n    { label: \"Home\", href: \"/\" },\n    { label: \"Products\", href: \"/products\" },\n    { label: \"Shoes\", onClick: vi.fn() },\n    { label: \"Current Page\" },\n];\n\ntest(\"renders breadcrumb items\", () => {\n    render(<Breadcrumb items={mockItems} />);\n    expect(screen.getByText(\"Home\")).toBeInTheDocument();\n    expect(screen.getByText(\"Products\")).toBeInTheDocument();\n    expect(screen.getByText(\"Shoes\")).toBeInTheDocument();\n    expect(screen.getByText(\"Current Page\")).toBeInTheDocument();\n});\n\ntest(\"renders links for items with href\", () => {\n    render(<Breadcrumb items={mockItems} />);\n    const homeLink = screen.getByRole(\"link\", { name: \"Home\" });\n    expect(homeLink).toHaveAttribute(\"href\", \"/\");\n});\n\ntest(\"renders buttons for items with onClick\", async () => {\n    const user = userEvent.setup();\n    const onClick = vi.fn();\n    const items = [{ label: \"Clickable\", onClick }];\n\n    render(<Breadcrumb items={items} />);\n    const button = screen.getByRole(\"button\", { name: \"Clickable\" });\n\n    await user.click(button);\n    expect(onClick).toHaveBeenCalledTimes(1);\n});\n\ntest(\"marks last item as current\", () => {\n    render(<Breadcrumb items={mockItems} />);\n    const currentItem = screen.getByText(\"Current Page\");\n    expect(currentItem).toHaveAttribute(\"aria-current\", \"page\");\n});\n\ntest(\"shows custom separator\", () => {\n    render(<Breadcrumb items={mockItems} separator=\">\" />);\n    expect(screen.getAllByText(\">\")).toHaveLength(3);\n});\n\ntest(\"truncates items when maxItems is set\", () => {\n    const manyItems = [\n        { label: \"Item 1\" },\n        { label: \"Item 2\" },\n        { label: \"Item 3\" },\n        { label: \"Item 4\" },\n        { label: \"Item 5\" },\n    ];\n\n    render(<Breadcrumb items={manyItems} maxItems={4} />);\n    expect(screen.getByText(\"Item 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"...\")).toBeInTheDocument();\n    expect(screen.getByText(\"Item 4\")).toBeInTheDocument();\n    expect(screen.getByText(\"Item 5\")).toBeInTheDocument();\n    expect(screen.queryByText(\"Item 2\")).not.toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface CalendarEvent {\n  id: string;\n  title: string;\n  start: Date;\n  end: Date;\n  color?: string;\n  allDay?: boolean;\n  description?: string;\n}\n\nexport interface CalendarProps extends React.HTMLAttributes<HTMLDivElement> {\n  value?: Date;\n  defaultValue?: Date;\n  onChange?: (date: Date) => void;\n  mode?: \"month\" | \"year\" | \"decade\";\n  events?: CalendarEvent[];\n  onEventClick?: (event: CalendarEvent) => void;\n  disabledDate?: (date: Date) => boolean;\n  cellRender?: (date: Date, events: CalendarEvent[]) => React.ReactNode;\n  headerRender?: (date: Date, onNavigate: (date: Date) => void) => React.ReactNode;\n  showWeekNumbers?: boolean;\n  firstDayOfWeek?: 0 | 1 | 2 | 3 | 4 | 5 | 6; // 0 = Sunday\n  locale?: {\n    monthNames: string[];\n    dayNames: string[];\n    today: string;\n  };\n}\n\nconst defaultLocale = {\n  monthNames: [\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n  ],\n  dayNames: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n  today: \"Today\"\n};\n\nexport const Calendar = React.forwardRef<HTMLDivElement, CalendarProps>(\n  ({\n    value: controlledValue,\n    defaultValue,\n    onChange,\n    mode = \"month\",\n    events = [],\n    onEventClick,\n    disabledDate,\n    cellRender,\n    headerRender,\n    showWeekNumbers = false,\n    firstDayOfWeek = 0,\n    locale = defaultLocale,\n    className,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState<Date>(\n      defaultValue || new Date()\n    );\n    const [viewDate, setViewDate] = React.useState<Date>(\n      controlledValue || defaultValue || new Date()\n    );\n\n    const isControlled = controlledValue !== undefined;\n    const currentValue = isControlled ? controlledValue : internalValue;\n\n    const classes = `calendar calendar-${mode} ${className || \"\"}`.trim();\n\n    const updateValue = (newValue: Date) => {\n      if (onChange) {\n        onChange(newValue);\n      }\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n    };\n\n    const isSameDay = (date1: Date, date2: Date): boolean => {\n      return date1.getDate() === date2.getDate() &&\n             date1.getMonth() === date2.getMonth() &&\n             date1.getFullYear() === date2.getFullYear();\n    };\n\n    const isSameMonth = (date1: Date, date2: Date): boolean => {\n      return date1.getMonth() === date2.getMonth() &&\n             date1.getFullYear() === date2.getFullYear();\n    };\n\n    const isToday = (date: Date): boolean => {\n      return isSameDay(date, new Date());\n    };\n\n    const getWeekNumber = (date: Date): number => {\n      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\n      const dayNum = d.getUTCDay() || 7;\n      d.setUTCDate(d.getUTCDate() + 4 - dayNum);\n      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n      return Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);\n    };\n\n    const getMonthDays = (date: Date): Date[][] => {\n      const year = date.getFullYear();\n      const month = date.getMonth();\n      const firstDay = new Date(year, month, 1);\n      const lastDay = new Date(year, month + 1, 0);\n      \n      const startDay = (firstDay.getDay() - firstDayOfWeek + 7) % 7;\n      const startDate = new Date(firstDay);\n      startDate.setDate(startDate.getDate() - startDay);\n\n      const weeks: Date[][] = [];\n      let currentWeek: Date[] = [];\n      \n      for (let i = 0; i < 42; i++) { // 6 weeks max\n        const currentDate = new Date(startDate);\n        currentDate.setDate(startDate.getDate() + i);\n        \n        currentWeek.push(currentDate);\n        \n        if (currentWeek.length === 7) {\n          weeks.push(currentWeek);\n          currentWeek = [];\n        }\n        \n        if (currentDate > lastDay && currentWeek.length === 0) {\n          break;\n        }\n      }\n      \n      return weeks;\n    };\n\n    const getYearMonths = (date: Date): Date[] => {\n      const year = date.getFullYear();\n      return Array.from({ length: 12 }, (_, i) => new Date(year, i, 1));\n    };\n\n    const getDecadeYears = (date: Date): Date[] => {\n      const year = date.getFullYear();\n      const startYear = Math.floor(year / 10) * 10;\n      return Array.from({ length: 12 }, (_, i) => new Date(startYear + i - 1, 0, 1));\n    };\n\n    const getEventsForDate = (date: Date): CalendarEvent[] => {\n      return events.filter(event => {\n        if (event.allDay) {\n          return isSameDay(event.start, date);\n        }\n        return event.start <= date && event.end >= date;\n      });\n    };\n\n    const handleDateClick = (date: Date) => {\n      if (disabledDate && disabledDate(date)) return;\n      \n      if (mode === \"month\") {\n        updateValue(date);\n      } else if (mode === \"year\") {\n        setViewDate(date);\n      } else if (mode === \"decade\") {\n        setViewDate(date);\n      }\n    };\n\n    const handleEventClick = (event: CalendarEvent, e: React.MouseEvent) => {\n      e.stopPropagation();\n      if (onEventClick) {\n        onEventClick(event);\n      }\n    };\n\n    const navigateMonth = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setMonth(newDate.getMonth() + direction);\n      setViewDate(newDate);\n    };\n\n    const navigateYear = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setFullYear(newDate.getFullYear() + direction);\n      setViewDate(newDate);\n    };\n\n    const navigateDecade = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setFullYear(newDate.getFullYear() + (direction * 10));\n      setViewDate(newDate);\n    };\n\n    const handleNavigation = (direction: number) => {\n      switch (mode) {\n        case \"month\":\n          navigateMonth(direction);\n          break;\n        case \"year\":\n          navigateYear(direction);\n          break;\n        case \"decade\":\n          navigateDecade(direction);\n          break;\n      }\n    };\n\n    const renderMonthView = () => {\n      const weeks = getMonthDays(viewDate);\n      const orderedDayNames = [...locale.dayNames.slice(firstDayOfWeek), ...locale.dayNames.slice(0, firstDayOfWeek)];\n\n      return (\n        <div className=\"calendar-month-view\">\n          <div className=\"calendar-weekdays\">\n            {showWeekNumbers && <div className=\"calendar-weekday calendar-week-number-header\">Wk</div>}\n            {orderedDayNames.map(day => (\n              <div key={day} className=\"calendar-weekday\">\n                {day}\n              </div>\n            ))}\n          </div>\n          \n          <div className=\"calendar-month-body\">\n            {weeks.map((week, weekIndex) => (\n              <div key={weekIndex} className=\"calendar-week\">\n                {showWeekNumbers && (\n                  <div className=\"calendar-week-number\">\n                    {getWeekNumber(week[0])}\n                  </div>\n                )}\n                {week.map((date, dayIndex) => {\n                  const isCurrentMonth = isSameMonth(date, viewDate);\n                  const isSelected = isSameDay(date, currentValue);\n                  const isTodayDate = isToday(date);\n                  const isDisabled = disabledDate && disabledDate(date);\n                  const dayEvents = getEventsForDate(date);\n\n                  return (\n                    <div\n                      key={dayIndex}\n                      className={`calendar-cell calendar-date ${\n                        !isCurrentMonth ? \"calendar-date-other-month\" : \"\"\n                      } ${isSelected ? \"calendar-date-selected\" : \"\"} ${\n                        isTodayDate ? \"calendar-date-today\" : \"\"\n                      } ${isDisabled ? \"calendar-date-disabled\" : \"\"}`}\n                      onClick={() => handleDateClick(date)}\n                      role=\"gridcell\"\n                      aria-selected={isSelected}\n                      aria-label={date.toDateString()}\n                      tabIndex={isSelected ? 0 : -1}\n                    >\n                      {cellRender ? cellRender(date, dayEvents) : (\n                        <>\n                          <div className=\"calendar-date-content\">\n                            <span className=\"calendar-date-number\">{date.getDate()}</span>\n                          </div>\n                          {dayEvents.length > 0 && (\n                            <div className=\"calendar-events\">\n                              {dayEvents.slice(0, 3).map(event => (\n                                <div\n                                  key={event.id}\n                                  className=\"calendar-event\"\n                                  style={{ backgroundColor: event.color }}\n                                  onClick={(e) => handleEventClick(event, e)}\n                                  title={event.title}\n                                >\n                                  {event.title}\n                                </div>\n                              ))}\n                              {dayEvents.length > 3 && (\n                                <div className=\"calendar-event-more\">\n                                  +{dayEvents.length - 3} more\n                                </div>\n                              )}\n                            </div>\n                          )}\n                        </>\n                      )}\n                    </div>\n                  );\n                })}\n              </div>\n            ))}\n          </div>\n        </div>\n      );\n    };\n\n    const renderYearView = () => {\n      const months = getYearMonths(viewDate);\n\n      return (\n        <div className=\"calendar-year-view\">\n          <div className=\"calendar-year-body\">\n            {Array.from({ length: 4 }, (_, rowIndex) => (\n              <div key={rowIndex} className=\"calendar-year-row\">\n                {months.slice(rowIndex * 3, (rowIndex + 1) * 3).map(month => {\n                  const isSelected = isSameMonth(month, currentValue);\n                  const isCurrentMonth = isSameMonth(month, new Date());\n\n                  return (\n                    <div\n                      key={month.getMonth()}\n                      className={`calendar-cell calendar-month ${\n                        isSelected ? \"calendar-month-selected\" : \"\"\n                      } ${isCurrentMonth ? \"calendar-month-current\" : \"\"}`}\n                      onClick={() => handleDateClick(month)}\n                      role=\"gridcell\"\n                      aria-selected={isSelected}\n                      tabIndex={isSelected ? 0 : -1}\n                    >\n                      {locale.monthNames[month.getMonth()]}\n                    </div>\n                  );\n                })}\n              </div>\n            ))}\n          </div>\n        </div>\n      );\n    };\n\n    const renderDecadeView = () => {\n      const years = getDecadeYears(viewDate);\n\n      return (\n        <div className=\"calendar-decade-view\">\n          <div className=\"calendar-decade-body\">\n            {Array.from({ length: 4 }, (_, rowIndex) => (\n              <div key={rowIndex} className=\"calendar-decade-row\">\n                {years.slice(rowIndex * 3, (rowIndex + 1) * 3).map(year => {\n                  const isSelected = year.getFullYear() === currentValue.getFullYear();\n                  const isCurrentYear = year.getFullYear() === new Date().getFullYear();\n\n                  return (\n                    <div\n                      key={year.getFullYear()}\n                      className={`calendar-cell calendar-year ${\n                        isSelected ? \"calendar-year-selected\" : \"\"\n                      } ${isCurrentYear ? \"calendar-year-current\" : \"\"}`}\n                      onClick={() => handleDateClick(year)}\n                      role=\"gridcell\"\n                      aria-selected={isSelected}\n                      tabIndex={isSelected ? 0 : -1}\n                    >\n                      {year.getFullYear()}\n                    </div>\n                  );\n                })}\n              </div>\n            ))}\n          </div>\n        </div>\n      );\n    };\n\n    const getTitle = () => {\n      switch (mode) {\n        case \"month\":\n          return `${locale.monthNames[viewDate.getMonth()]} ${viewDate.getFullYear()}`;\n        case \"year\":\n          return viewDate.getFullYear().toString();\n        case \"decade\":\n          const startYear = Math.floor(viewDate.getFullYear() / 10) * 10;\n          return `${startYear}-${startYear + 9}`;\n        default:\n          return \"\";\n      }\n    };\n\n    return (\n      <div {...rest} ref={ref} className={classes} role=\"grid\">\n        {headerRender ? headerRender(viewDate, setViewDate) : (\n          <div className=\"calendar-header\">\n            <button\n              type=\"button\"\n              className=\"calendar-nav-button\"\n              onClick={() => handleNavigation(-1)}\n              aria-label=\"Previous\"\n            >\n              ‹\n            </button>\n            \n            <div className=\"calendar-title\" role=\"heading\" aria-level={2}>\n              {getTitle()}\n            </div>\n            \n            <button\n              type=\"button\"\n              className=\"calendar-nav-button\"\n              onClick={() => handleNavigation(1)}\n              aria-label=\"Next\"\n            >\n              ›\n            </button>\n          </div>\n        )}\n\n        <div className=\"calendar-body\">\n          {mode === \"month\" && renderMonthView()}\n          {mode === \"year\" && renderYearView()}\n          {mode === \"decade\" && renderDecadeView()}\n        </div>\n      </div>\n    );\n  }\n);\nCalendar.displayName = \"Calendar\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Calendar } from \"../Calendar\";\n\ntest(\"renders calendar in month view\", () => {\n  render(<Calendar defaultValue={new Date(2024, 5, 15)} />);\n  \n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n  expect(screen.getByRole(\"grid\")).toBeInTheDocument();\n});\n\ntest(\"shows weekday headers\", () => {\n  render(<Calendar />);\n  \n  expect(screen.getByText(\"Su\")).toBeInTheDocument();\n  expect(screen.getByText(\"Mo\")).toBeInTheDocument();\n  expect(screen.getByText(\"Tu\")).toBeInTheDocument();\n  expect(screen.getByText(\"We\")).toBeInTheDocument();\n  expect(screen.getByText(\"Th\")).toBeInTheDocument();\n  expect(screen.getByText(\"Fr\")).toBeInTheDocument();\n  expect(screen.getByText(\"Sa\")).toBeInTheDocument();\n});\n\ntest(\"navigates between months\", async () => {\n  const user = userEvent.setup();\n  render(<Calendar defaultValue={new Date(2024, 5, 15)} />);\n  \n  await user.click(screen.getByLabelText(\"Next\"));\n  expect(screen.getByText(\"July 2024\")).toBeInTheDocument();\n  \n  await user.click(screen.getByLabelText(\"Previous\"));\n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n});\n\ntest(\"handles date selection\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Calendar defaultValue={new Date(2024, 5, 15)} onChange={onChange} />);\n  \n  const date20 = screen.getByText(\"20\");\n  await user.click(date20);\n  \n  expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n  const calledDate = onChange.mock.calls[0][0];\n  expect(calledDate.getDate()).toBe(20);\n  expect(calledDate.getMonth()).toBe(5);\n  expect(calledDate.getFullYear()).toBe(2024);\n});\n\ntest(\"shows selected date\", () => {\n  render(<Calendar value={new Date(2024, 5, 15)} />);\n  \n  const selectedDate = screen.getByText(\"15\").closest(\".calendar-date\");\n  expect(selectedDate).toHaveClass(\"calendar-date-selected\");\n  expect(selectedDate).toHaveAttribute(\"aria-selected\", \"true\");\n});\n\ntest(\"highlights today's date\", () => {\n  const today = new Date();\n  render(<Calendar defaultValue={today} />);\n  \n  const todayElement = screen.getByText(today.getDate().toString()).closest(\".calendar-date\");\n  expect(todayElement).toHaveClass(\"calendar-date-today\");\n});\n\ntest(\"shows events on calendar\", () => {\n  const events = [\n    {\n      id: \"1\",\n      title: \"Meeting\",\n      start: new Date(2024, 5, 15),\n      end: new Date(2024, 5, 15),\n      color: \"#ff0000\"\n    }\n  ];\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} events={events} />);\n  \n  expect(screen.getByText(\"Meeting\")).toBeInTheDocument();\n});\n\ntest(\"handles event clicks\", async () => {\n  const user = userEvent.setup();\n  const onEventClick = vi.fn();\n  const events = [\n    {\n      id: \"1\",\n      title: \"Meeting\",\n      start: new Date(2024, 5, 15),\n      end: new Date(2024, 5, 15)\n    }\n  ];\n  \n  render(\n    <Calendar \n      defaultValue={new Date(2024, 5, 15)} \n      events={events} \n      onEventClick={onEventClick} \n    />\n  );\n  \n  await user.click(screen.getByText(\"Meeting\"));\n  expect(onEventClick).toHaveBeenCalledWith(events[0]);\n});\n\ntest(\"shows multiple events and overflow\", () => {\n  const events = Array.from({ length: 5 }, (_, i) => ({\n    id: `${i + 1}`,\n    title: `Event ${i + 1}`,\n    start: new Date(2024, 5, 15),\n    end: new Date(2024, 5, 15)\n  }));\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} events={events} />);\n  \n  expect(screen.getByText(\"Event 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Event 2\")).toBeInTheDocument();\n  expect(screen.getByText(\"Event 3\")).toBeInTheDocument();\n  expect(screen.getByText(\"+2 more\")).toBeInTheDocument();\n});\n\ntest(\"respects disabled date function\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const disabledDate = (date: Date) => date.getDate() === 15;\n  \n  render(\n    <Calendar \n      defaultValue={new Date(2024, 5, 10)} \n      onChange={onChange}\n      disabledDate={disabledDate}\n    />\n  );\n  \n  const disabledDay = screen.getByText(\"15\").closest(\".calendar-date\");\n  expect(disabledDay).toHaveClass(\"calendar-date-disabled\");\n  \n  await user.click(screen.getByText(\"15\"));\n  expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"shows week numbers when enabled\", () => {\n  render(<Calendar showWeekNumbers defaultValue={new Date(2024, 5, 15)} />);\n  \n  expect(screen.getByText(\"Wk\")).toBeInTheDocument();\n  expect(screen.getByText(\"24\")).toBeInTheDocument(); // Week number for June 15, 2024\n});\n\ntest(\"respects first day of week setting\", () => {\n  render(<Calendar firstDayOfWeek={1} />); // Monday first\n  \n  const weekdays = screen.getAllByText(/^(Mo|Tu|We|Th|Fr|Sa|Su)$/);\n  expect(weekdays[0]).toHaveTextContent(\"Mo\");\n});\n\ntest(\"renders year view\", () => {\n  render(<Calendar mode=\"year\" defaultValue={new Date(2024, 5, 15)} />);\n  \n  expect(screen.getByText(\"2024\")).toBeInTheDocument();\n  expect(screen.getByText(\"January\")).toBeInTheDocument();\n  expect(screen.getByText(\"December\")).toBeInTheDocument();\n});\n\ntest(\"renders decade view\", () => {\n  render(<Calendar mode=\"decade\" defaultValue={new Date(2024, 5, 15)} />);\n  \n  expect(screen.getByText(\"2020-2029\")).toBeInTheDocument();\n  expect(screen.getByText(\"2019\")).toBeInTheDocument();\n  expect(screen.getByText(\"2030\")).toBeInTheDocument();\n});\n\ntest(\"uses custom locale\", () => {\n  const customLocale = {\n    monthNames: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n    dayNames: [\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"],\n    today: \"Aujourd'hui\"\n  };\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} locale={customLocale} />);\n  \n  expect(screen.getByText(\"Jun 2024\")).toBeInTheDocument();\n  expect(screen.getByText(\"S\")).toBeInTheDocument();\n});\n\ntest(\"uses custom cell renderer\", () => {\n  const cellRender = (date: Date) => (\n    <div>Custom {date.getDate()}</div>\n  );\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} cellRender={cellRender} />);\n  \n  expect(screen.getByText(\"Custom 15\")).toBeInTheDocument();\n});\n\ntest(\"uses custom header renderer\", () => {\n  const headerRender = (date: Date) => (\n    <div>Custom Header {date.getFullYear()}</div>\n  );\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} headerRender={headerRender} />);\n  \n  expect(screen.getByText(\"Custom Header 2024\")).toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  render(<Calendar value={new Date(2024, 5, 15)} onChange={onChange} />);\n  \n  const selectedDate = screen.getByText(\"15\").closest(\".calendar-date\");\n  expect(selectedDate).toHaveClass(\"calendar-date-selected\");\n});\n\ntest(\"shows all day events correctly\", () => {\n  const events = [\n    {\n      id: \"1\",\n      title: \"All Day Event\",\n      start: new Date(2024, 5, 15, 0, 0, 0),\n      end: new Date(2024, 5, 15, 23, 59, 59),\n      allDay: true\n    }\n  ];\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} events={events} />);\n  \n  expect(screen.getByText(\"All Day Event\")).toBeInTheDocument();\n});\n\ntest(\"applies event colors\", () => {\n  const events = [\n    {\n      id: \"1\",\n      title: \"Colored Event\",\n      start: new Date(2024, 5, 15),\n      end: new Date(2024, 5, 15),\n      color: \"#ff0000\"\n    }\n  ];\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} events={events} />);\n  \n  const eventElement = screen.getByText(\"Colored Event\");\n  expect(eventElement).toHaveStyle({ backgroundColor: \"#ff0000\" });\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface CalendarEvent {\n  id: string;\n  title: string;\n  start: Date;\n  end: Date;\n  color?: string;\n  allDay?: boolean;\n  description?: string;\n}\n\nexport interface CalendarProps extends React.HTMLAttributes<HTMLDivElement> {\n  value?: Date;\n  defaultValue?: Date;\n  onChange?: (date: Date) => void;\n  mode?: \"month\" | \"year\" | \"decade\";\n  events?: CalendarEvent[];\n  onEventClick?: (event: CalendarEvent) => void;\n  disabledDate?: (date: Date) => boolean;\n  cellRender?: (date: Date, events: CalendarEvent[]) => React.ReactNode;\n  headerRender?: (date: Date, onNavigate: (date: Date) => void) => React.ReactNode;\n  showWeekNumbers?: boolean;\n  firstDayOfWeek?: 0 | 1 | 2 | 3 | 4 | 5 | 6; // 0 = Sunday\n  locale?: {\n    monthNames: string[];\n    dayNames: string[];\n    today: string;\n  };\n}\n\nconst defaultLocale = {\n  monthNames: [\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n  ],\n  dayNames: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n  today: \"Today\"\n};\n\nexport const Calendar = React.forwardRef<HTMLDivElement, CalendarProps>(\n  ({\n    value: controlledValue,\n    defaultValue,\n    onChange,\n    mode = \"month\",\n    events = [],\n    onEventClick,\n    disabledDate,\n    cellRender,\n    headerRender,\n    showWeekNumbers = false,\n    firstDayOfWeek = 0,\n    locale = defaultLocale,\n    className,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState<Date>(\n      defaultValue || new Date()\n    );\n    const [viewDate, setViewDate] = React.useState<Date>(\n      controlledValue || defaultValue || new Date()\n    );\n\n    const isControlled = controlledValue !== undefined;\n    const currentValue = isControlled ? controlledValue : internalValue;\n\n    const classes = `calendar calendar-${mode} ${className || \"\"}`.trim();\n\n    const updateValue = (newValue: Date) => {\n      if (onChange) {\n        onChange(newValue);\n      }\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n    };\n\n    const isSameDay = (date1: Date, date2: Date): boolean => {\n      return date1.getDate() === date2.getDate() &&\n             date1.getMonth() === date2.getMonth() &&\n             date1.getFullYear() === date2.getFullYear();\n    };\n\n    const isSameMonth = (date1: Date, date2: Date): boolean => {\n      return date1.getMonth() === date2.getMonth() &&\n             date1.getFullYear() === date2.getFullYear();\n    };\n\n    const isToday = (date: Date): boolean => {\n      return isSameDay(date, new Date());\n    };\n\n    const getWeekNumber = (date: Date): number => {\n      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\n      const dayNum = d.getUTCDay() || 7;\n      d.setUTCDate(d.getUTCDate() + 4 - dayNum);\n      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n      return Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);\n    };\n\n    const getMonthDays = (date: Date): Date[][] => {\n      const year = date.getFullYear();\n      const month = date.getMonth();\n      const firstDay = new Date(year, month, 1);\n      const lastDay = new Date(year, month + 1, 0);\n      \n      const startDay = (firstDay.getDay() - firstDayOfWeek + 7) % 7;\n      const startDate = new Date(firstDay);\n      startDate.setDate(startDate.getDate() - startDay);\n\n      const weeks: Date[][] = [];\n      let currentWeek: Date[] = [];\n      \n      for (let i = 0; i < 42; i++) { // 6 weeks max\n        const currentDate = new Date(startDate);\n        currentDate.setDate(startDate.getDate() + i);\n        \n        currentWeek.push(currentDate);\n        \n        if (currentWeek.length === 7) {\n          weeks.push(currentWeek);\n          currentWeek = [];\n        }\n        \n        if (currentDate > lastDay && currentWeek.length === 0) {\n          break;\n        }\n      }\n      \n      return weeks;\n    };\n\n    const getYearMonths = (date: Date): Date[] => {\n      const year = date.getFullYear();\n      return Array.from({ length: 12 }, (_, i) => new Date(year, i, 1));\n    };\n\n    const getDecadeYears = (date: Date): Date[] => {\n      const year = date.getFullYear();\n      const startYear = Math.floor(year / 10) * 10;\n      return Array.from({ length: 12 }, (_, i) => new Date(startYear + i - 1, 0, 1));\n    };\n\n    const getEventsForDate = (date: Date): CalendarEvent[] => {\n      return events.filter(event => {\n        if (event.allDay) {\n          return isSameDay(event.start, date);\n        }\n        return event.start <= date && event.end >= date;\n      });\n    };\n\n    const handleDateClick = (date: Date) => {\n      if (disabledDate && disabledDate(date)) return;\n      \n      if (mode === \"month\") {\n        updateValue(date);\n      } else if (mode === \"year\") {\n        setViewDate(date);\n      } else if (mode === \"decade\") {\n        setViewDate(date);\n      }\n    };\n\n    const handleEventClick = (event: CalendarEvent, e: React.MouseEvent) => {\n      e.stopPropagation();\n      if (onEventClick) {\n        onEventClick(event);\n      }\n    };\n\n    const navigateMonth = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setMonth(newDate.getMonth() + direction);\n      setViewDate(newDate);\n    };\n\n    const navigateYear = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setFullYear(newDate.getFullYear() + direction);\n      setViewDate(newDate);\n    };\n\n    const navigateDecade = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setFullYear(newDate.getFullYear() + (direction * 10));\n      setViewDate(newDate);\n    };\n\n    const handleNavigation = (direction: number) => {\n      switch (mode) {\n        case \"month\":\n          navigateMonth(direction);\n          break;\n        case \"year\":\n          navigateYear(direction);\n          break;\n        case \"decade\":\n          navigateDecade(direction);\n          break;\n      }\n    };\n\n    const renderMonthView = () => {\n      const weeks = getMonthDays(viewDate);\n      const orderedDayNames = [...locale.dayNames.slice(firstDayOfWeek), ...locale.dayNames.slice(0, firstDayOfWeek)];\n\n      return (\n        <div className=\"calendar-month-view\">\n          <div className=\"calendar-weekdays\">\n            {showWeekNumbers && <div className=\"calendar-weekday calendar-week-number-header\">Wk</div>}\n            {orderedDayNames.map(day => (\n              <div key={day} className=\"calendar-weekday\">\n                {day}\n              </div>\n            ))}\n          </div>\n          \n          <div className=\"calendar-month-body\">\n            {weeks.map((week, weekIndex) => (\n              <div key={weekIndex} className=\"calendar-week\">\n                {showWeekNumbers && (\n                  <div className=\"calendar-week-number\">\n                    {getWeekNumber(week[0])}\n                  </div>\n                )}\n                {week.map((date, dayIndex) => {\n                  const isCurrentMonth = isSameMonth(date, viewDate);\n                  const isSelected = isSameDay(date, currentValue);\n                  const isTodayDate = isToday(date);\n                  const isDisabled = disabledDate && disabledDate(date);\n                  const dayEvents = getEventsForDate(date);\n\n                  return (\n                    <div\n                      key={dayIndex}\n                      className={`calendar-cell calendar-date ${\n                        !isCurrentMonth ? \"calendar-date-other-month\" : \"\"\n                      } ${isSelected ? \"calendar-date-selected\" : \"\"} ${\n                        isTodayDate ? \"calendar-date-today\" : \"\"\n                      } ${isDisabled ? \"calendar-date-disabled\" : \"\"}`}\n                      onClick={() => handleDateClick(date)}\n                      role=\"gridcell\"\n                      aria-selected={isSelected}\n                      aria-label={date.toDateString()}\n                      tabIndex={isSelected ? 0 : -1}\n                    >\n                      {cellRender ? cellRender(date, dayEvents) : (\n                        <>\n                          <div className=\"calendar-date-content\">\n                            <span className=\"calendar-date-number\">{date.getDate()}</span>\n                          </div>\n                          {dayEvents.length > 0 && (\n                            <div className=\"calendar-events\">\n                              {dayEvents.slice(0, 3).map(event => (\n                                <div\n                                  key={event.id}\n                                  className=\"calendar-event\"\n                                  style={{ backgroundColor: event.color }}\n                                  onClick={(e) => handleEventClick(event, e)}\n                                  title={event.title}\n                                >\n                                  {event.title}\n                                </div>\n                              ))}\n                              {dayEvents.length > 3 && (\n                                <div className=\"calendar-event-more\">\n                                  +{dayEvents.length - 3} more\n                                </div>\n                              )}\n                            </div>\n                          )}\n                        </>\n                      )}\n                    </div>\n                  );\n                })}\n              </div>\n            ))}\n          </div>\n        </div>\n      );\n    };\n\n    const renderYearView = () => {\n      const months = getYearMonths(viewDate);\n\n      return (\n        <div className=\"calendar-year-view\">\n          <div className=\"calendar-year-body\">\n            {Array.from({ length: 4 }, (_, rowIndex) => (\n              <div key={rowIndex} className=\"calendar-year-row\">\n                {months.slice(rowIndex * 3, (rowIndex + 1) * 3).map(month => {\n                  const isSelected = isSameMonth(month, currentValue);\n                  const isCurrentMonth = isSameMonth(month, new Date());\n\n                  return (\n                    <div\n                      key={month.getMonth()}\n                      className={`calendar-cell calendar-month ${\n                        isSelected ? \"calendar-month-selected\" : \"\"\n                      } ${isCurrentMonth ? \"calendar-month-current\" : \"\"}`}\n                      onClick={() => handleDateClick(month)}\n                      role=\"gridcell\"\n                      aria-selected={isSelected}\n                      tabIndex={isSelected ? 0 : -1}\n                    >\n                      {locale.monthNames[month.getMonth()]}\n                    </div>\n                  );\n                })}\n              </div>\n            ))}\n          </div>\n        </div>\n      );\n    };\n\n    const renderDecadeView = () => {\n      const years = getDecadeYears(viewDate);\n\n      return (\n        <div className=\"calendar-decade-view\">\n          <div className=\"calendar-decade-body\">\n            {Array.from({ length: 4 }, (_, rowIndex) => (\n              <div key={rowIndex} className=\"calendar-decade-row\">\n                {years.slice(rowIndex * 3, (rowIndex + 1) * 3).map(year => {\n                  const isSelected = year.getFullYear() === currentValue.getFullYear();\n                  const isCurrentYear = year.getFullYear() === new Date().getFullYear();\n\n                  return (\n                    <div\n                      key={year.getFullYear()}\n                      className={`calendar-cell calendar-year ${\n                        isSelected ? \"calendar-year-selected\" : \"\"\n                      } ${isCurrentYear ? \"calendar-year-current\" : \"\"}`}\n                      onClick={() => handleDateClick(year)}\n                      role=\"gridcell\"\n                      aria-selected={isSelected}\n                      tabIndex={isSelected ? 0 : -1}\n                    >\n                      {year.getFullYear()}\n                    </div>\n                  );\n                })}\n              </div>\n            ))}\n          </div>\n        </div>\n      );\n    };\n\n    const getTitle = () => {\n      switch (mode) {\n        case \"month\":\n          return `${locale.monthNames[viewDate.getMonth()]} ${viewDate.getFullYear()}`;\n        case \"year\":\n          return viewDate.getFullYear().toString();\n        case \"decade\":\n          const startYear = Math.floor(viewDate.getFullYear() / 10) * 10;\n          return `${startYear}-${startYear + 9}`;\n        default:\n          return \"\";\n      }\n    };\n\n    return (\n      <div {...rest} ref={ref} className={classes} role=\"grid\">\n        {headerRender ? headerRender(viewDate, setViewDate) : (\n          <div className=\"calendar-header\">\n            <button\n              type=\"button\"\n              className=\"calendar-nav-button\"\n              onClick={() => handleNavigation(-1)}\n              aria-label=\"Previous\"\n            >\n              ‹\n            </button>\n            \n            <div className=\"calendar-title\" role=\"heading\" aria-level={2}>\n              {getTitle()}\n            </div>\n            \n            <button\n              type=\"button\"\n              className=\"calendar-nav-button\"\n              onClick={() => handleNavigation(1)}\n              aria-label=\"Next\"\n            >\n              ›\n            </button>\n          </div>\n        )}\n\n        <div className=\"calendar-body\">\n          {mode === \"month\" && renderMonthView()}\n          {mode === \"year\" && renderYearView()}\n          {mode === \"decade\" && renderDecadeView()}\n        </div>\n      </div>\n    );\n  }\n);\nCalendar.displayName = \"Calendar\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Calendar } from \"../Calendar\";\n\ntest(\"renders calendar in month view\", () => {\n  render(<Calendar defaultValue={new Date(2024, 5, 15)} />);\n  \n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n  expect(screen.getByRole(\"grid\")).toBeInTheDocument();\n});\n\ntest(\"shows weekday headers\", () => {\n  render(<Calendar />);\n  \n  expect(screen.getByText(\"Su\")).toBeInTheDocument();\n  expect(screen.getByText(\"Mo\")).toBeInTheDocument();\n  expect(screen.getByText(\"Tu\")).toBeInTheDocument();\n  expect(screen.getByText(\"We\")).toBeInTheDocument();\n  expect(screen.getByText(\"Th\")).toBeInTheDocument();\n  expect(screen.getByText(\"Fr\")).toBeInTheDocument();\n  expect(screen.getByText(\"Sa\")).toBeInTheDocument();\n});\n\ntest(\"navigates between months\", async () => {\n  const user = userEvent.setup();\n  render(<Calendar defaultValue={new Date(2024, 5, 15)} />);\n  \n  await user.click(screen.getByLabelText(\"Next\"));\n  expect(screen.getByText(\"July 2024\")).toBeInTheDocument();\n  \n  await user.click(screen.getByLabelText(\"Previous\"));\n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n});\n\ntest(\"handles date selection\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Calendar defaultValue={new Date(2024, 5, 15)} onChange={onChange} />);\n  \n  const date20 = screen.getByText(\"20\");\n  await user.click(date20);\n  \n  expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n  const calledDate = onChange.mock.calls[0][0];\n  expect(calledDate.getDate()).toBe(20);\n  expect(calledDate.getMonth()).toBe(5);\n  expect(calledDate.getFullYear()).toBe(2024);\n});\n\ntest(\"shows selected date\", () => {\n  render(<Calendar value={new Date(2024, 5, 15)} />);\n  \n  const selectedDate = screen.getByText(\"15\").closest(\".calendar-date\");\n  expect(selectedDate).toHaveClass(\"calendar-date-selected\");\n  expect(selectedDate).toHaveAttribute(\"aria-selected\", \"true\");\n});\n\ntest(\"highlights today's date\", () => {\n  const today = new Date();\n  render(<Calendar defaultValue={today} />);\n  \n  const todayElement = screen.getByText(today.getDate().toString()).closest(\".calendar-date\");\n  expect(todayElement).toHaveClass(\"calendar-date-today\");\n});\n\ntest(\"shows events on calendar\", () => {\n  const events = [\n    {\n      id: \"1\",\n      title: \"Meeting\",\n      start: new Date(2024, 5, 15),\n      end: new Date(2024, 5, 15),\n      color: \"#ff0000\"\n    }\n  ];\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} events={events} />);\n  \n  expect(screen.getByText(\"Meeting\")).toBeInTheDocument();\n});\n\ntest(\"handles event clicks\", async () => {\n  const user = userEvent.setup();\n  const onEventClick = vi.fn();\n  const events = [\n    {\n      id: \"1\",\n      title: \"Meeting\",\n      start: new Date(2024, 5, 15),\n      end: new Date(2024, 5, 15)\n    }\n  ];\n  \n  render(\n    <Calendar \n      defaultValue={new Date(2024, 5, 15)} \n      events={events} \n      onEventClick={onEventClick} \n    />\n  );\n  \n  await user.click(screen.getByText(\"Meeting\"));\n  expect(onEventClick).toHaveBeenCalledWith(events[0]);\n});\n\ntest(\"shows multiple events and overflow\", () => {\n  const events = Array.from({ length: 5 }, (_, i) => ({\n    id: `${i + 1}`,\n    title: `Event ${i + 1}`,\n    start: new Date(2024, 5, 15),\n    end: new Date(2024, 5, 15)\n  }));\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} events={events} />);\n  \n  expect(screen.getByText(\"Event 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Event 2\")).toBeInTheDocument();\n  expect(screen.getByText(\"Event 3\")).toBeInTheDocument();\n  expect(screen.getByText(\"+2 more\")).toBeInTheDocument();\n});\n\ntest(\"respects disabled date function\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const disabledDate = (date: Date) => date.getDate() === 15;\n  \n  render(\n    <Calendar \n      defaultValue={new Date(2024, 5, 10)} \n      onChange={onChange}\n      disabledDate={disabledDate}\n    />\n  );\n  \n  const disabledDay = screen.getByText(\"15\").closest(\".calendar-date\");\n  expect(disabledDay).toHaveClass(\"calendar-date-disabled\");\n  \n  await user.click(screen.getByText(\"15\"));\n  expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"shows week numbers when enabled\", () => {\n  render(<Calendar showWeekNumbers defaultValue={new Date(2024, 5, 15)} />);\n  \n  expect(screen.getByText(\"Wk\")).toBeInTheDocument();\n  expect(screen.getByText(\"24\")).toBeInTheDocument(); // Week number for June 15, 2024\n});\n\ntest(\"respects first day of week setting\", () => {\n  render(<Calendar firstDayOfWeek={1} />); // Monday first\n  \n  const weekdays = screen.getAllByText(/^(Mo|Tu|We|Th|Fr|Sa|Su)$/);\n  expect(weekdays[0]).toHaveTextContent(\"Mo\");\n});\n\ntest(\"renders year view\", () => {\n  render(<Calendar mode=\"year\" defaultValue={new Date(2024, 5, 15)} />);\n  \n  expect(screen.getByText(\"2024\")).toBeInTheDocument();\n  expect(screen.getByText(\"January\")).toBeInTheDocument();\n  expect(screen.getByText(\"December\")).toBeInTheDocument();\n});\n\ntest(\"renders decade view\", () => {\n  render(<Calendar mode=\"decade\" defaultValue={new Date(2024, 5, 15)} />);\n  \n  expect(screen.getByText(\"2020-2029\")).toBeInTheDocument();\n  expect(screen.getByText(\"2019\")).toBeInTheDocument();\n  expect(screen.getByText(\"2030\")).toBeInTheDocument();\n});\n\ntest(\"uses custom locale\", () => {\n  const customLocale = {\n    monthNames: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n    dayNames: [\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"],\n    today: \"Aujourd'hui\"\n  };\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} locale={customLocale} />);\n  \n  expect(screen.getByText(\"Jun 2024\")).toBeInTheDocument();\n  expect(screen.getByText(\"S\")).toBeInTheDocument();\n});\n\ntest(\"uses custom cell renderer\", () => {\n  const cellRender = (date: Date) => (\n    <div>Custom {date.getDate()}</div>\n  );\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} cellRender={cellRender} />);\n  \n  expect(screen.getByText(\"Custom 15\")).toBeInTheDocument();\n});\n\ntest(\"uses custom header renderer\", () => {\n  const headerRender = (date: Date) => (\n    <div>Custom Header {date.getFullYear()}</div>\n  );\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} headerRender={headerRender} />);\n  \n  expect(screen.getByText(\"Custom Header 2024\")).toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  render(<Calendar value={new Date(2024, 5, 15)} onChange={onChange} />);\n  \n  const selectedDate = screen.getByText(\"15\").closest(\".calendar-date\");\n  expect(selectedDate).toHaveClass(\"calendar-date-selected\");\n});\n\ntest(\"shows all day events correctly\", () => {\n  const events = [\n    {\n      id: \"1\",\n      title: \"All Day Event\",\n      start: new Date(2024, 5, 15, 0, 0, 0),\n      end: new Date(2024, 5, 15, 23, 59, 59),\n      allDay: true\n    }\n  ];\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} events={events} />);\n  \n  expect(screen.getByText(\"All Day Event\")).toBeInTheDocument();\n});\n\ntest(\"applies event colors\", () => {\n  const events = [\n    {\n      id: \"1\",\n      title: \"Colored Event\",\n      start: new Date(2024, 5, 15),\n      end: new Date(2024, 5, 15),\n      color: \"#ff0000\"\n    }\n  ];\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} events={events} />);\n  \n  const eventElement = screen.getByText(\"Colored Event\");\n  expect(eventElement).toHaveStyle({ backgroundColor: \"#ff0000\" });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface CalendarEvent {\n  id: string;\n  title: string;\n  start: Date;\n  end: Date;\n  color?: string;\n  allDay?: boolean;\n  description?: string;\n}\n\nexport interface CalendarProps extends React.HTMLAttributes<HTMLDivElement> {\n  value?: Date;\n  defaultValue?: Date;\n  onChange?: (date: Date) => void;\n  mode?: \"month\" | \"year\" | \"decade\";\n  events?: CalendarEvent[];\n  onEventClick?: (event: CalendarEvent) => void;\n  disabledDate?: (date: Date) => boolean;\n  cellRender?: (date: Date, events: CalendarEvent[]) => React.ReactNode;\n  headerRender?: (date: Date, onNavigate: (date: Date) => void) => React.ReactNode;\n  showWeekNumbers?: boolean;\n  firstDayOfWeek?: 0 | 1 | 2 | 3 | 4 | 5 | 6; // 0 = Sunday\n  locale?: {\n    monthNames: string[];\n    dayNames: string[];\n    today: string;\n  };\n}\n\nconst defaultLocale = {\n  monthNames: [\n    \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n    \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n  ],\n  dayNames: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"],\n  today: \"Today\"\n};\n\nexport const Calendar = React.forwardRef<HTMLDivElement, CalendarProps>(\n  ({\n    value: controlledValue,\n    defaultValue,\n    onChange,\n    mode = \"month\",\n    events = [],\n    onEventClick,\n    disabledDate,\n    cellRender,\n    headerRender,\n    showWeekNumbers = false,\n    firstDayOfWeek = 0,\n    locale = defaultLocale,\n    className,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState<Date>(\n      defaultValue || new Date()\n    );\n    const [viewDate, setViewDate] = React.useState<Date>(\n      controlledValue || defaultValue || new Date()\n    );\n\n    const isControlled = controlledValue !== undefined;\n    const currentValue = isControlled ? controlledValue : internalValue;\n\n    const classes = `calendar calendar-${mode} ${className || \"\"}`.trim();\n\n    const updateValue = (newValue: Date) => {\n      if (onChange) {\n        onChange(newValue);\n      }\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n    };\n\n    const isSameDay = (date1: Date, date2: Date): boolean => {\n      return date1.getDate() === date2.getDate() &&\n             date1.getMonth() === date2.getMonth() &&\n             date1.getFullYear() === date2.getFullYear();\n    };\n\n    const isSameMonth = (date1: Date, date2: Date): boolean => {\n      return date1.getMonth() === date2.getMonth() &&\n             date1.getFullYear() === date2.getFullYear();\n    };\n\n    const isToday = (date: Date): boolean => {\n      return isSameDay(date, new Date());\n    };\n\n    const getWeekNumber = (date: Date): number => {\n      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));\n      const dayNum = d.getUTCDay() || 7;\n      d.setUTCDate(d.getUTCDate() + 4 - dayNum);\n      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));\n      return Math.ceil((((d.getTime() - yearStart.getTime()) / 86400000) + 1) / 7);\n    };\n\n    const getMonthDays = (date: Date): Date[][] => {\n      const year = date.getFullYear();\n      const month = date.getMonth();\n      const firstDay = new Date(year, month, 1);\n      const lastDay = new Date(year, month + 1, 0);\n      \n      const startDay = (firstDay.getDay() - firstDayOfWeek + 7) % 7;\n      const startDate = new Date(firstDay);\n      startDate.setDate(startDate.getDate() - startDay);\n\n      const weeks: Date[][] = [];\n      let currentWeek: Date[] = [];\n      \n      for (let i = 0; i < 42; i++) { // 6 weeks max\n        const currentDate = new Date(startDate);\n        currentDate.setDate(startDate.getDate() + i);\n        \n        currentWeek.push(currentDate);\n        \n        if (currentWeek.length === 7) {\n          weeks.push(currentWeek);\n          currentWeek = [];\n        }\n        \n        if (currentDate > lastDay && currentWeek.length === 0) {\n          break;\n        }\n      }\n      \n      return weeks;\n    };\n\n    const getYearMonths = (date: Date): Date[] => {\n      const year = date.getFullYear();\n      return Array.from({ length: 12 }, (_, i) => new Date(year, i, 1));\n    };\n\n    const getDecadeYears = (date: Date): Date[] => {\n      const year = date.getFullYear();\n      const startYear = Math.floor(year / 10) * 10;\n      return Array.from({ length: 12 }, (_, i) => new Date(startYear + i - 1, 0, 1));\n    };\n\n    const getEventsForDate = (date: Date): CalendarEvent[] => {\n      return events.filter(event => {\n        if (event.allDay) {\n          return isSameDay(event.start, date);\n        }\n        return event.start <= date && event.end >= date;\n      });\n    };\n\n    const handleDateClick = (date: Date) => {\n      if (disabledDate && disabledDate(date)) return;\n      \n      if (mode === \"month\") {\n        updateValue(date);\n      } else if (mode === \"year\") {\n        setViewDate(date);\n      } else if (mode === \"decade\") {\n        setViewDate(date);\n      }\n    };\n\n    const handleEventClick = (event: CalendarEvent, e: React.MouseEvent) => {\n      e.stopPropagation();\n      if (onEventClick) {\n        onEventClick(event);\n      }\n    };\n\n    const navigateMonth = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setMonth(newDate.getMonth() + direction);\n      setViewDate(newDate);\n    };\n\n    const navigateYear = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setFullYear(newDate.getFullYear() + direction);\n      setViewDate(newDate);\n    };\n\n    const navigateDecade = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setFullYear(newDate.getFullYear() + (direction * 10));\n      setViewDate(newDate);\n    };\n\n    const handleNavigation = (direction: number) => {\n      switch (mode) {\n        case \"month\":\n          navigateMonth(direction);\n          break;\n        case \"year\":\n          navigateYear(direction);\n          break;\n        case \"decade\":\n          navigateDecade(direction);\n          break;\n      }\n    };\n\n    const renderMonthView = () => {\n      const weeks = getMonthDays(viewDate);\n      const orderedDayNames = [...locale.dayNames.slice(firstDayOfWeek), ...locale.dayNames.slice(0, firstDayOfWeek)];\n\n      return (\n        <div className=\"calendar-month-view\">\n          <div className=\"calendar-weekdays\">\n            {showWeekNumbers && <div className=\"calendar-weekday calendar-week-number-header\">Wk</div>}\n            {orderedDayNames.map(day => (\n              <div key={day} className=\"calendar-weekday\">\n                {day}\n              </div>\n            ))}\n          </div>\n          \n          <div className=\"calendar-month-body\">\n            {weeks.map((week, weekIndex) => (\n              <div key={weekIndex} className=\"calendar-week\">\n                {showWeekNumbers && (\n                  <div className=\"calendar-week-number\">\n                    {getWeekNumber(week[0])}\n                  </div>\n                )}\n                {week.map((date, dayIndex) => {\n                  const isCurrentMonth = isSameMonth(date, viewDate);\n                  const isSelected = isSameDay(date, currentValue);\n                  const isTodayDate = isToday(date);\n                  const isDisabled = disabledDate && disabledDate(date);\n                  const dayEvents = getEventsForDate(date);\n\n                  return (\n                    <div\n                      key={dayIndex}\n                      className={`calendar-cell calendar-date ${\n                        !isCurrentMonth ? \"calendar-date-other-month\" : \"\"\n                      } ${isSelected ? \"calendar-date-selected\" : \"\"} ${\n                        isTodayDate ? \"calendar-date-today\" : \"\"\n                      } ${isDisabled ? \"calendar-date-disabled\" : \"\"}`}\n                      onClick={() => handleDateClick(date)}\n                      role=\"gridcell\"\n                      aria-selected={isSelected}\n                      aria-label={date.toDateString()}\n                      tabIndex={isSelected ? 0 : -1}\n                    >\n                      {cellRender ? cellRender(date, dayEvents) : (\n                        <>\n                          <div className=\"calendar-date-content\">\n                            <span className=\"calendar-date-number\">{date.getDate()}</span>\n                          </div>\n                          {dayEvents.length > 0 && (\n                            <div className=\"calendar-events\">\n                              {dayEvents.slice(0, 3).map(event => (\n                                <div\n                                  key={event.id}\n                                  className=\"calendar-event\"\n                                  style={{ backgroundColor: event.color }}\n                                  onClick={(e) => handleEventClick(event, e)}\n                                  title={event.title}\n                                >\n                                  {event.title}\n                                </div>\n                              ))}\n                              {dayEvents.length > 3 && (\n                                <div className=\"calendar-event-more\">\n                                  +{dayEvents.length - 3} more\n                                </div>\n                              )}\n                            </div>\n                          )}\n                        </>\n                      )}\n                    </div>\n                  );\n                })}\n              </div>\n            ))}\n          </div>\n        </div>\n      );\n    };\n\n    const renderYearView = () => {\n      const months = getYearMonths(viewDate);\n\n      return (\n        <div className=\"calendar-year-view\">\n          <div className=\"calendar-year-body\">\n            {Array.from({ length: 4 }, (_, rowIndex) => (\n              <div key={rowIndex} className=\"calendar-year-row\">\n                {months.slice(rowIndex * 3, (rowIndex + 1) * 3).map(month => {\n                  const isSelected = isSameMonth(month, currentValue);\n                  const isCurrentMonth = isSameMonth(month, new Date());\n\n                  return (\n                    <div\n                      key={month.getMonth()}\n                      className={`calendar-cell calendar-month ${\n                        isSelected ? \"calendar-month-selected\" : \"\"\n                      } ${isCurrentMonth ? \"calendar-month-current\" : \"\"}`}\n                      onClick={() => handleDateClick(month)}\n                      role=\"gridcell\"\n                      aria-selected={isSelected}\n                      tabIndex={isSelected ? 0 : -1}\n                    >\n                      {locale.monthNames[month.getMonth()]}\n                    </div>\n                  );\n                })}\n              </div>\n            ))}\n          </div>\n        </div>\n      );\n    };\n\n    const renderDecadeView = () => {\n      const years = getDecadeYears(viewDate);\n\n      return (\n        <div className=\"calendar-decade-view\">\n          <div className=\"calendar-decade-body\">\n            {Array.from({ length: 4 }, (_, rowIndex) => (\n              <div key={rowIndex} className=\"calendar-decade-row\">\n                {years.slice(rowIndex * 3, (rowIndex + 1) * 3).map(year => {\n                  const isSelected = year.getFullYear() === currentValue.getFullYear();\n                  const isCurrentYear = year.getFullYear() === new Date().getFullYear();\n\n                  return (\n                    <div\n                      key={year.getFullYear()}\n                      className={`calendar-cell calendar-year ${\n                        isSelected ? \"calendar-year-selected\" : \"\"\n                      } ${isCurrentYear ? \"calendar-year-current\" : \"\"}`}\n                      onClick={() => handleDateClick(year)}\n                      role=\"gridcell\"\n                      aria-selected={isSelected}\n                      tabIndex={isSelected ? 0 : -1}\n                    >\n                      {year.getFullYear()}\n                    </div>\n                  );\n                })}\n              </div>\n            ))}\n          </div>\n        </div>\n      );\n    };\n\n    const getTitle = () => {\n      switch (mode) {\n        case \"month\":\n          return `${locale.monthNames[viewDate.getMonth()]} ${viewDate.getFullYear()}`;\n        case \"year\":\n          return viewDate.getFullYear().toString();\n        case \"decade\":\n          const startYear = Math.floor(viewDate.getFullYear() / 10) * 10;\n          return `${startYear}-${startYear + 9}`;\n        default:\n          return \"\";\n      }\n    };\n\n    return (\n      <div {...rest} ref={ref} className={classes} role=\"grid\">\n        {headerRender ? headerRender(viewDate, setViewDate) : (\n          <div className=\"calendar-header\">\n            <button\n              type=\"button\"\n              className=\"calendar-nav-button\"\n              onClick={() => handleNavigation(-1)}\n              aria-label=\"Previous\"\n            >\n              ‹\n            </button>\n            \n            <div className=\"calendar-title\" role=\"heading\" aria-level={2}>\n              {getTitle()}\n            </div>\n            \n            <button\n              type=\"button\"\n              className=\"calendar-nav-button\"\n              onClick={() => handleNavigation(1)}\n              aria-label=\"Next\"\n            >\n              ›\n            </button>\n          </div>\n        )}\n\n        <div className=\"calendar-body\">\n          {mode === \"month\" && renderMonthView()}\n          {mode === \"year\" && renderYearView()}\n          {mode === \"decade\" && renderDecadeView()}\n        </div>\n      </div>\n    );\n  }\n);\nCalendar.displayName = \"Calendar\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Calendar } from \"../Calendar\";\n\ntest(\"renders calendar in month view\", () => {\n  render(<Calendar defaultValue={new Date(2024, 5, 15)} />);\n  \n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n  expect(screen.getByRole(\"grid\")).toBeInTheDocument();\n});\n\ntest(\"shows weekday headers\", () => {\n  render(<Calendar />);\n  \n  expect(screen.getByText(\"Su\")).toBeInTheDocument();\n  expect(screen.getByText(\"Mo\")).toBeInTheDocument();\n  expect(screen.getByText(\"Tu\")).toBeInTheDocument();\n  expect(screen.getByText(\"We\")).toBeInTheDocument();\n  expect(screen.getByText(\"Th\")).toBeInTheDocument();\n  expect(screen.getByText(\"Fr\")).toBeInTheDocument();\n  expect(screen.getByText(\"Sa\")).toBeInTheDocument();\n});\n\ntest(\"navigates between months\", async () => {\n  const user = userEvent.setup();\n  render(<Calendar defaultValue={new Date(2024, 5, 15)} />);\n  \n  await user.click(screen.getByLabelText(\"Next\"));\n  expect(screen.getByText(\"July 2024\")).toBeInTheDocument();\n  \n  await user.click(screen.getByLabelText(\"Previous\"));\n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n});\n\ntest(\"handles date selection\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Calendar defaultValue={new Date(2024, 5, 15)} onChange={onChange} />);\n  \n  const date20 = screen.getByText(\"20\");\n  await user.click(date20);\n  \n  expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n  const calledDate = onChange.mock.calls[0][0];\n  expect(calledDate.getDate()).toBe(20);\n  expect(calledDate.getMonth()).toBe(5);\n  expect(calledDate.getFullYear()).toBe(2024);\n});\n\ntest(\"shows selected date\", () => {\n  render(<Calendar value={new Date(2024, 5, 15)} />);\n  \n  const selectedDate = screen.getByText(\"15\").closest(\".calendar-date\");\n  expect(selectedDate).toHaveClass(\"calendar-date-selected\");\n  expect(selectedDate).toHaveAttribute(\"aria-selected\", \"true\");\n});\n\ntest(\"highlights today's date\", () => {\n  const today = new Date();\n  render(<Calendar defaultValue={today} />);\n  \n  const todayElement = screen.getByText(today.getDate().toString()).closest(\".calendar-date\");\n  expect(todayElement).toHaveClass(\"calendar-date-today\");\n});\n\ntest(\"shows events on calendar\", () => {\n  const events = [\n    {\n      id: \"1\",\n      title: \"Meeting\",\n      start: new Date(2024, 5, 15),\n      end: new Date(2024, 5, 15),\n      color: \"#ff0000\"\n    }\n  ];\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} events={events} />);\n  \n  expect(screen.getByText(\"Meeting\")).toBeInTheDocument();\n});\n\ntest(\"handles event clicks\", async () => {\n  const user = userEvent.setup();\n  const onEventClick = vi.fn();\n  const events = [\n    {\n      id: \"1\",\n      title: \"Meeting\",\n      start: new Date(2024, 5, 15),\n      end: new Date(2024, 5, 15)\n    }\n  ];\n  \n  render(\n    <Calendar \n      defaultValue={new Date(2024, 5, 15)} \n      events={events} \n      onEventClick={onEventClick} \n    />\n  );\n  \n  await user.click(screen.getByText(\"Meeting\"));\n  expect(onEventClick).toHaveBeenCalledWith(events[0]);\n});\n\ntest(\"shows multiple events and overflow\", () => {\n  const events = Array.from({ length: 5 }, (_, i) => ({\n    id: `${i + 1}`,\n    title: `Event ${i + 1}`,\n    start: new Date(2024, 5, 15),\n    end: new Date(2024, 5, 15)\n  }));\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} events={events} />);\n  \n  expect(screen.getByText(\"Event 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Event 2\")).toBeInTheDocument();\n  expect(screen.getByText(\"Event 3\")).toBeInTheDocument();\n  expect(screen.getByText(\"+2 more\")).toBeInTheDocument();\n});\n\ntest(\"respects disabled date function\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const disabledDate = (date: Date) => date.getDate() === 15;\n  \n  render(\n    <Calendar \n      defaultValue={new Date(2024, 5, 10)} \n      onChange={onChange}\n      disabledDate={disabledDate}\n    />\n  );\n  \n  const disabledDay = screen.getByText(\"15\").closest(\".calendar-date\");\n  expect(disabledDay).toHaveClass(\"calendar-date-disabled\");\n  \n  await user.click(screen.getByText(\"15\"));\n  expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"shows week numbers when enabled\", () => {\n  render(<Calendar showWeekNumbers defaultValue={new Date(2024, 5, 15)} />);\n  \n  expect(screen.getByText(\"Wk\")).toBeInTheDocument();\n  expect(screen.getByText(\"24\")).toBeInTheDocument(); // Week number for June 15, 2024\n});\n\ntest(\"respects first day of week setting\", () => {\n  render(<Calendar firstDayOfWeek={1} />); // Monday first\n  \n  const weekdays = screen.getAllByText(/^(Mo|Tu|We|Th|Fr|Sa|Su)$/);\n  expect(weekdays[0]).toHaveTextContent(\"Mo\");\n});\n\ntest(\"renders year view\", () => {\n  render(<Calendar mode=\"year\" defaultValue={new Date(2024, 5, 15)} />);\n  \n  expect(screen.getByText(\"2024\")).toBeInTheDocument();\n  expect(screen.getByText(\"January\")).toBeInTheDocument();\n  expect(screen.getByText(\"December\")).toBeInTheDocument();\n});\n\ntest(\"renders decade view\", () => {\n  render(<Calendar mode=\"decade\" defaultValue={new Date(2024, 5, 15)} />);\n  \n  expect(screen.getByText(\"2020-2029\")).toBeInTheDocument();\n  expect(screen.getByText(\"2019\")).toBeInTheDocument();\n  expect(screen.getByText(\"2030\")).toBeInTheDocument();\n});\n\ntest(\"uses custom locale\", () => {\n  const customLocale = {\n    monthNames: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n    dayNames: [\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"],\n    today: \"Aujourd'hui\"\n  };\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} locale={customLocale} />);\n  \n  expect(screen.getByText(\"Jun 2024\")).toBeInTheDocument();\n  expect(screen.getByText(\"S\")).toBeInTheDocument();\n});\n\ntest(\"uses custom cell renderer\", () => {\n  const cellRender = (date: Date) => (\n    <div>Custom {date.getDate()}</div>\n  );\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} cellRender={cellRender} />);\n  \n  expect(screen.getByText(\"Custom 15\")).toBeInTheDocument();\n});\n\ntest(\"uses custom header renderer\", () => {\n  const headerRender = (date: Date) => (\n    <div>Custom Header {date.getFullYear()}</div>\n  );\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} headerRender={headerRender} />);\n  \n  expect(screen.getByText(\"Custom Header 2024\")).toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  render(<Calendar value={new Date(2024, 5, 15)} onChange={onChange} />);\n  \n  const selectedDate = screen.getByText(\"15\").closest(\".calendar-date\");\n  expect(selectedDate).toHaveClass(\"calendar-date-selected\");\n});\n\ntest(\"shows all day events correctly\", () => {\n  const events = [\n    {\n      id: \"1\",\n      title: \"All Day Event\",\n      start: new Date(2024, 5, 15, 0, 0, 0),\n      end: new Date(2024, 5, 15, 23, 59, 59),\n      allDay: true\n    }\n  ];\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} events={events} />);\n  \n  expect(screen.getByText(\"All Day Event\")).toBeInTheDocument();\n});\n\ntest(\"applies event colors\", () => {\n  const events = [\n    {\n      id: \"1\",\n      title: \"Colored Event\",\n      start: new Date(2024, 5, 15),\n      end: new Date(2024, 5, 15),\n      color: \"#ff0000\"\n    }\n  ];\n  \n  render(<Calendar defaultValue={new Date(2024, 5, 15)} events={events} />);\n  \n  const eventElement = screen.getByText(\"Colored Event\");\n  expect(eventElement).toHaveStyle({ backgroundColor: \"#ff0000\" });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface CardProps extends React.HTMLAttributes<HTMLDivElement> {\n    variant?: \"default\" | \"outlined\" | \"elevated\";\n    padding?: \"none\" | \"sm\" | \"md\" | \"lg\";\n}\n\nconst classesByVariant: Record<NonNullable<CardProps[\"variant\"]>, string> = {\n    default: \"card card-default\",\n    outlined: \"card card-outlined\",\n    elevated: \"card card-elevated\",\n};\n\nconst classesByPadding: Record<NonNullable<CardProps[\"padding\"]>, string> = {\n    none: \"\",\n    sm: \"card-padding-sm\",\n    md: \"card-padding-md\",\n    lg: \"card-padding-lg\",\n};\n\nexport const Card = React.forwardRef<HTMLDivElement, CardProps>(\n    ({ variant = \"default\", padding = \"md\", className, children, ...rest }, ref) => {\n        const classes = `${classesByVariant[variant]} ${classesByPadding[padding]} ${className || \"\"}`.trim();\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n            >\n                {children}\n            </div>\n        );\n    }\n);\nCard.displayName = \"Card\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Card } from \"../Card\";\n\ntest(\"renders with children\", () => {\n    render(<Card>Card content</Card>);\n    expect(screen.getByText(\"Card content\")).toBeInTheDocument();\n});\n\ntest(\"applies default classes\", () => {\n    render(<Card>Default card</Card>);\n    const card = screen.getByText(\"Default card\");\n    expect(card).toHaveClass(\"card\", \"card-default\", \"card-padding-md\");\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Card variant=\"outlined\">Outlined card</Card>);\n    expect(screen.getByText(\"Outlined card\")).toHaveClass(\"card\", \"card-outlined\");\n});\n\ntest(\"applies padding classes\", () => {\n    render(<Card padding=\"lg\">Large padding</Card>);\n    expect(screen.getByText(\"Large padding\")).toHaveClass(\"card-padding-lg\");\n});\n\ntest(\"handles no padding\", () => {\n    render(<Card padding=\"none\">No padding</Card>);\n    const card = screen.getByText(\"No padding\");\n    expect(card).not.toHaveClass(\"card-padding-sm\");\n    expect(card).not.toHaveClass(\"card-padding-md\");\n    expect(card).not.toHaveClass(\"card-padding-lg\");\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface CardProps extends React.HTMLAttributes<HTMLDivElement> {\n    variant?: \"default\" | \"outlined\" | \"elevated\";\n    padding?: \"none\" | \"sm\" | \"md\" | \"lg\";\n}\n\nconst classesByVariant: Record<NonNullable<CardProps[\"variant\"]>, string> = {\n    default: \"card card-default\",\n    outlined: \"card card-outlined\",\n    elevated: \"card card-elevated\",\n};\n\nconst classesByPadding: Record<NonNullable<CardProps[\"padding\"]>, string> = {\n    none: \"\",\n    sm: \"card-padding-sm\",\n    md: \"card-padding-md\",\n    lg: \"card-padding-lg\",\n};\n\nexport const Card = React.forwardRef<HTMLDivElement, CardProps>(\n    ({ variant = \"default\", padding = \"md\", className, children, ...rest }, ref) => {\n        const classes = `${classesByVariant[variant]} ${classesByPadding[padding]} ${className || \"\"}`.trim();\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n            >\n                {children}\n            </div>\n        );\n    }\n);\nCard.displayName = \"Card\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Card } from \"../Card\";\n\ntest(\"renders with children\", () => {\n    render(<Card>Card content</Card>);\n    expect(screen.getByText(\"Card content\")).toBeInTheDocument();\n});\n\ntest(\"applies default classes\", () => {\n    render(<Card>Default card</Card>);\n    const card = screen.getByText(\"Default card\");\n    expect(card).toHaveClass(\"card\", \"card-default\", \"card-padding-md\");\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Card variant=\"outlined\">Outlined card</Card>);\n    expect(screen.getByText(\"Outlined card\")).toHaveClass(\"card\", \"card-outlined\");\n});\n\ntest(\"applies padding classes\", () => {\n    render(<Card padding=\"lg\">Large padding</Card>);\n    expect(screen.getByText(\"Large padding\")).toHaveClass(\"card-padding-lg\");\n});\n\ntest(\"handles no padding\", () => {\n    render(<Card padding=\"none\">No padding</Card>);\n    const card = screen.getByText(\"No padding\");\n    expect(card).not.toHaveClass(\"card-padding-sm\");\n    expect(card).not.toHaveClass(\"card-padding-md\");\n    expect(card).not.toHaveClass(\"card-padding-lg\");\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface CardProps extends React.HTMLAttributes<HTMLDivElement> {\n    variant?: \"default\" | \"outlined\" | \"elevated\";\n    padding?: \"none\" | \"sm\" | \"md\" | \"lg\";\n}\n\nconst classesByVariant: Record<NonNullable<CardProps[\"variant\"]>, string> = {\n    default: \"card card-default\",\n    outlined: \"card card-outlined\",\n    elevated: \"card card-elevated\",\n};\n\nconst classesByPadding: Record<NonNullable<CardProps[\"padding\"]>, string> = {\n    none: \"\",\n    sm: \"card-padding-sm\",\n    md: \"card-padding-md\",\n    lg: \"card-padding-lg\",\n};\n\nexport const Card = React.forwardRef<HTMLDivElement, CardProps>(\n    ({ variant = \"default\", padding = \"md\", className, children, ...rest }, ref) => {\n        const classes = `${classesByVariant[variant]} ${classesByPadding[padding]} ${className || \"\"}`.trim();\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n            >\n                {children}\n            </div>\n        );\n    }\n);\nCard.displayName = \"Card\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Card } from \"../Card\";\n\ntest(\"renders with children\", () => {\n    render(<Card>Card content</Card>);\n    expect(screen.getByText(\"Card content\")).toBeInTheDocument();\n});\n\ntest(\"applies default classes\", () => {\n    render(<Card>Default card</Card>);\n    const card = screen.getByText(\"Default card\");\n    expect(card).toHaveClass(\"card\", \"card-default\", \"card-padding-md\");\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Card variant=\"outlined\">Outlined card</Card>);\n    expect(screen.getByText(\"Outlined card\")).toHaveClass(\"card\", \"card-outlined\");\n});\n\ntest(\"applies padding classes\", () => {\n    render(<Card padding=\"lg\">Large padding</Card>);\n    expect(screen.getByText(\"Large padding\")).toHaveClass(\"card-padding-lg\");\n});\n\ntest(\"handles no padding\", () => {\n    render(<Card padding=\"none\">No padding</Card>);\n    const card = screen.getByText(\"No padding\");\n    expect(card).not.toHaveClass(\"card-padding-sm\");\n    expect(card).not.toHaveClass(\"card-padding-md\");\n    expect(card).not.toHaveClass(\"card-padding-lg\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface CarouselProps extends React.HTMLAttributes<HTMLDivElement> {\n  items: React.ReactNode[];\n  showDots?: boolean;\n  showArrows?: boolean;\n}\n\nexport const Carousel = React.forwardRef<HTMLDivElement, CarouselProps>(\n  ({ items, showDots = true, showArrows = true, className, ...rest }, ref) => {\n    const [currentIndex, setCurrentIndex] = React.useState(0);\n\n    const goToSlide = (index: number) => {\n      setCurrentIndex(index);\n    };\n\n    const goToPrevious = () => {\n      setCurrentIndex(prev => prev === 0 ? items.length - 1 : prev - 1);\n    };\n\n    const goToNext = () => {\n      setCurrentIndex(prev => prev === items.length - 1 ? 0 : prev + 1);\n    };\n\n    return (\n      <div\n        {...rest}\n        ref={ref}\n        className={[\"carousel\", className].filter(Boolean).join(\" \")}\n      >\n        <div className=\"carousel-content\">\n          {items[currentIndex]}\n        </div>\n\n        {showArrows && (\n          <>\n            <button onClick={goToPrevious} aria-label=\"Previous slide\">\n              Previous\n            </button>\n            <button onClick={goToNext} aria-label=\"Next slide\">\n              Next\n            </button>\n          </>\n        )}\n\n        {showDots && (\n          <div className=\"carousel-dots\">\n            {items.map((_, index) => (\n              <button\n                key={index}\n                onClick={() => goToSlide(index)}\n                aria-label={`Go to slide ${index + 1}`}\n              >\n                Dot {index + 1}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    );\n  }\n);\nCarousel.displayName = \"Carousel\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Carousel } from \"../Carousel\";\n\nconst mockItems = [\n  <div key=\"1\">Slide 1</div>,\n  <div key=\"2\">Slide 2</div>,\n  <div key=\"3\">Slide 3</div>\n];\n\ntest(\"renders carousel with items\", () => {\n  render(<Carousel items={mockItems} />);\n  expect(screen.getByText(\"Slide 1\")).toBeInTheDocument();\n});\n\ntest(\"navigates with arrow buttons\", async () => {\n  const user = userEvent.setup();\n  render(<Carousel items={mockItems} />);\n\n  const nextButton = screen.getByLabelText(\"Next slide\");\n  await user.click(nextButton);\n\n  expect(screen.getByText(\"Slide 2\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface CarouselProps extends React.HTMLAttributes<HTMLDivElement> {\n  items: React.ReactNode[];\n  showDots?: boolean;\n  showArrows?: boolean;\n}\n\nexport const Carousel = React.forwardRef<HTMLDivElement, CarouselProps>(\n  ({ items, showDots = true, showArrows = true, className, ...rest }, ref) => {\n    const [currentIndex, setCurrentIndex] = React.useState(0);\n\n    const goToSlide = (index: number) => {\n      setCurrentIndex(index);\n    };\n\n    const goToPrevious = () => {\n      setCurrentIndex(prev => prev === 0 ? items.length - 1 : prev - 1);\n    };\n\n    const goToNext = () => {\n      setCurrentIndex(prev => prev === items.length - 1 ? 0 : prev + 1);\n    };\n\n    return (\n      <div\n        {...rest}\n        ref={ref}\n        className={[\"carousel\", className].filter(Boolean).join(\" \")}\n      >\n        <div className=\"carousel-content\">\n          {items[currentIndex]}\n        </div>\n\n        {showArrows && (\n          <>\n            <button onClick={goToPrevious} aria-label=\"Previous slide\">\n              Previous\n            </button>\n            <button onClick={goToNext} aria-label=\"Next slide\">\n              Next\n            </button>\n          </>\n        )}\n\n        {showDots && (\n          <div className=\"carousel-dots\">\n            {items.map((_, index) => (\n              <button\n                key={index}\n                onClick={() => goToSlide(index)}\n                aria-label={`Go to slide ${index + 1}`}\n              >\n                Dot {index + 1}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    );\n  }\n);\nCarousel.displayName = \"Carousel\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Carousel } from \"../Carousel\";\n\nconst mockItems = [\n  <div key=\"1\">Slide 1</div>,\n  <div key=\"2\">Slide 2</div>,\n  <div key=\"3\">Slide 3</div>\n];\n\ntest(\"renders carousel with items\", () => {\n  render(<Carousel items={mockItems} />);\n  expect(screen.getByText(\"Slide 1\")).toBeInTheDocument();\n});\n\ntest(\"navigates with arrow buttons\", async () => {\n  const user = userEvent.setup();\n  render(<Carousel items={mockItems} />);\n\n  const nextButton = screen.getByLabelText(\"Next slide\");\n  await user.click(nextButton);\n\n  expect(screen.getByText(\"Slide 2\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface CarouselProps extends React.HTMLAttributes<HTMLDivElement> {\n  items: React.ReactNode[];\n  showDots?: boolean;\n  showArrows?: boolean;\n}\n\nexport const Carousel = React.forwardRef<HTMLDivElement, CarouselProps>(\n  ({ items, showDots = true, showArrows = true, className, ...rest }, ref) => {\n    const [currentIndex, setCurrentIndex] = React.useState(0);\n\n    const goToSlide = (index: number) => {\n      setCurrentIndex(index);\n    };\n\n    const goToPrevious = () => {\n      setCurrentIndex(prev => prev === 0 ? items.length - 1 : prev - 1);\n    };\n\n    const goToNext = () => {\n      setCurrentIndex(prev => prev === items.length - 1 ? 0 : prev + 1);\n    };\n\n    return (\n      <div\n        {...rest}\n        ref={ref}\n        className={[\"carousel\", className].filter(Boolean).join(\" \")}\n      >\n        <div className=\"carousel-content\">\n          {items[currentIndex]}\n        </div>\n\n        {showArrows && (\n          <>\n            <button onClick={goToPrevious} aria-label=\"Previous slide\">\n              Previous\n            </button>\n            <button onClick={goToNext} aria-label=\"Next slide\">\n              Next\n            </button>\n          </>\n        )}\n\n        {showDots && (\n          <div className=\"carousel-dots\">\n            {items.map((_, index) => (\n              <button\n                key={index}\n                onClick={() => goToSlide(index)}\n                aria-label={`Go to slide ${index + 1}`}\n              >\n                Dot {index + 1}\n              </button>\n            ))}\n          </div>\n        )}\n      </div>\n    );\n  }\n);\nCarousel.displayName = \"Carousel\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Carousel } from \"../Carousel\";\n\nconst mockItems = [\n  <div key=\"1\">Slide 1</div>,\n  <div key=\"2\">Slide 2</div>,\n  <div key=\"3\">Slide 3</div>\n];\n\ntest(\"renders carousel with items\", () => {\n  render(<Carousel items={mockItems} />);\n  expect(screen.getByText(\"Slide 1\")).toBeInTheDocument();\n});\n\ntest(\"navigates with arrow buttons\", async () => {\n  const user = userEvent.setup();\n  render(<Carousel items={mockItems} />);\n\n  const nextButton = screen.getByLabelText(\"Next slide\");\n  await user.click(nextButton);\n\n  expect(screen.getByText(\"Slide 2\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\ntype ChipVariant = \"default\" | \"outlined\" | \"filled\";\ntype ChipSize = \"sm\" | \"md\" | \"lg\";\n\nexport interface ChipProps extends React.HTMLAttributes<HTMLDivElement> {\n    label: string;\n    variant?: ChipVariant;\n    size?: ChipSize;\n    deletable?: boolean;\n    onDelete?: () => void;\n    disabled?: boolean;\n    icon?: React.ReactNode;\n    clickable?: boolean;\n}\n\nconst classesByVariant: Record<ChipVariant, string> = {\n    default: \"chip chip-default\",\n    outlined: \"chip chip-outlined\",\n    filled: \"chip chip-filled\",\n};\n\nconst classesBySize: Record<ChipSize, string> = {\n    sm: \"chip-sm\",\n    md: \"chip-md\",\n    lg: \"chip-lg\",\n};\n\nexport const Chip = React.forwardRef<HTMLDivElement, ChipProps>(\n    ({\n        label,\n        variant = \"default\",\n        size = \"md\",\n        deletable = false,\n        onDelete,\n        disabled = false,\n        icon,\n        clickable = false,\n        className,\n        onClick,\n        ...rest\n    }, ref) => {\n        const classes = `${classesByVariant[variant]} ${classesBySize[size]} ${disabled ? \"chip-disabled\" : \"\"\n            } ${clickable ? \"chip-clickable\" : \"\"} ${className || \"\"}`.trim();\n\n        const handleDelete = (e: React.MouseEvent) => {\n            e.stopPropagation();\n            if (onDelete && !disabled) {\n                onDelete();\n            }\n        };\n\n        const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n            if (!disabled && clickable && onClick) {\n                onClick(e);\n            }\n        };\n\n        const handleKeyDown = (e: React.KeyboardEvent) => {\n            if (e.key === \"Enter\" || e.key === \" \") {\n                e.preventDefault();\n                if (!disabled && clickable && onClick) {\n                    onClick(e as any);\n                }\n            }\n            if (e.key === \"Delete\" || e.key === \"Backspace\") {\n                if (deletable && onDelete && !disabled) {\n                    onDelete();\n                }\n            }\n        };\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                onClick={handleClick}\n                onKeyDown={handleKeyDown}\n                tabIndex={clickable && !disabled ? 0 : undefined}\n                role={clickable ? \"button\" : undefined}\n                aria-disabled={disabled}\n            >\n                {icon && <span className=\"chip-icon\">{icon}</span>}\n                <span className=\"chip-label\">{label}</span>\n                {deletable && (\n                    <button\n                        type=\"button\"\n                        className=\"chip-delete\"\n                        onClick={handleDelete}\n                        disabled={disabled}\n                        aria-label={`Remove ${label}`}\n                    >\n                        ×\n                    </button>\n                )}\n            </div>\n        );\n    }\n);\nChip.displayName = \"Chip\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Chip } from \"../Chip\";\n\ntest(\"renders with label\", () => {\n    render(<Chip label=\"Test Chip\" />);\n    expect(screen.getByText(\"Test Chip\")).toBeInTheDocument();\n});\n\ntest(\"applies variant and size classes\", () => {\n    render(<Chip label=\"Chip\" variant=\"outlined\" size=\"lg\" />);\n    const chip = screen.getByText(\"Chip\").parentElement;\n    expect(chip).toHaveClass(\"chip\", \"chip-outlined\", \"chip-lg\");\n});\n\ntest(\"shows delete button when deletable\", () => {\n    const onDelete = vi.fn();\n    render(<Chip label=\"Deletable\" deletable onDelete={onDelete} />);\n    expect(screen.getByLabelText(\"Remove Deletable\")).toBeInTheDocument();\n});\n\ntest(\"calls onDelete when delete button clicked\", async () => {\n    const user = userEvent.setup();\n    const onDelete = vi.fn();\n    render(<Chip label=\"Delete Me\" deletable onDelete={onDelete} />);\n\n    await user.click(screen.getByLabelText(\"Remove Delete Me\"));\n    expect(onDelete).toHaveBeenCalledTimes(1);\n});\n\ntest(\"handles click when clickable\", async () => {\n    const user = userEvent.setup();\n    const onClick = vi.fn();\n    render(<Chip label=\"Clickable\" clickable onClick={onClick} />);\n\n    const chip = screen.getByRole(\"button\", { name: /clickable/i });\n    await user.click(chip);\n    expect(onClick).toHaveBeenCalledTimes(1);\n});\n\ntest(\"handles keyboard events\", async () => {\n    const user = userEvent.setup();\n    const onClick = vi.fn();\n    const onDelete = vi.fn();\n\n    render(\n        <Chip\n            label=\"Keyboard\"\n            clickable\n            deletable\n            onClick={onClick}\n            onDelete={onDelete}\n        />\n    );\n\n    const chip = screen.getByRole(\"button\", { name: /keyboard/i });\n    chip.focus();\n\n    await user.keyboard(\"{Enter}\");\n    expect(onClick).toHaveBeenCalledTimes(1);\n\n    await user.keyboard(\"{Delete}\");\n    expect(onDelete).toHaveBeenCalledTimes(1);\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n    const user = userEvent.setup();\n    const onClick = vi.fn();\n    const onDelete = vi.fn();\n\n    render(\n        <Chip\n            label=\"Disabled\"\n            disabled\n            clickable\n            deletable\n            onClick={onClick}\n            onDelete={onDelete}\n        />\n    );\n\n    const chip = screen.getByText(\"Disabled\").parentElement;\n    const deleteBtn = screen.getByLabelText(\"Remove Disabled\");\n\n    expect(chip).toHaveClass(\"chip-disabled\");\n    expect(deleteBtn).toBeDisabled();\n});\n\ntest(\"renders with icon\", () => {\n    render(<Chip label=\"With Icon\" icon={<span>🎉</span>} />);\n    expect(screen.getByText(\"🎉\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\ntype ChipVariant = \"default\" | \"outlined\" | \"filled\";\ntype ChipSize = \"sm\" | \"md\" | \"lg\";\n\nexport interface ChipProps extends React.HTMLAttributes<HTMLDivElement> {\n    label: string;\n    variant?: ChipVariant;\n    size?: ChipSize;\n    deletable?: boolean;\n    onDelete?: () => void;\n    disabled?: boolean;\n    icon?: React.ReactNode;\n    clickable?: boolean;\n}\n\nconst classesByVariant: Record<ChipVariant, string> = {\n    default: \"chip chip-default\",\n    outlined: \"chip chip-outlined\",\n    filled: \"chip chip-filled\",\n};\n\nconst classesBySize: Record<ChipSize, string> = {\n    sm: \"chip-sm\",\n    md: \"chip-md\",\n    lg: \"chip-lg\",\n};\n\nexport const Chip = React.forwardRef<HTMLDivElement, ChipProps>(\n    ({\n        label,\n        variant = \"default\",\n        size = \"md\",\n        deletable = false,\n        onDelete,\n        disabled = false,\n        icon,\n        clickable = false,\n        className,\n        onClick,\n        ...rest\n    }, ref) => {\n        const classes = `${classesByVariant[variant]} ${classesBySize[size]} ${disabled ? \"chip-disabled\" : \"\"\n            } ${clickable ? \"chip-clickable\" : \"\"} ${className || \"\"}`.trim();\n\n        const handleDelete = (e: React.MouseEvent) => {\n            e.stopPropagation();\n            if (onDelete && !disabled) {\n                onDelete();\n            }\n        };\n\n        const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n            if (!disabled && clickable && onClick) {\n                onClick(e);\n            }\n        };\n\n        const handleKeyDown = (e: React.KeyboardEvent) => {\n            if (e.key === \"Enter\" || e.key === \" \") {\n                e.preventDefault();\n                if (!disabled && clickable && onClick) {\n                    onClick(e as any);\n                }\n            }\n            if (e.key === \"Delete\" || e.key === \"Backspace\") {\n                if (deletable && onDelete && !disabled) {\n                    onDelete();\n                }\n            }\n        };\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                onClick={handleClick}\n                onKeyDown={handleKeyDown}\n                tabIndex={clickable && !disabled ? 0 : undefined}\n                role={clickable ? \"button\" : undefined}\n                aria-disabled={disabled}\n            >\n                {icon && <span className=\"chip-icon\">{icon}</span>}\n                <span className=\"chip-label\">{label}</span>\n                {deletable && (\n                    <button\n                        type=\"button\"\n                        className=\"chip-delete\"\n                        onClick={handleDelete}\n                        disabled={disabled}\n                        aria-label={`Remove ${label}`}\n                    >\n                        ×\n                    </button>\n                )}\n            </div>\n        );\n    }\n);\nChip.displayName = \"Chip\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Chip } from \"../Chip\";\n\ntest(\"renders with label\", () => {\n    render(<Chip label=\"Test Chip\" />);\n    expect(screen.getByText(\"Test Chip\")).toBeInTheDocument();\n});\n\ntest(\"applies variant and size classes\", () => {\n    render(<Chip label=\"Chip\" variant=\"outlined\" size=\"lg\" />);\n    const chip = screen.getByText(\"Chip\").parentElement;\n    expect(chip).toHaveClass(\"chip\", \"chip-outlined\", \"chip-lg\");\n});\n\ntest(\"shows delete button when deletable\", () => {\n    const onDelete = vi.fn();\n    render(<Chip label=\"Deletable\" deletable onDelete={onDelete} />);\n    expect(screen.getByLabelText(\"Remove Deletable\")).toBeInTheDocument();\n});\n\ntest(\"calls onDelete when delete button clicked\", async () => {\n    const user = userEvent.setup();\n    const onDelete = vi.fn();\n    render(<Chip label=\"Delete Me\" deletable onDelete={onDelete} />);\n\n    await user.click(screen.getByLabelText(\"Remove Delete Me\"));\n    expect(onDelete).toHaveBeenCalledTimes(1);\n});\n\ntest(\"handles click when clickable\", async () => {\n    const user = userEvent.setup();\n    const onClick = vi.fn();\n    render(<Chip label=\"Clickable\" clickable onClick={onClick} />);\n\n    const chip = screen.getByRole(\"button\", { name: /clickable/i });\n    await user.click(chip);\n    expect(onClick).toHaveBeenCalledTimes(1);\n});\n\ntest(\"handles keyboard events\", async () => {\n    const user = userEvent.setup();\n    const onClick = vi.fn();\n    const onDelete = vi.fn();\n\n    render(\n        <Chip\n            label=\"Keyboard\"\n            clickable\n            deletable\n            onClick={onClick}\n            onDelete={onDelete}\n        />\n    );\n\n    const chip = screen.getByRole(\"button\", { name: /keyboard/i });\n    chip.focus();\n\n    await user.keyboard(\"{Enter}\");\n    expect(onClick).toHaveBeenCalledTimes(1);\n\n    await user.keyboard(\"{Delete}\");\n    expect(onDelete).toHaveBeenCalledTimes(1);\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n    const user = userEvent.setup();\n    const onClick = vi.fn();\n    const onDelete = vi.fn();\n\n    render(\n        <Chip\n            label=\"Disabled\"\n            disabled\n            clickable\n            deletable\n            onClick={onClick}\n            onDelete={onDelete}\n        />\n    );\n\n    const chip = screen.getByText(\"Disabled\").parentElement;\n    const deleteBtn = screen.getByLabelText(\"Remove Disabled\");\n\n    expect(chip).toHaveClass(\"chip-disabled\");\n    expect(deleteBtn).toBeDisabled();\n});\n\ntest(\"renders with icon\", () => {\n    render(<Chip label=\"With Icon\" icon={<span>🎉</span>} />);\n    expect(screen.getByText(\"🎉\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\ntype ChipVariant = \"default\" | \"outlined\" | \"filled\";\ntype ChipSize = \"sm\" | \"md\" | \"lg\";\n\nexport interface ChipProps extends React.HTMLAttributes<HTMLDivElement> {\n    label: string;\n    variant?: ChipVariant;\n    size?: ChipSize;\n    deletable?: boolean;\n    onDelete?: () => void;\n    disabled?: boolean;\n    icon?: React.ReactNode;\n    clickable?: boolean;\n}\n\nconst classesByVariant: Record<ChipVariant, string> = {\n    default: \"chip chip-default\",\n    outlined: \"chip chip-outlined\",\n    filled: \"chip chip-filled\",\n};\n\nconst classesBySize: Record<ChipSize, string> = {\n    sm: \"chip-sm\",\n    md: \"chip-md\",\n    lg: \"chip-lg\",\n};\n\nexport const Chip = React.forwardRef<HTMLDivElement, ChipProps>(\n    ({\n        label,\n        variant = \"default\",\n        size = \"md\",\n        deletable = false,\n        onDelete,\n        disabled = false,\n        icon,\n        clickable = false,\n        className,\n        onClick,\n        ...rest\n    }, ref) => {\n        const classes = `${classesByVariant[variant]} ${classesBySize[size]} ${disabled ? \"chip-disabled\" : \"\"\n            } ${clickable ? \"chip-clickable\" : \"\"} ${className || \"\"}`.trim();\n\n        const handleDelete = (e: React.MouseEvent) => {\n            e.stopPropagation();\n            if (onDelete && !disabled) {\n                onDelete();\n            }\n        };\n\n        const handleClick = (e: React.MouseEvent<HTMLDivElement>) => {\n            if (!disabled && clickable && onClick) {\n                onClick(e);\n            }\n        };\n\n        const handleKeyDown = (e: React.KeyboardEvent) => {\n            if (e.key === \"Enter\" || e.key === \" \") {\n                e.preventDefault();\n                if (!disabled && clickable && onClick) {\n                    onClick(e as any);\n                }\n            }\n            if (e.key === \"Delete\" || e.key === \"Backspace\") {\n                if (deletable && onDelete && !disabled) {\n                    onDelete();\n                }\n            }\n        };\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                onClick={handleClick}\n                onKeyDown={handleKeyDown}\n                tabIndex={clickable && !disabled ? 0 : undefined}\n                role={clickable ? \"button\" : undefined}\n                aria-disabled={disabled}\n            >\n                {icon && <span className=\"chip-icon\">{icon}</span>}\n                <span className=\"chip-label\">{label}</span>\n                {deletable && (\n                    <button\n                        type=\"button\"\n                        className=\"chip-delete\"\n                        onClick={handleDelete}\n                        disabled={disabled}\n                        aria-label={`Remove ${label}`}\n                    >\n                        ×\n                    </button>\n                )}\n            </div>\n        );\n    }\n);\nChip.displayName = \"Chip\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Chip } from \"../Chip\";\n\ntest(\"renders with label\", () => {\n    render(<Chip label=\"Test Chip\" />);\n    expect(screen.getByText(\"Test Chip\")).toBeInTheDocument();\n});\n\ntest(\"applies variant and size classes\", () => {\n    render(<Chip label=\"Chip\" variant=\"outlined\" size=\"lg\" />);\n    const chip = screen.getByText(\"Chip\").parentElement;\n    expect(chip).toHaveClass(\"chip\", \"chip-outlined\", \"chip-lg\");\n});\n\ntest(\"shows delete button when deletable\", () => {\n    const onDelete = vi.fn();\n    render(<Chip label=\"Deletable\" deletable onDelete={onDelete} />);\n    expect(screen.getByLabelText(\"Remove Deletable\")).toBeInTheDocument();\n});\n\ntest(\"calls onDelete when delete button clicked\", async () => {\n    const user = userEvent.setup();\n    const onDelete = vi.fn();\n    render(<Chip label=\"Delete Me\" deletable onDelete={onDelete} />);\n\n    await user.click(screen.getByLabelText(\"Remove Delete Me\"));\n    expect(onDelete).toHaveBeenCalledTimes(1);\n});\n\ntest(\"handles click when clickable\", async () => {\n    const user = userEvent.setup();\n    const onClick = vi.fn();\n    render(<Chip label=\"Clickable\" clickable onClick={onClick} />);\n\n    const chip = screen.getByRole(\"button\", { name: /clickable/i });\n    await user.click(chip);\n    expect(onClick).toHaveBeenCalledTimes(1);\n});\n\ntest(\"handles keyboard events\", async () => {\n    const user = userEvent.setup();\n    const onClick = vi.fn();\n    const onDelete = vi.fn();\n\n    render(\n        <Chip\n            label=\"Keyboard\"\n            clickable\n            deletable\n            onClick={onClick}\n            onDelete={onDelete}\n        />\n    );\n\n    const chip = screen.getByRole(\"button\", { name: /keyboard/i });\n    chip.focus();\n\n    await user.keyboard(\"{Enter}\");\n    expect(onClick).toHaveBeenCalledTimes(1);\n\n    await user.keyboard(\"{Delete}\");\n    expect(onDelete).toHaveBeenCalledTimes(1);\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n    const user = userEvent.setup();\n    const onClick = vi.fn();\n    const onDelete = vi.fn();\n\n    render(\n        <Chip\n            label=\"Disabled\"\n            disabled\n            clickable\n            deletable\n            onClick={onClick}\n            onDelete={onDelete}\n        />\n    );\n\n    const chip = screen.getByText(\"Disabled\").parentElement;\n    const deleteBtn = screen.getByLabelText(\"Remove Disabled\");\n\n    expect(chip).toHaveClass(\"chip-disabled\");\n    expect(deleteBtn).toBeDisabled();\n});\n\ntest(\"renders with icon\", () => {\n    render(<Chip label=\"With Icon\" icon={<span>🎉</span>} />);\n    expect(screen.getByText(\"🎉\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface ColorPickerProps extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (color: string) => void;\n  disabled?: boolean;\n  format?: \"hex\" | \"rgb\" | \"hsl\";\n  showInput?: boolean;\n  showPresets?: boolean;\n  presets?: string[];\n  size?: \"sm\" | \"md\" | \"lg\";\n  placement?: \"top\" | \"bottom\" | \"left\" | \"right\";\n}\n\nconst defaultPresets = [\n  \"#FF0000\", \"#FF8C00\", \"#FFD700\", \"#ADFF2F\", \"#00FF7F\",\n  \"#00CED1\", \"#1E90FF\", \"#9932CC\", \"#FF1493\", \"#000000\",\n  \"#808080\", \"#FFFFFF\", \"#8B4513\", \"#2F4F4F\", \"#800080\",\n];\n\nconst classesBySize: Record<NonNullable<ColorPickerProps[\"size\"]>, string> = {\n  sm: \"color-picker-sm\",\n  md: \"color-picker-md\",\n  lg: \"color-picker-lg\",\n};\n\nexport const ColorPicker = React.forwardRef<HTMLDivElement, ColorPickerProps>(\n  ({\n    value: controlledValue,\n    defaultValue = \"#000000\",\n    onChange,\n    disabled = false,\n    format = \"hex\",\n    showInput = true,\n    showPresets = true,\n    presets = defaultPresets,\n    size = \"md\",\n    placement = \"bottom\",\n    className,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState(defaultValue);\n    const [isOpen, setIsOpen] = React.useState(false);\n    const [inputValue, setInputValue] = React.useState(\"\");\n    \n    const containerRef = React.useRef<HTMLDivElement>(null);\n    const panelRef = React.useRef<HTMLDivElement>(null);\n    const combinedRef = React.useMemo(() => ref || containerRef, [ref]);\n\n    const isControlled = controlledValue !== undefined;\n    const currentValue = isControlled ? controlledValue : internalValue;\n\n    React.useEffect(() => {\n      setInputValue(currentValue);\n    }, [currentValue]);\n\n    const updateValue = (newValue: string) => {\n      if (onChange) {\n        onChange(newValue);\n      }\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n    };\n\n    const hexToRgb = (hex: string) => {\n      const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result\n        ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16),\n          }\n        : null;\n    };\n\n    const rgbToHex = (r: number, g: number, b: number) => {\n      return \"#\" + [r, g, b].map(x => {\n        const hex = x.toString(16);\n        return hex.length === 1 ? \"0\" + hex : hex;\n      }).join(\"\");\n    };\n\n    const hexToHsl = (hex: string) => {\n      const rgb = hexToRgb(hex);\n      if (!rgb) return null;\n      \n      const r = rgb.r / 255;\n      const g = rgb.g / 255;\n      const b = rgb.b / 255;\n      \n      const max = Math.max(r, g, b);\n      const min = Math.min(r, g, b);\n      let h = 0;\n      let s = 0;\n      const l = (max + min) / 2;\n      \n      if (max !== min) {\n        const d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        \n        switch (max) {\n          case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n          case g: h = (b - r) / d + 2; break;\n          case b: h = (r - g) / d + 4; break;\n        }\n        h /= 6;\n      }\n      \n      return {\n        h: Math.round(h * 360),\n        s: Math.round(s * 100),\n        l: Math.round(l * 100),\n      };\n    };\n\n    const formatColor = (hex: string) => {\n      switch (format) {\n        case \"rgb\": {\n          const rgb = hexToRgb(hex);\n          return rgb ? `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})` : hex;\n        }\n        case \"hsl\": {\n          const hsl = hexToHsl(hex);\n          return hsl ? `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)` : hex;\n        }\n        default:\n          return hex;\n      }\n    };\n\n    const parseColorInput = (input: string): string | null => {\n      input = input.trim();\n      \n      if (/^#?[0-9A-Fa-f]{6}$/.test(input)) {\n        return input.startsWith(\"#\") ? input : `#${input}`;\n      }\n      \n      const rgbMatch = input.match(/rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/);\n      if (rgbMatch) {\n        const [, r, g, b] = rgbMatch.map(Number);\n        if (r <= 255 && g <= 255 && b <= 255) {\n          return rgbToHex(r, g, b);\n        }\n      }\n      \n      return null;\n    };\n\n    const handleToggle = () => {\n      if (!disabled) {\n        setIsOpen(!isOpen);\n      }\n    };\n\n    const handlePresetClick = (color: string) => {\n      updateValue(color);\n      setIsOpen(false);\n    };\n\n    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n      const value = e.target.value;\n      setInputValue(value);\n      \n      const parsedColor = parseColorInput(value);\n      if (parsedColor) {\n        updateValue(parsedColor);\n      }\n    };\n\n    const handleInputKeyDown = (e: React.KeyboardEvent) => {\n      if (e.key === \"Enter\") {\n        const parsedColor = parseColorInput(inputValue);\n        if (parsedColor) {\n          updateValue(parsedColor);\n          setIsOpen(false);\n        }\n      }\n      if (e.key === \"Escape\") {\n        setInputValue(currentValue);\n        setIsOpen(false);\n      }\n    };\n\n    React.useEffect(() => {\n      const handleClickOutside = (event: MouseEvent) => {\n        if (\n          isOpen &&\n          combinedRef &&\n          \"current\" in combinedRef &&\n          combinedRef.current &&\n          !combinedRef.current.contains(event.target as Node)\n        ) {\n          setIsOpen(false);\n        }\n      };\n\n      document.addEventListener(\"mousedown\", handleClickOutside);\n      return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n    }, [isOpen, combinedRef]);\n\n    const classes = `color-picker ${classesBySize[size]} ${\n      disabled ? \"color-picker-disabled\" : \"\"\n    } ${isOpen ? \"color-picker-open\" : \"\"} ${className || \"\"}`.trim();\n\n    return (\n      <div {...rest} ref={combinedRef} className={classes}>\n        <div\n          className=\"color-picker-trigger\"\n          onClick={handleToggle}\n          role=\"button\"\n          tabIndex={disabled ? -1 : 0}\n          aria-label=\"Open color picker\"\n          aria-expanded={isOpen}\n          aria-disabled={disabled}\n          onKeyDown={(e) => {\n            if (e.key === \"Enter\" || e.key === \" \") {\n              e.preventDefault();\n              handleToggle();\n            }\n          }}\n        >\n          <div\n            className=\"color-picker-swatch\"\n            style={{ backgroundColor: currentValue }}\n          />\n          <span className=\"color-picker-arrow\">▼</span>\n        </div>\n\n        {isOpen && (\n          <div\n            ref={panelRef}\n            className={`color-picker-panel color-picker-panel-${placement}`}\n            role=\"dialog\"\n            aria-label=\"Color picker\"\n          >\n            {showInput && (\n              <div className=\"color-picker-input-section\">\n                <input\n                  type=\"text\"\n                  className=\"color-picker-input\"\n                  value={inputValue}\n                  onChange={handleInputChange}\n                  onKeyDown={handleInputKeyDown}\n                  placeholder=\"Enter color value\"\n                  aria-label=\"Color value input\"\n                />\n                <div className=\"color-picker-format-label\">{format.toUpperCase()}</div>\n              </div>\n            )}\n\n            {showPresets && (\n              <div className=\"color-picker-presets\">\n                <div className=\"color-picker-presets-label\">Presets</div>\n                <div className=\"color-picker-presets-grid\">\n                  {presets.map((preset, index) => (\n                    <button\n                      key={index}\n                      type=\"button\"\n                      className={`color-picker-preset ${\n                        preset === currentValue ? \"color-picker-preset-selected\" : \"\"\n                      }`}\n                      style={{ backgroundColor: preset }}\n                      onClick={() => handlePresetClick(preset)}\n                      aria-label={`Select color ${preset}`}\n                      title={preset}\n                    />\n                  ))}\n                </div>\n              </div>\n            )}\n\n            <div className=\"color-picker-footer\">\n              <div className=\"color-picker-preview\">\n                <div\n                  className=\"color-picker-preview-swatch\"\n                  style={{ backgroundColor: currentValue }}\n                />\n                <span className=\"color-picker-preview-text\">\n                  {formatColor(currentValue)}\n                </span>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n);\nColorPicker.displayName = \"ColorPicker\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { ColorPicker } from \"../ColorPicker\";\n\ntest(\"renders color picker trigger\", () => {\n  render(<ColorPicker />);\n  expect(screen.getByRole(\"button\", { name: /open color picker/i })).toBeInTheDocument();\n});\n\ntest(\"opens panel on trigger click\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker />);\n  \n  const trigger = screen.getByRole(\"button\", { name: /open color picker/i });\n  await user.click(trigger);\n  \n  expect(screen.getByRole(\"dialog\", { name: /color picker/i })).toBeInTheDocument();\n  expect(trigger).toHaveAttribute(\"aria-expanded\", \"true\");\n});\n\ntest(\"closes panel on outside click\", async () => {\n  const user = userEvent.setup();\n  render(\n    <div>\n      <ColorPicker />\n      <button>Outside button</button>\n    </div>\n  );\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n  \n  await user.click(screen.getByText(\"Outside button\"));\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"shows color input when enabled\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker showInput />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  expect(screen.getByLabelText(\"Color value input\")).toBeInTheDocument();\n});\n\ntest(\"handles color input change\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<ColorPicker showInput onChange={onChange} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  const input = screen.getByLabelText(\"Color value input\");\n  await user.clear(input);\n  await user.type(input, \"#FF0000\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onChange).toHaveBeenCalledWith(\"#FF0000\");\n});\n\ntest(\"shows preset colors when enabled\", async () => {\n  const user = userEvent.setup();\n  const presets = [\"#FF0000\", \"#00FF00\", \"#0000FF\"];\n  render(<ColorPicker showPresets presets={presets} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  expect(screen.getByText(\"Presets\")).toBeInTheDocument();\n  expect(screen.getByLabelText(\"Select color #FF0000\")).toBeInTheDocument();\n  expect(screen.getByLabelText(\"Select color #00FF00\")).toBeInTheDocument();\n  expect(screen.getByLabelText(\"Select color #0000FF\")).toBeInTheDocument();\n});\n\ntest(\"selects preset color\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const presets = [\"#FF0000\", \"#00FF00\"];\n  render(<ColorPicker showPresets presets={presets} onChange={onChange} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  await user.click(screen.getByLabelText(\"Select color #FF0000\"));\n  \n  expect(onChange).toHaveBeenCalledWith(\"#FF0000\");\n});\n\ntest(\"shows current color in different formats\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker value=\"#FF0000\" format=\"rgb\" />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  expect(screen.getByText(\"rgb(255, 0, 0)\")).toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  render(<ColorPicker value=\"#00FF00\" onChange={onChange} />);\n  \n  const swatch = document.querySelector(\".color-picker-swatch\") as HTMLElement;\n  expect(swatch).toHaveStyle({ backgroundColor: \"#00FF00\" });\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker />);\n  \n  const trigger = screen.getByRole(\"button\", { name: /open color picker/i });\n  trigger.focus();\n  \n  await user.keyboard(\"{Enter}\");\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n  \n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<ColorPicker disabled onChange={onChange} />);\n  \n  const trigger = screen.getByRole(\"button\", { name: /open color picker/i });\n  expect(trigger).toHaveAttribute(\"aria-disabled\", \"true\");\n  expect(trigger).toHaveAttribute(\"tabindex\", \"-1\");\n  \n  await user.click(trigger);\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n  expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<ColorPicker size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"color-picker-lg\");\n});\n\ntest(\"parses RGB input correctly\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<ColorPicker showInput onChange={onChange} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  const input = screen.getByLabelText(\"Color value input\");\n  await user.clear(input);\n  await user.type(input, \"rgb(255, 0, 0)\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onChange).toHaveBeenCalledWith(\"#ff0000\");\n});\n\ntest(\"shows HSL format correctly\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker value=\"#FF0000\" format=\"hsl\" />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  expect(screen.getByText(\"hsl(0, 100%, 50%)\")).toBeInTheDocument();\n});\n\ntest(\"highlights selected preset\", async () => {\n  const user = userEvent.setup();\n  const presets = [\"#FF0000\", \"#00FF00\"];\n  render(<ColorPicker value=\"#FF0000\" showPresets presets={presets} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  const selectedPreset = screen.getByLabelText(\"Select color #FF0000\");\n  expect(selectedPreset).toHaveClass(\"color-picker-preset-selected\");\n});\n\ntest(\"applies placement classes\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker placement=\"top\" />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  const panel = screen.getByRole(\"dialog\");\n  expect(panel).toHaveClass(\"color-picker-panel-top\");\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface ColorPickerProps extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (color: string) => void;\n  disabled?: boolean;\n  format?: \"hex\" | \"rgb\" | \"hsl\";\n  showInput?: boolean;\n  showPresets?: boolean;\n  presets?: string[];\n  size?: \"sm\" | \"md\" | \"lg\";\n  placement?: \"top\" | \"bottom\" | \"left\" | \"right\";\n}\n\nconst defaultPresets = [\n  \"#FF0000\", \"#FF8C00\", \"#FFD700\", \"#ADFF2F\", \"#00FF7F\",\n  \"#00CED1\", \"#1E90FF\", \"#9932CC\", \"#FF1493\", \"#000000\",\n  \"#808080\", \"#FFFFFF\", \"#8B4513\", \"#2F4F4F\", \"#800080\",\n];\n\nconst classesBySize: Record<NonNullable<ColorPickerProps[\"size\"]>, string> = {\n  sm: \"color-picker-sm\",\n  md: \"color-picker-md\",\n  lg: \"color-picker-lg\",\n};\n\nexport const ColorPicker = React.forwardRef<HTMLDivElement, ColorPickerProps>(\n  ({\n    value: controlledValue,\n    defaultValue = \"#000000\",\n    onChange,\n    disabled = false,\n    format = \"hex\",\n    showInput = true,\n    showPresets = true,\n    presets = defaultPresets,\n    size = \"md\",\n    placement = \"bottom\",\n    className,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState(defaultValue);\n    const [isOpen, setIsOpen] = React.useState(false);\n    const [inputValue, setInputValue] = React.useState(\"\");\n    \n    const containerRef = React.useRef<HTMLDivElement>(null);\n    const panelRef = React.useRef<HTMLDivElement>(null);\n    const combinedRef = React.useMemo(() => ref || containerRef, [ref]);\n\n    const isControlled = controlledValue !== undefined;\n    const currentValue = isControlled ? controlledValue : internalValue;\n\n    React.useEffect(() => {\n      setInputValue(currentValue);\n    }, [currentValue]);\n\n    const updateValue = (newValue: string) => {\n      if (onChange) {\n        onChange(newValue);\n      }\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n    };\n\n    const hexToRgb = (hex: string) => {\n      const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result\n        ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16),\n          }\n        : null;\n    };\n\n    const rgbToHex = (r: number, g: number, b: number) => {\n      return \"#\" + [r, g, b].map(x => {\n        const hex = x.toString(16);\n        return hex.length === 1 ? \"0\" + hex : hex;\n      }).join(\"\");\n    };\n\n    const hexToHsl = (hex: string) => {\n      const rgb = hexToRgb(hex);\n      if (!rgb) return null;\n      \n      const r = rgb.r / 255;\n      const g = rgb.g / 255;\n      const b = rgb.b / 255;\n      \n      const max = Math.max(r, g, b);\n      const min = Math.min(r, g, b);\n      let h = 0;\n      let s = 0;\n      const l = (max + min) / 2;\n      \n      if (max !== min) {\n        const d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        \n        switch (max) {\n          case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n          case g: h = (b - r) / d + 2; break;\n          case b: h = (r - g) / d + 4; break;\n        }\n        h /= 6;\n      }\n      \n      return {\n        h: Math.round(h * 360),\n        s: Math.round(s * 100),\n        l: Math.round(l * 100),\n      };\n    };\n\n    const formatColor = (hex: string) => {\n      switch (format) {\n        case \"rgb\": {\n          const rgb = hexToRgb(hex);\n          return rgb ? `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})` : hex;\n        }\n        case \"hsl\": {\n          const hsl = hexToHsl(hex);\n          return hsl ? `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)` : hex;\n        }\n        default:\n          return hex;\n      }\n    };\n\n    const parseColorInput = (input: string): string | null => {\n      input = input.trim();\n      \n      if (/^#?[0-9A-Fa-f]{6}$/.test(input)) {\n        return input.startsWith(\"#\") ? input : `#${input}`;\n      }\n      \n      const rgbMatch = input.match(/rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/);\n      if (rgbMatch) {\n        const [, r, g, b] = rgbMatch.map(Number);\n        if (r <= 255 && g <= 255 && b <= 255) {\n          return rgbToHex(r, g, b);\n        }\n      }\n      \n      return null;\n    };\n\n    const handleToggle = () => {\n      if (!disabled) {\n        setIsOpen(!isOpen);\n      }\n    };\n\n    const handlePresetClick = (color: string) => {\n      updateValue(color);\n      setIsOpen(false);\n    };\n\n    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n      const value = e.target.value;\n      setInputValue(value);\n      \n      const parsedColor = parseColorInput(value);\n      if (parsedColor) {\n        updateValue(parsedColor);\n      }\n    };\n\n    const handleInputKeyDown = (e: React.KeyboardEvent) => {\n      if (e.key === \"Enter\") {\n        const parsedColor = parseColorInput(inputValue);\n        if (parsedColor) {\n          updateValue(parsedColor);\n          setIsOpen(false);\n        }\n      }\n      if (e.key === \"Escape\") {\n        setInputValue(currentValue);\n        setIsOpen(false);\n      }\n    };\n\n    React.useEffect(() => {\n      const handleClickOutside = (event: MouseEvent) => {\n        if (\n          isOpen &&\n          combinedRef &&\n          \"current\" in combinedRef &&\n          combinedRef.current &&\n          !combinedRef.current.contains(event.target as Node)\n        ) {\n          setIsOpen(false);\n        }\n      };\n\n      document.addEventListener(\"mousedown\", handleClickOutside);\n      return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n    }, [isOpen, combinedRef]);\n\n    const classes = `color-picker ${classesBySize[size]} ${\n      disabled ? \"color-picker-disabled\" : \"\"\n    } ${isOpen ? \"color-picker-open\" : \"\"} ${className || \"\"}`.trim();\n\n    return (\n      <div {...rest} ref={combinedRef} className={classes}>\n        <div\n          className=\"color-picker-trigger\"\n          onClick={handleToggle}\n          role=\"button\"\n          tabIndex={disabled ? -1 : 0}\n          aria-label=\"Open color picker\"\n          aria-expanded={isOpen}\n          aria-disabled={disabled}\n          onKeyDown={(e) => {\n            if (e.key === \"Enter\" || e.key === \" \") {\n              e.preventDefault();\n              handleToggle();\n            }\n          }}\n        >\n          <div\n            className=\"color-picker-swatch\"\n            style={{ backgroundColor: currentValue }}\n          />\n          <span className=\"color-picker-arrow\">▼</span>\n        </div>\n\n        {isOpen && (\n          <div\n            ref={panelRef}\n            className={`color-picker-panel color-picker-panel-${placement}`}\n            role=\"dialog\"\n            aria-label=\"Color picker\"\n          >\n            {showInput && (\n              <div className=\"color-picker-input-section\">\n                <input\n                  type=\"text\"\n                  className=\"color-picker-input\"\n                  value={inputValue}\n                  onChange={handleInputChange}\n                  onKeyDown={handleInputKeyDown}\n                  placeholder=\"Enter color value\"\n                  aria-label=\"Color value input\"\n                />\n                <div className=\"color-picker-format-label\">{format.toUpperCase()}</div>\n              </div>\n            )}\n\n            {showPresets && (\n              <div className=\"color-picker-presets\">\n                <div className=\"color-picker-presets-label\">Presets</div>\n                <div className=\"color-picker-presets-grid\">\n                  {presets.map((preset, index) => (\n                    <button\n                      key={index}\n                      type=\"button\"\n                      className={`color-picker-preset ${\n                        preset === currentValue ? \"color-picker-preset-selected\" : \"\"\n                      }`}\n                      style={{ backgroundColor: preset }}\n                      onClick={() => handlePresetClick(preset)}\n                      aria-label={`Select color ${preset}`}\n                      title={preset}\n                    />\n                  ))}\n                </div>\n              </div>\n            )}\n\n            <div className=\"color-picker-footer\">\n              <div className=\"color-picker-preview\">\n                <div\n                  className=\"color-picker-preview-swatch\"\n                  style={{ backgroundColor: currentValue }}\n                />\n                <span className=\"color-picker-preview-text\">\n                  {formatColor(currentValue)}\n                </span>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n);\nColorPicker.displayName = \"ColorPicker\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { ColorPicker } from \"../ColorPicker\";\n\ntest(\"renders color picker trigger\", () => {\n  render(<ColorPicker />);\n  expect(screen.getByRole(\"button\", { name: /open color picker/i })).toBeInTheDocument();\n});\n\ntest(\"opens panel on trigger click\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker />);\n  \n  const trigger = screen.getByRole(\"button\", { name: /open color picker/i });\n  await user.click(trigger);\n  \n  expect(screen.getByRole(\"dialog\", { name: /color picker/i })).toBeInTheDocument();\n  expect(trigger).toHaveAttribute(\"aria-expanded\", \"true\");\n});\n\ntest(\"closes panel on outside click\", async () => {\n  const user = userEvent.setup();\n  render(\n    <div>\n      <ColorPicker />\n      <button>Outside button</button>\n    </div>\n  );\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n  \n  await user.click(screen.getByText(\"Outside button\"));\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"shows color input when enabled\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker showInput />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  expect(screen.getByLabelText(\"Color value input\")).toBeInTheDocument();\n});\n\ntest(\"handles color input change\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<ColorPicker showInput onChange={onChange} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  const input = screen.getByLabelText(\"Color value input\");\n  await user.clear(input);\n  await user.type(input, \"#FF0000\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onChange).toHaveBeenCalledWith(\"#FF0000\");\n});\n\ntest(\"shows preset colors when enabled\", async () => {\n  const user = userEvent.setup();\n  const presets = [\"#FF0000\", \"#00FF00\", \"#0000FF\"];\n  render(<ColorPicker showPresets presets={presets} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  expect(screen.getByText(\"Presets\")).toBeInTheDocument();\n  expect(screen.getByLabelText(\"Select color #FF0000\")).toBeInTheDocument();\n  expect(screen.getByLabelText(\"Select color #00FF00\")).toBeInTheDocument();\n  expect(screen.getByLabelText(\"Select color #0000FF\")).toBeInTheDocument();\n});\n\ntest(\"selects preset color\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const presets = [\"#FF0000\", \"#00FF00\"];\n  render(<ColorPicker showPresets presets={presets} onChange={onChange} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  await user.click(screen.getByLabelText(\"Select color #FF0000\"));\n  \n  expect(onChange).toHaveBeenCalledWith(\"#FF0000\");\n});\n\ntest(\"shows current color in different formats\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker value=\"#FF0000\" format=\"rgb\" />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  expect(screen.getByText(\"rgb(255, 0, 0)\")).toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  render(<ColorPicker value=\"#00FF00\" onChange={onChange} />);\n  \n  const swatch = document.querySelector(\".color-picker-swatch\") as HTMLElement;\n  expect(swatch).toHaveStyle({ backgroundColor: \"#00FF00\" });\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker />);\n  \n  const trigger = screen.getByRole(\"button\", { name: /open color picker/i });\n  trigger.focus();\n  \n  await user.keyboard(\"{Enter}\");\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n  \n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<ColorPicker disabled onChange={onChange} />);\n  \n  const trigger = screen.getByRole(\"button\", { name: /open color picker/i });\n  expect(trigger).toHaveAttribute(\"aria-disabled\", \"true\");\n  expect(trigger).toHaveAttribute(\"tabindex\", \"-1\");\n  \n  await user.click(trigger);\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n  expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<ColorPicker size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"color-picker-lg\");\n});\n\ntest(\"parses RGB input correctly\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<ColorPicker showInput onChange={onChange} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  const input = screen.getByLabelText(\"Color value input\");\n  await user.clear(input);\n  await user.type(input, \"rgb(255, 0, 0)\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onChange).toHaveBeenCalledWith(\"#ff0000\");\n});\n\ntest(\"shows HSL format correctly\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker value=\"#FF0000\" format=\"hsl\" />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  expect(screen.getByText(\"hsl(0, 100%, 50%)\")).toBeInTheDocument();\n});\n\ntest(\"highlights selected preset\", async () => {\n  const user = userEvent.setup();\n  const presets = [\"#FF0000\", \"#00FF00\"];\n  render(<ColorPicker value=\"#FF0000\" showPresets presets={presets} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  const selectedPreset = screen.getByLabelText(\"Select color #FF0000\");\n  expect(selectedPreset).toHaveClass(\"color-picker-preset-selected\");\n});\n\ntest(\"applies placement classes\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker placement=\"top\" />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  const panel = screen.getByRole(\"dialog\");\n  expect(panel).toHaveClass(\"color-picker-panel-top\");\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface ColorPickerProps extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (color: string) => void;\n  disabled?: boolean;\n  format?: \"hex\" | \"rgb\" | \"hsl\";\n  showInput?: boolean;\n  showPresets?: boolean;\n  presets?: string[];\n  size?: \"sm\" | \"md\" | \"lg\";\n  placement?: \"top\" | \"bottom\" | \"left\" | \"right\";\n}\n\nconst defaultPresets = [\n  \"#FF0000\", \"#FF8C00\", \"#FFD700\", \"#ADFF2F\", \"#00FF7F\",\n  \"#00CED1\", \"#1E90FF\", \"#9932CC\", \"#FF1493\", \"#000000\",\n  \"#808080\", \"#FFFFFF\", \"#8B4513\", \"#2F4F4F\", \"#800080\",\n];\n\nconst classesBySize: Record<NonNullable<ColorPickerProps[\"size\"]>, string> = {\n  sm: \"color-picker-sm\",\n  md: \"color-picker-md\",\n  lg: \"color-picker-lg\",\n};\n\nexport const ColorPicker = React.forwardRef<HTMLDivElement, ColorPickerProps>(\n  ({\n    value: controlledValue,\n    defaultValue = \"#000000\",\n    onChange,\n    disabled = false,\n    format = \"hex\",\n    showInput = true,\n    showPresets = true,\n    presets = defaultPresets,\n    size = \"md\",\n    placement = \"bottom\",\n    className,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState(defaultValue);\n    const [isOpen, setIsOpen] = React.useState(false);\n    const [inputValue, setInputValue] = React.useState(\"\");\n    \n    const containerRef = React.useRef<HTMLDivElement>(null);\n    const panelRef = React.useRef<HTMLDivElement>(null);\n    const combinedRef = React.useMemo(() => ref || containerRef, [ref]);\n\n    const isControlled = controlledValue !== undefined;\n    const currentValue = isControlled ? controlledValue : internalValue;\n\n    React.useEffect(() => {\n      setInputValue(currentValue);\n    }, [currentValue]);\n\n    const updateValue = (newValue: string) => {\n      if (onChange) {\n        onChange(newValue);\n      }\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n    };\n\n    const hexToRgb = (hex: string) => {\n      const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result\n        ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16),\n          }\n        : null;\n    };\n\n    const rgbToHex = (r: number, g: number, b: number) => {\n      return \"#\" + [r, g, b].map(x => {\n        const hex = x.toString(16);\n        return hex.length === 1 ? \"0\" + hex : hex;\n      }).join(\"\");\n    };\n\n    const hexToHsl = (hex: string) => {\n      const rgb = hexToRgb(hex);\n      if (!rgb) return null;\n      \n      const r = rgb.r / 255;\n      const g = rgb.g / 255;\n      const b = rgb.b / 255;\n      \n      const max = Math.max(r, g, b);\n      const min = Math.min(r, g, b);\n      let h = 0;\n      let s = 0;\n      const l = (max + min) / 2;\n      \n      if (max !== min) {\n        const d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        \n        switch (max) {\n          case r: h = (g - b) / d + (g < b ? 6 : 0); break;\n          case g: h = (b - r) / d + 2; break;\n          case b: h = (r - g) / d + 4; break;\n        }\n        h /= 6;\n      }\n      \n      return {\n        h: Math.round(h * 360),\n        s: Math.round(s * 100),\n        l: Math.round(l * 100),\n      };\n    };\n\n    const formatColor = (hex: string) => {\n      switch (format) {\n        case \"rgb\": {\n          const rgb = hexToRgb(hex);\n          return rgb ? `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})` : hex;\n        }\n        case \"hsl\": {\n          const hsl = hexToHsl(hex);\n          return hsl ? `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)` : hex;\n        }\n        default:\n          return hex;\n      }\n    };\n\n    const parseColorInput = (input: string): string | null => {\n      input = input.trim();\n      \n      if (/^#?[0-9A-Fa-f]{6}$/.test(input)) {\n        return input.startsWith(\"#\") ? input : `#${input}`;\n      }\n      \n      const rgbMatch = input.match(/rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/);\n      if (rgbMatch) {\n        const [, r, g, b] = rgbMatch.map(Number);\n        if (r <= 255 && g <= 255 && b <= 255) {\n          return rgbToHex(r, g, b);\n        }\n      }\n      \n      return null;\n    };\n\n    const handleToggle = () => {\n      if (!disabled) {\n        setIsOpen(!isOpen);\n      }\n    };\n\n    const handlePresetClick = (color: string) => {\n      updateValue(color);\n      setIsOpen(false);\n    };\n\n    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n      const value = e.target.value;\n      setInputValue(value);\n      \n      const parsedColor = parseColorInput(value);\n      if (parsedColor) {\n        updateValue(parsedColor);\n      }\n    };\n\n    const handleInputKeyDown = (e: React.KeyboardEvent) => {\n      if (e.key === \"Enter\") {\n        const parsedColor = parseColorInput(inputValue);\n        if (parsedColor) {\n          updateValue(parsedColor);\n          setIsOpen(false);\n        }\n      }\n      if (e.key === \"Escape\") {\n        setInputValue(currentValue);\n        setIsOpen(false);\n      }\n    };\n\n    React.useEffect(() => {\n      const handleClickOutside = (event: MouseEvent) => {\n        if (\n          isOpen &&\n          combinedRef &&\n          \"current\" in combinedRef &&\n          combinedRef.current &&\n          !combinedRef.current.contains(event.target as Node)\n        ) {\n          setIsOpen(false);\n        }\n      };\n\n      document.addEventListener(\"mousedown\", handleClickOutside);\n      return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n    }, [isOpen, combinedRef]);\n\n    const classes = `color-picker ${classesBySize[size]} ${\n      disabled ? \"color-picker-disabled\" : \"\"\n    } ${isOpen ? \"color-picker-open\" : \"\"} ${className || \"\"}`.trim();\n\n    return (\n      <div {...rest} ref={combinedRef} className={classes}>\n        <div\n          className=\"color-picker-trigger\"\n          onClick={handleToggle}\n          role=\"button\"\n          tabIndex={disabled ? -1 : 0}\n          aria-label=\"Open color picker\"\n          aria-expanded={isOpen}\n          aria-disabled={disabled}\n          onKeyDown={(e) => {\n            if (e.key === \"Enter\" || e.key === \" \") {\n              e.preventDefault();\n              handleToggle();\n            }\n          }}\n        >\n          <div\n            className=\"color-picker-swatch\"\n            style={{ backgroundColor: currentValue }}\n          />\n          <span className=\"color-picker-arrow\">▼</span>\n        </div>\n\n        {isOpen && (\n          <div\n            ref={panelRef}\n            className={`color-picker-panel color-picker-panel-${placement}`}\n            role=\"dialog\"\n            aria-label=\"Color picker\"\n          >\n            {showInput && (\n              <div className=\"color-picker-input-section\">\n                <input\n                  type=\"text\"\n                  className=\"color-picker-input\"\n                  value={inputValue}\n                  onChange={handleInputChange}\n                  onKeyDown={handleInputKeyDown}\n                  placeholder=\"Enter color value\"\n                  aria-label=\"Color value input\"\n                />\n                <div className=\"color-picker-format-label\">{format.toUpperCase()}</div>\n              </div>\n            )}\n\n            {showPresets && (\n              <div className=\"color-picker-presets\">\n                <div className=\"color-picker-presets-label\">Presets</div>\n                <div className=\"color-picker-presets-grid\">\n                  {presets.map((preset, index) => (\n                    <button\n                      key={index}\n                      type=\"button\"\n                      className={`color-picker-preset ${\n                        preset === currentValue ? \"color-picker-preset-selected\" : \"\"\n                      }`}\n                      style={{ backgroundColor: preset }}\n                      onClick={() => handlePresetClick(preset)}\n                      aria-label={`Select color ${preset}`}\n                      title={preset}\n                    />\n                  ))}\n                </div>\n              </div>\n            )}\n\n            <div className=\"color-picker-footer\">\n              <div className=\"color-picker-preview\">\n                <div\n                  className=\"color-picker-preview-swatch\"\n                  style={{ backgroundColor: currentValue }}\n                />\n                <span className=\"color-picker-preview-text\">\n                  {formatColor(currentValue)}\n                </span>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n);\nColorPicker.displayName = \"ColorPicker\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { ColorPicker } from \"../ColorPicker\";\n\ntest(\"renders color picker trigger\", () => {\n  render(<ColorPicker />);\n  expect(screen.getByRole(\"button\", { name: /open color picker/i })).toBeInTheDocument();\n});\n\ntest(\"opens panel on trigger click\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker />);\n  \n  const trigger = screen.getByRole(\"button\", { name: /open color picker/i });\n  await user.click(trigger);\n  \n  expect(screen.getByRole(\"dialog\", { name: /color picker/i })).toBeInTheDocument();\n  expect(trigger).toHaveAttribute(\"aria-expanded\", \"true\");\n});\n\ntest(\"closes panel on outside click\", async () => {\n  const user = userEvent.setup();\n  render(\n    <div>\n      <ColorPicker />\n      <button>Outside button</button>\n    </div>\n  );\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n  \n  await user.click(screen.getByText(\"Outside button\"));\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"shows color input when enabled\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker showInput />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  expect(screen.getByLabelText(\"Color value input\")).toBeInTheDocument();\n});\n\ntest(\"handles color input change\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<ColorPicker showInput onChange={onChange} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  const input = screen.getByLabelText(\"Color value input\");\n  await user.clear(input);\n  await user.type(input, \"#FF0000\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onChange).toHaveBeenCalledWith(\"#FF0000\");\n});\n\ntest(\"shows preset colors when enabled\", async () => {\n  const user = userEvent.setup();\n  const presets = [\"#FF0000\", \"#00FF00\", \"#0000FF\"];\n  render(<ColorPicker showPresets presets={presets} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  expect(screen.getByText(\"Presets\")).toBeInTheDocument();\n  expect(screen.getByLabelText(\"Select color #FF0000\")).toBeInTheDocument();\n  expect(screen.getByLabelText(\"Select color #00FF00\")).toBeInTheDocument();\n  expect(screen.getByLabelText(\"Select color #0000FF\")).toBeInTheDocument();\n});\n\ntest(\"selects preset color\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const presets = [\"#FF0000\", \"#00FF00\"];\n  render(<ColorPicker showPresets presets={presets} onChange={onChange} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  await user.click(screen.getByLabelText(\"Select color #FF0000\"));\n  \n  expect(onChange).toHaveBeenCalledWith(\"#FF0000\");\n});\n\ntest(\"shows current color in different formats\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker value=\"#FF0000\" format=\"rgb\" />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  expect(screen.getByText(\"rgb(255, 0, 0)\")).toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  render(<ColorPicker value=\"#00FF00\" onChange={onChange} />);\n  \n  const swatch = document.querySelector(\".color-picker-swatch\") as HTMLElement;\n  expect(swatch).toHaveStyle({ backgroundColor: \"#00FF00\" });\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker />);\n  \n  const trigger = screen.getByRole(\"button\", { name: /open color picker/i });\n  trigger.focus();\n  \n  await user.keyboard(\"{Enter}\");\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n  \n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<ColorPicker disabled onChange={onChange} />);\n  \n  const trigger = screen.getByRole(\"button\", { name: /open color picker/i });\n  expect(trigger).toHaveAttribute(\"aria-disabled\", \"true\");\n  expect(trigger).toHaveAttribute(\"tabindex\", \"-1\");\n  \n  await user.click(trigger);\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n  expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<ColorPicker size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"color-picker-lg\");\n});\n\ntest(\"parses RGB input correctly\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<ColorPicker showInput onChange={onChange} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  const input = screen.getByLabelText(\"Color value input\");\n  await user.clear(input);\n  await user.type(input, \"rgb(255, 0, 0)\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onChange).toHaveBeenCalledWith(\"#ff0000\");\n});\n\ntest(\"shows HSL format correctly\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker value=\"#FF0000\" format=\"hsl\" />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  expect(screen.getByText(\"hsl(0, 100%, 50%)\")).toBeInTheDocument();\n});\n\ntest(\"highlights selected preset\", async () => {\n  const user = userEvent.setup();\n  const presets = [\"#FF0000\", \"#00FF00\"];\n  render(<ColorPicker value=\"#FF0000\" showPresets presets={presets} />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  const selectedPreset = screen.getByLabelText(\"Select color #FF0000\");\n  expect(selectedPreset).toHaveClass(\"color-picker-preset-selected\");\n});\n\ntest(\"applies placement classes\", async () => {\n  const user = userEvent.setup();\n  render(<ColorPicker placement=\"top\" />);\n  \n  await user.click(screen.getByRole(\"button\", { name: /open color picker/i }));\n  \n  const panel = screen.getByRole(\"dialog\");\n  expect(panel).toHaveClass(\"color-picker-panel-top\");\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface DatePickerProps extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n  value?: Date;\n  defaultValue?: Date;\n  onChange?: (date: Date | null) => void;\n  format?: string;\n  placeholder?: string;\n  disabled?: boolean;\n  readOnly?: boolean;\n  clearable?: boolean;\n  showToday?: boolean;\n  minDate?: Date;\n  maxDate?: Date;\n  disabledDates?: (date: Date) => boolean;\n  size?: \"sm\" | \"md\" | \"lg\";\n  placement?: \"top\" | \"bottom\" | \"left\" | \"right\";\n}\n\nconst monthNames = [\n  \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n  \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n];\n\nconst dayNames = [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"];\n\nconst classesBySize: Record<NonNullable<DatePickerProps[\"size\"]>, string> = {\n  sm: \"date-picker-sm\",\n  md: \"date-picker-md\",\n  lg: \"date-picker-lg\",\n};\n\nexport const DatePicker = React.forwardRef<HTMLDivElement, DatePickerProps>(\n  ({\n    value: controlledValue,\n    defaultValue,\n    onChange,\n    format = \"MM/DD/YYYY\",\n    placeholder = \"Select date\",\n    disabled = false,\n    readOnly = false,\n    clearable = true,\n    showToday = true,\n    minDate,\n    maxDate,\n    disabledDates,\n    size = \"md\",\n    placement = \"bottom\",\n    className,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState<Date | null>(defaultValue || null);\n    const [isOpen, setIsOpen] = React.useState(false);\n    const [viewDate, setViewDate] = React.useState(() => \n      controlledValue || defaultValue || new Date()\n    );\n    const [inputValue, setInputValue] = React.useState(\"\");\n    \n    const containerRef = React.useRef<HTMLDivElement>(null);\n    const inputRef = React.useRef<HTMLInputElement>(null);\n    const combinedRef = React.useMemo(() => ref || containerRef, [ref]);\n\n    const isControlled = controlledValue !== undefined;\n    const currentValue = isControlled ? controlledValue : internalValue;\n\n    React.useEffect(() => {\n      if (currentValue) {\n        setInputValue(formatDate(currentValue, format));\n      } else {\n        setInputValue(\"\");\n      }\n    }, [currentValue, format]);\n\n    const formatDate = (date: Date, formatStr: string): string => {\n      const day = date.getDate().toString().padStart(2, \"0\");\n      const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n      const year = date.getFullYear().toString();\n      \n      return formatStr\n        .replace(\"DD\", day)\n        .replace(\"MM\", month)\n        .replace(\"YYYY\", year)\n        .replace(\"YY\", year.slice(-2));\n    };\n\n    const parseDate = (dateStr: string): Date | null => {\n      const cleanStr = dateStr.replace(/[^\\d]/g, \"\");\n      if (cleanStr.length !== 8) return null;\n      \n      const month = parseInt(cleanStr.slice(0, 2), 10);\n      const day = parseInt(cleanStr.slice(2, 4), 10);\n      const year = parseInt(cleanStr.slice(4, 8), 10);\n      \n      if (month < 1 || month > 12 || day < 1 || day > 31) return null;\n      \n      const date = new Date(year, month - 1, day);\n      if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {\n        return null;\n      }\n      \n      return date;\n    };\n\n    const updateValue = (newValue: Date | null) => {\n      if (onChange) {\n        onChange(newValue);\n      }\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n    };\n\n    const isDateDisabled = (date: Date): boolean => {\n      if (minDate && date < minDate) return true;\n      if (maxDate && date > maxDate) return true;\n      if (disabledDates && disabledDates(date)) return true;\n      return false;\n    };\n\n    const isSameDay = (date1: Date, date2: Date): boolean => {\n      return date1.getDate() === date2.getDate() &&\n             date1.getMonth() === date2.getMonth() &&\n             date1.getFullYear() === date2.getFullYear();\n    };\n\n    const getDaysInMonth = (date: Date): Date[] => {\n      const year = date.getFullYear();\n      const month = date.getMonth();\n      const firstDay = new Date(year, month, 1);\n      const lastDay = new Date(year, month + 1, 0);\n      const startDate = new Date(firstDay);\n      \n      const startDay = firstDay.getDay();\n      startDate.setDate(startDate.getDate() - startDay);\n      \n      const days: Date[] = [];\n      const endDate = new Date(startDate);\n      endDate.setDate(endDate.getDate() + 41); // 6 weeks\n      \n      for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {\n        days.push(new Date(d));\n      }\n      \n      return days;\n    };\n\n    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n      const value = e.target.value;\n      setInputValue(value);\n      \n      const parsedDate = parseDate(value);\n      if (parsedDate && !isDateDisabled(parsedDate)) {\n        updateValue(parsedDate);\n        setViewDate(parsedDate);\n      }\n    };\n\n    const handleInputKeyDown = (e: React.KeyboardEvent) => {\n      if (e.key === \"Enter\") {\n        const parsedDate = parseDate(inputValue);\n        if (parsedDate && !isDateDisabled(parsedDate)) {\n          updateValue(parsedDate);\n          setIsOpen(false);\n        }\n      }\n      if (e.key === \"Escape\") {\n        setInputValue(currentValue ? formatDate(currentValue, format) : \"\");\n        setIsOpen(false);\n      }\n      if (e.key === \"ArrowDown\" && !isOpen) {\n        setIsOpen(true);\n      }\n    };\n\n    const handleDateClick = (date: Date) => {\n      if (!isDateDisabled(date)) {\n        updateValue(date);\n        setIsOpen(false);\n        inputRef.current?.focus();\n      }\n    };\n\n    const handleClear = () => {\n      updateValue(null);\n      setInputValue(\"\");\n      inputRef.current?.focus();\n    };\n\n    const handleTodayClick = () => {\n      const today = new Date();\n      if (!isDateDisabled(today)) {\n        updateValue(today);\n        setViewDate(today);\n        setIsOpen(false);\n      }\n    };\n\n    const navigateMonth = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setMonth(newDate.getMonth() + direction);\n      setViewDate(newDate);\n    };\n\n    const navigateYear = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setFullYear(newDate.getFullYear() + direction);\n      setViewDate(newDate);\n    };\n\n    React.useEffect(() => {\n      const handleClickOutside = (event: MouseEvent) => {\n        if (\n          isOpen &&\n          combinedRef &&\n          \"current\" in combinedRef &&\n          combinedRef.current &&\n          !combinedRef.current.contains(event.target as Node)\n        ) {\n          setIsOpen(false);\n        }\n      };\n\n      document.addEventListener(\"mousedown\", handleClickOutside);\n      return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n    }, [isOpen, combinedRef]);\n\n    const classes = `date-picker ${classesBySize[size]} ${\n      disabled ? \"date-picker-disabled\" : \"\"\n    } ${isOpen ? \"date-picker-open\" : \"\"} ${className || \"\"}`.trim();\n\n    const today = new Date();\n    const days = getDaysInMonth(viewDate);\n\n    return (\n      <div {...rest} ref={combinedRef} className={classes}>\n        <div className=\"date-picker-input-wrapper\">\n          <input\n            ref={inputRef}\n            type=\"text\"\n            className=\"date-picker-input\"\n            value={inputValue}\n            onChange={handleInputChange}\n            onKeyDown={handleInputKeyDown}\n            onFocus={() => !disabled && !readOnly && setIsOpen(true)}\n            placeholder={placeholder}\n            disabled={disabled}\n            readOnly={readOnly}\n            aria-label=\"Date input\"\n            aria-expanded={isOpen}\n            aria-haspopup=\"dialog\"\n          />\n          \n          <div className=\"date-picker-suffix\">\n            {clearable && currentValue && !disabled && (\n              <button\n                type=\"button\"\n                className=\"date-picker-clear\"\n                onClick={handleClear}\n                aria-label=\"Clear date\"\n                tabIndex={-1}\n              >\n                ×\n              </button>\n            )}\n            <button\n              type=\"button\"\n              className=\"date-picker-calendar-icon\"\n              onClick={() => !disabled && setIsOpen(!isOpen)}\n              aria-label=\"Open calendar\"\n              disabled={disabled}\n              tabIndex={-1}\n            >\n              📅\n            </button>\n          </div>\n        </div>\n\n        {isOpen && (\n          <div\n            className={`date-picker-panel date-picker-panel-${placement}`}\n            role=\"dialog\"\n            aria-label=\"Date picker\"\n          >\n            <div className=\"date-picker-header\">\n              <div className=\"date-picker-nav\">\n                <button\n                  type=\"button\"\n                  className=\"date-picker-nav-button\"\n                  onClick={() => navigateYear(-1)}\n                  aria-label=\"Previous year\"\n                >\n                  «\n                </button>\n                <button\n                  type=\"button\"\n                  className=\"date-picker-nav-button\"\n                  onClick={() => navigateMonth(-1)}\n                  aria-label=\"Previous month\"\n                >\n                  ‹\n                </button>\n              </div>\n              \n              <div className=\"date-picker-month-year\">\n                {monthNames[viewDate.getMonth()]} {viewDate.getFullYear()}\n              </div>\n              \n              <div className=\"date-picker-nav\">\n                <button\n                  type=\"button\"\n                  className=\"date-picker-nav-button\"\n                  onClick={() => navigateMonth(1)}\n                  aria-label=\"Next month\"\n                >\n                  ›\n                </button>\n                <button\n                  type=\"button\"\n                  className=\"date-picker-nav-button\"\n                  onClick={() => navigateYear(1)}\n                  aria-label=\"Next year\"\n                >\n                  »\n                </button>\n              </div>\n            </div>\n\n            <div className=\"date-picker-calendar\">\n              <div className=\"date-picker-weekdays\">\n                {dayNames.map(day => (\n                  <div key={day} className=\"date-picker-weekday\">\n                    {day}\n                  </div>\n                ))}\n              </div>\n              \n              <div className=\"date-picker-days\">\n                {days.map((date, index) => {\n                  const isCurrentMonth = date.getMonth() === viewDate.getMonth();\n                  const isSelected = currentValue && isSameDay(date, currentValue);\n                  const isToday = isSameDay(date, today);\n                  const isDisabled = isDateDisabled(date);\n                  \n                  return (\n                    <button\n                      key={index}\n                      type=\"button\"\n                      className={`date-picker-day ${\n                        !isCurrentMonth ? \"date-picker-day-other-month\" : \"\"\n                      } ${isSelected ? \"date-picker-day-selected\" : \"\"} ${\n                        isToday ? \"date-picker-day-today\" : \"\"\n                      } ${isDisabled ? \"date-picker-day-disabled\" : \"\"}`}\n                      onClick={() => handleDateClick(date)}\n                      disabled={isDisabled}\n                      aria-label={formatDate(date, \"MM/DD/YYYY\")}\n                      aria-selected={isSelected}\n                    >\n                      {date.getDate()}\n                    </button>\n                  );\n                })}\n              </div>\n            </div>\n\n            {showToday && (\n              <div className=\"date-picker-footer\">\n                <button\n                  type=\"button\"\n                  className=\"date-picker-today-button\"\n                  onClick={handleTodayClick}\n                  disabled={isDateDisabled(today)}\n                >\n                  Today\n                </button>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  }\n);\nDatePicker.displayName = \"DatePicker\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { DatePicker } from \"../DatePicker\";\n\ntest(\"renders date picker input\", () => {\n  render(<DatePicker />);\n  expect(screen.getByLabelText(\"Date input\")).toBeInTheDocument();\n  expect(screen.getByLabelText(\"Open calendar\")).toBeInTheDocument();\n});\n\ntest(\"shows placeholder when no value\", () => {\n  render(<DatePicker placeholder=\"Choose a date\" />);\n  expect(screen.getByPlaceholderText(\"Choose a date\")).toBeInTheDocument();\n});\n\ntest(\"opens calendar on input focus\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker />);\n  \n  await user.click(screen.getByLabelText(\"Date input\"));\n  expect(screen.getByRole(\"dialog\", { name: /date picker/i })).toBeInTheDocument();\n});\n\ntest(\"opens calendar on calendar icon click\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n});\n\ntest(\"displays current month and year\", async () => {\n  const user = userEvent.setup();\n  const testDate = new Date(2024, 5, 15); // June 2024\n  render(<DatePicker defaultValue={testDate} />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n});\n\ntest(\"navigates between months\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker defaultValue={new Date(2024, 5, 15)} />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  await user.click(screen.getByLabelText(\"Next month\"));\n  expect(screen.getByText(\"July 2024\")).toBeInTheDocument();\n  \n  await user.click(screen.getByLabelText(\"Previous month\"));\n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n});\n\ntest(\"navigates between years\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker defaultValue={new Date(2024, 5, 15)} />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  await user.click(screen.getByLabelText(\"Next year\"));\n  expect(screen.getByText(\"June 2025\")).toBeInTheDocument();\n  \n  await user.click(screen.getByLabelText(\"Previous year\"));\n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n});\n\ntest(\"selects date on day click\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker onChange={onChange} />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  const dayButton = screen.getByLabelText(/06\\/15\\/\\d{4}/);\n  await user.click(dayButton);\n  \n  expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n});\n\ntest(\"shows selected date\", async () => {\n  const user = userEvent.setup();\n  const selectedDate = new Date(2024, 5, 15);\n  render(<DatePicker value={selectedDate} />);\n  \n  expect(screen.getByDisplayValue(\"06/15/2024\")).toBeInTheDocument();\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  const selectedDay = screen.getByLabelText(\"06/15/2024\");\n  expect(selectedDay).toHaveAttribute(\"aria-selected\", \"true\");\n});\n\ntest(\"handles today button\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker onChange={onChange} showToday />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  await user.click(screen.getByText(\"Today\"));\n  \n  expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n});\n\ntest(\"handles clear button\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker value={new Date(2024, 5, 15)} onChange={onChange} clearable />);\n  \n  await user.click(screen.getByLabelText(\"Clear date\"));\n  expect(onChange).toHaveBeenCalledWith(null);\n});\n\ntest(\"parses manual date input\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker onChange={onChange} />);\n  \n  const input = screen.getByLabelText(\"Date input\");\n  await user.clear(input);\n  await user.type(input, \"06/15/2024\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n});\n\ntest(\"respects min and max dates\", async () => {\n  const user = userEvent.setup();\n  const minDate = new Date(2024, 5, 10);\n  const maxDate = new Date(2024, 5, 20);\n  \n  render(\n    <DatePicker \n      defaultValue={new Date(2024, 5, 15)}\n      minDate={minDate}\n      maxDate={maxDate}\n    />\n  );\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  const disabledDay = screen.getByLabelText(\"06/05/2024\");\n  expect(disabledDay).toBeDisabled();\n});\n\ntest(\"handles custom disabled dates\", async () => {\n  const user = userEvent.setup();\n  const disabledDates = (date: Date) => date.getDay() === 0; // Disable Sundays\n  \n  render(\n    <DatePicker \n      defaultValue={new Date(2024, 5, 15)}\n      disabledDates={disabledDates}\n    />\n  );\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  // Find a Sunday and check if it's disabled\n  const sunday = screen.getByLabelText(\"06/02/2024\");\n  expect(sunday).toBeDisabled();\n});\n\ntest(\"closes on escape key\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker />);\n  \n  const input = screen.getByLabelText(\"Date input\");\n  await user.click(input);\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n  \n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker disabled onChange={onChange} />);\n  \n  const input = screen.getByLabelText(\"Date input\");\n  const calendarButton = screen.getByLabelText(\"Open calendar\");\n  \n  expect(input).toBeDisabled();\n  expect(calendarButton).toBeDisabled();\n  \n  await user.click(input);\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"is read-only when readOnly prop is true\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker readOnly />);\n  \n  const input = screen.getByLabelText(\"Date input\");\n  expect(input).toHaveAttribute(\"readonly\");\n  \n  await user.click(input);\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<DatePicker size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"date-picker-lg\");\n});\n\ntest(\"formats date according to format prop\", () => {\n  const date = new Date(2024, 5, 15);\n  render(<DatePicker value={date} format=\"DD/MM/YYYY\" />);\n  expect(screen.getByDisplayValue(\"15/06/2024\")).toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  const date = new Date(2024, 5, 15);\n  render(<DatePicker value={date} onChange={onChange} />);\n  \n  expect(screen.getByDisplayValue(\"06/15/2024\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface DatePickerProps extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n  value?: Date;\n  defaultValue?: Date;\n  onChange?: (date: Date | null) => void;\n  format?: string;\n  placeholder?: string;\n  disabled?: boolean;\n  readOnly?: boolean;\n  clearable?: boolean;\n  showToday?: boolean;\n  minDate?: Date;\n  maxDate?: Date;\n  disabledDates?: (date: Date) => boolean;\n  size?: \"sm\" | \"md\" | \"lg\";\n  placement?: \"top\" | \"bottom\" | \"left\" | \"right\";\n}\n\nconst monthNames = [\n  \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n  \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n];\n\nconst dayNames = [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"];\n\nconst classesBySize: Record<NonNullable<DatePickerProps[\"size\"]>, string> = {\n  sm: \"date-picker-sm\",\n  md: \"date-picker-md\",\n  lg: \"date-picker-lg\",\n};\n\nexport const DatePicker = React.forwardRef<HTMLDivElement, DatePickerProps>(\n  ({\n    value: controlledValue,\n    defaultValue,\n    onChange,\n    format = \"MM/DD/YYYY\",\n    placeholder = \"Select date\",\n    disabled = false,\n    readOnly = false,\n    clearable = true,\n    showToday = true,\n    minDate,\n    maxDate,\n    disabledDates,\n    size = \"md\",\n    placement = \"bottom\",\n    className,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState<Date | null>(defaultValue || null);\n    const [isOpen, setIsOpen] = React.useState(false);\n    const [viewDate, setViewDate] = React.useState(() => \n      controlledValue || defaultValue || new Date()\n    );\n    const [inputValue, setInputValue] = React.useState(\"\");\n    \n    const containerRef = React.useRef<HTMLDivElement>(null);\n    const inputRef = React.useRef<HTMLInputElement>(null);\n    const combinedRef = React.useMemo(() => ref || containerRef, [ref]);\n\n    const isControlled = controlledValue !== undefined;\n    const currentValue = isControlled ? controlledValue : internalValue;\n\n    React.useEffect(() => {\n      if (currentValue) {\n        setInputValue(formatDate(currentValue, format));\n      } else {\n        setInputValue(\"\");\n      }\n    }, [currentValue, format]);\n\n    const formatDate = (date: Date, formatStr: string): string => {\n      const day = date.getDate().toString().padStart(2, \"0\");\n      const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n      const year = date.getFullYear().toString();\n      \n      return formatStr\n        .replace(\"DD\", day)\n        .replace(\"MM\", month)\n        .replace(\"YYYY\", year)\n        .replace(\"YY\", year.slice(-2));\n    };\n\n    const parseDate = (dateStr: string): Date | null => {\n      const cleanStr = dateStr.replace(/[^\\d]/g, \"\");\n      if (cleanStr.length !== 8) return null;\n      \n      const month = parseInt(cleanStr.slice(0, 2), 10);\n      const day = parseInt(cleanStr.slice(2, 4), 10);\n      const year = parseInt(cleanStr.slice(4, 8), 10);\n      \n      if (month < 1 || month > 12 || day < 1 || day > 31) return null;\n      \n      const date = new Date(year, month - 1, day);\n      if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {\n        return null;\n      }\n      \n      return date;\n    };\n\n    const updateValue = (newValue: Date | null) => {\n      if (onChange) {\n        onChange(newValue);\n      }\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n    };\n\n    const isDateDisabled = (date: Date): boolean => {\n      if (minDate && date < minDate) return true;\n      if (maxDate && date > maxDate) return true;\n      if (disabledDates && disabledDates(date)) return true;\n      return false;\n    };\n\n    const isSameDay = (date1: Date, date2: Date): boolean => {\n      return date1.getDate() === date2.getDate() &&\n             date1.getMonth() === date2.getMonth() &&\n             date1.getFullYear() === date2.getFullYear();\n    };\n\n    const getDaysInMonth = (date: Date): Date[] => {\n      const year = date.getFullYear();\n      const month = date.getMonth();\n      const firstDay = new Date(year, month, 1);\n      const lastDay = new Date(year, month + 1, 0);\n      const startDate = new Date(firstDay);\n      \n      const startDay = firstDay.getDay();\n      startDate.setDate(startDate.getDate() - startDay);\n      \n      const days: Date[] = [];\n      const endDate = new Date(startDate);\n      endDate.setDate(endDate.getDate() + 41); // 6 weeks\n      \n      for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {\n        days.push(new Date(d));\n      }\n      \n      return days;\n    };\n\n    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n      const value = e.target.value;\n      setInputValue(value);\n      \n      const parsedDate = parseDate(value);\n      if (parsedDate && !isDateDisabled(parsedDate)) {\n        updateValue(parsedDate);\n        setViewDate(parsedDate);\n      }\n    };\n\n    const handleInputKeyDown = (e: React.KeyboardEvent) => {\n      if (e.key === \"Enter\") {\n        const parsedDate = parseDate(inputValue);\n        if (parsedDate && !isDateDisabled(parsedDate)) {\n          updateValue(parsedDate);\n          setIsOpen(false);\n        }\n      }\n      if (e.key === \"Escape\") {\n        setInputValue(currentValue ? formatDate(currentValue, format) : \"\");\n        setIsOpen(false);\n      }\n      if (e.key === \"ArrowDown\" && !isOpen) {\n        setIsOpen(true);\n      }\n    };\n\n    const handleDateClick = (date: Date) => {\n      if (!isDateDisabled(date)) {\n        updateValue(date);\n        setIsOpen(false);\n        inputRef.current?.focus();\n      }\n    };\n\n    const handleClear = () => {\n      updateValue(null);\n      setInputValue(\"\");\n      inputRef.current?.focus();\n    };\n\n    const handleTodayClick = () => {\n      const today = new Date();\n      if (!isDateDisabled(today)) {\n        updateValue(today);\n        setViewDate(today);\n        setIsOpen(false);\n      }\n    };\n\n    const navigateMonth = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setMonth(newDate.getMonth() + direction);\n      setViewDate(newDate);\n    };\n\n    const navigateYear = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setFullYear(newDate.getFullYear() + direction);\n      setViewDate(newDate);\n    };\n\n    React.useEffect(() => {\n      const handleClickOutside = (event: MouseEvent) => {\n        if (\n          isOpen &&\n          combinedRef &&\n          \"current\" in combinedRef &&\n          combinedRef.current &&\n          !combinedRef.current.contains(event.target as Node)\n        ) {\n          setIsOpen(false);\n        }\n      };\n\n      document.addEventListener(\"mousedown\", handleClickOutside);\n      return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n    }, [isOpen, combinedRef]);\n\n    const classes = `date-picker ${classesBySize[size]} ${\n      disabled ? \"date-picker-disabled\" : \"\"\n    } ${isOpen ? \"date-picker-open\" : \"\"} ${className || \"\"}`.trim();\n\n    const today = new Date();\n    const days = getDaysInMonth(viewDate);\n\n    return (\n      <div {...rest} ref={combinedRef} className={classes}>\n        <div className=\"date-picker-input-wrapper\">\n          <input\n            ref={inputRef}\n            type=\"text\"\n            className=\"date-picker-input\"\n            value={inputValue}\n            onChange={handleInputChange}\n            onKeyDown={handleInputKeyDown}\n            onFocus={() => !disabled && !readOnly && setIsOpen(true)}\n            placeholder={placeholder}\n            disabled={disabled}\n            readOnly={readOnly}\n            aria-label=\"Date input\"\n            aria-expanded={isOpen}\n            aria-haspopup=\"dialog\"\n          />\n          \n          <div className=\"date-picker-suffix\">\n            {clearable && currentValue && !disabled && (\n              <button\n                type=\"button\"\n                className=\"date-picker-clear\"\n                onClick={handleClear}\n                aria-label=\"Clear date\"\n                tabIndex={-1}\n              >\n                ×\n              </button>\n            )}\n            <button\n              type=\"button\"\n              className=\"date-picker-calendar-icon\"\n              onClick={() => !disabled && setIsOpen(!isOpen)}\n              aria-label=\"Open calendar\"\n              disabled={disabled}\n              tabIndex={-1}\n            >\n              📅\n            </button>\n          </div>\n        </div>\n\n        {isOpen && (\n          <div\n            className={`date-picker-panel date-picker-panel-${placement}`}\n            role=\"dialog\"\n            aria-label=\"Date picker\"\n          >\n            <div className=\"date-picker-header\">\n              <div className=\"date-picker-nav\">\n                <button\n                  type=\"button\"\n                  className=\"date-picker-nav-button\"\n                  onClick={() => navigateYear(-1)}\n                  aria-label=\"Previous year\"\n                >\n                  «\n                </button>\n                <button\n                  type=\"button\"\n                  className=\"date-picker-nav-button\"\n                  onClick={() => navigateMonth(-1)}\n                  aria-label=\"Previous month\"\n                >\n                  ‹\n                </button>\n              </div>\n              \n              <div className=\"date-picker-month-year\">\n                {monthNames[viewDate.getMonth()]} {viewDate.getFullYear()}\n              </div>\n              \n              <div className=\"date-picker-nav\">\n                <button\n                  type=\"button\"\n                  className=\"date-picker-nav-button\"\n                  onClick={() => navigateMonth(1)}\n                  aria-label=\"Next month\"\n                >\n                  ›\n                </button>\n                <button\n                  type=\"button\"\n                  className=\"date-picker-nav-button\"\n                  onClick={() => navigateYear(1)}\n                  aria-label=\"Next year\"\n                >\n                  »\n                </button>\n              </div>\n            </div>\n\n            <div className=\"date-picker-calendar\">\n              <div className=\"date-picker-weekdays\">\n                {dayNames.map(day => (\n                  <div key={day} className=\"date-picker-weekday\">\n                    {day}\n                  </div>\n                ))}\n              </div>\n              \n              <div className=\"date-picker-days\">\n                {days.map((date, index) => {\n                  const isCurrentMonth = date.getMonth() === viewDate.getMonth();\n                  const isSelected = currentValue && isSameDay(date, currentValue);\n                  const isToday = isSameDay(date, today);\n                  const isDisabled = isDateDisabled(date);\n                  \n                  return (\n                    <button\n                      key={index}\n                      type=\"button\"\n                      className={`date-picker-day ${\n                        !isCurrentMonth ? \"date-picker-day-other-month\" : \"\"\n                      } ${isSelected ? \"date-picker-day-selected\" : \"\"} ${\n                        isToday ? \"date-picker-day-today\" : \"\"\n                      } ${isDisabled ? \"date-picker-day-disabled\" : \"\"}`}\n                      onClick={() => handleDateClick(date)}\n                      disabled={isDisabled}\n                      aria-label={formatDate(date, \"MM/DD/YYYY\")}\n                      aria-selected={isSelected}\n                    >\n                      {date.getDate()}\n                    </button>\n                  );\n                })}\n              </div>\n            </div>\n\n            {showToday && (\n              <div className=\"date-picker-footer\">\n                <button\n                  type=\"button\"\n                  className=\"date-picker-today-button\"\n                  onClick={handleTodayClick}\n                  disabled={isDateDisabled(today)}\n                >\n                  Today\n                </button>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  }\n);\nDatePicker.displayName = \"DatePicker\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { DatePicker } from \"../DatePicker\";\n\ntest(\"renders date picker input\", () => {\n  render(<DatePicker />);\n  expect(screen.getByLabelText(\"Date input\")).toBeInTheDocument();\n  expect(screen.getByLabelText(\"Open calendar\")).toBeInTheDocument();\n});\n\ntest(\"shows placeholder when no value\", () => {\n  render(<DatePicker placeholder=\"Choose a date\" />);\n  expect(screen.getByPlaceholderText(\"Choose a date\")).toBeInTheDocument();\n});\n\ntest(\"opens calendar on input focus\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker />);\n  \n  await user.click(screen.getByLabelText(\"Date input\"));\n  expect(screen.getByRole(\"dialog\", { name: /date picker/i })).toBeInTheDocument();\n});\n\ntest(\"opens calendar on calendar icon click\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n});\n\ntest(\"displays current month and year\", async () => {\n  const user = userEvent.setup();\n  const testDate = new Date(2024, 5, 15); // June 2024\n  render(<DatePicker defaultValue={testDate} />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n});\n\ntest(\"navigates between months\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker defaultValue={new Date(2024, 5, 15)} />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  await user.click(screen.getByLabelText(\"Next month\"));\n  expect(screen.getByText(\"July 2024\")).toBeInTheDocument();\n  \n  await user.click(screen.getByLabelText(\"Previous month\"));\n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n});\n\ntest(\"navigates between years\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker defaultValue={new Date(2024, 5, 15)} />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  await user.click(screen.getByLabelText(\"Next year\"));\n  expect(screen.getByText(\"June 2025\")).toBeInTheDocument();\n  \n  await user.click(screen.getByLabelText(\"Previous year\"));\n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n});\n\ntest(\"selects date on day click\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker onChange={onChange} />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  const dayButton = screen.getByLabelText(/06\\/15\\/\\d{4}/);\n  await user.click(dayButton);\n  \n  expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n});\n\ntest(\"shows selected date\", async () => {\n  const user = userEvent.setup();\n  const selectedDate = new Date(2024, 5, 15);\n  render(<DatePicker value={selectedDate} />);\n  \n  expect(screen.getByDisplayValue(\"06/15/2024\")).toBeInTheDocument();\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  const selectedDay = screen.getByLabelText(\"06/15/2024\");\n  expect(selectedDay).toHaveAttribute(\"aria-selected\", \"true\");\n});\n\ntest(\"handles today button\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker onChange={onChange} showToday />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  await user.click(screen.getByText(\"Today\"));\n  \n  expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n});\n\ntest(\"handles clear button\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker value={new Date(2024, 5, 15)} onChange={onChange} clearable />);\n  \n  await user.click(screen.getByLabelText(\"Clear date\"));\n  expect(onChange).toHaveBeenCalledWith(null);\n});\n\ntest(\"parses manual date input\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker onChange={onChange} />);\n  \n  const input = screen.getByLabelText(\"Date input\");\n  await user.clear(input);\n  await user.type(input, \"06/15/2024\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n});\n\ntest(\"respects min and max dates\", async () => {\n  const user = userEvent.setup();\n  const minDate = new Date(2024, 5, 10);\n  const maxDate = new Date(2024, 5, 20);\n  \n  render(\n    <DatePicker \n      defaultValue={new Date(2024, 5, 15)}\n      minDate={minDate}\n      maxDate={maxDate}\n    />\n  );\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  const disabledDay = screen.getByLabelText(\"06/05/2024\");\n  expect(disabledDay).toBeDisabled();\n});\n\ntest(\"handles custom disabled dates\", async () => {\n  const user = userEvent.setup();\n  const disabledDates = (date: Date) => date.getDay() === 0; // Disable Sundays\n  \n  render(\n    <DatePicker \n      defaultValue={new Date(2024, 5, 15)}\n      disabledDates={disabledDates}\n    />\n  );\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  // Find a Sunday and check if it's disabled\n  const sunday = screen.getByLabelText(\"06/02/2024\");\n  expect(sunday).toBeDisabled();\n});\n\ntest(\"closes on escape key\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker />);\n  \n  const input = screen.getByLabelText(\"Date input\");\n  await user.click(input);\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n  \n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker disabled onChange={onChange} />);\n  \n  const input = screen.getByLabelText(\"Date input\");\n  const calendarButton = screen.getByLabelText(\"Open calendar\");\n  \n  expect(input).toBeDisabled();\n  expect(calendarButton).toBeDisabled();\n  \n  await user.click(input);\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"is read-only when readOnly prop is true\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker readOnly />);\n  \n  const input = screen.getByLabelText(\"Date input\");\n  expect(input).toHaveAttribute(\"readonly\");\n  \n  await user.click(input);\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<DatePicker size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"date-picker-lg\");\n});\n\ntest(\"formats date according to format prop\", () => {\n  const date = new Date(2024, 5, 15);\n  render(<DatePicker value={date} format=\"DD/MM/YYYY\" />);\n  expect(screen.getByDisplayValue(\"15/06/2024\")).toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  const date = new Date(2024, 5, 15);\n  render(<DatePicker value={date} onChange={onChange} />);\n  \n  expect(screen.getByDisplayValue(\"06/15/2024\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface DatePickerProps extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n  value?: Date;\n  defaultValue?: Date;\n  onChange?: (date: Date | null) => void;\n  format?: string;\n  placeholder?: string;\n  disabled?: boolean;\n  readOnly?: boolean;\n  clearable?: boolean;\n  showToday?: boolean;\n  minDate?: Date;\n  maxDate?: Date;\n  disabledDates?: (date: Date) => boolean;\n  size?: \"sm\" | \"md\" | \"lg\";\n  placement?: \"top\" | \"bottom\" | \"left\" | \"right\";\n}\n\nconst monthNames = [\n  \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n  \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n];\n\nconst dayNames = [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"];\n\nconst classesBySize: Record<NonNullable<DatePickerProps[\"size\"]>, string> = {\n  sm: \"date-picker-sm\",\n  md: \"date-picker-md\",\n  lg: \"date-picker-lg\",\n};\n\nexport const DatePicker = React.forwardRef<HTMLDivElement, DatePickerProps>(\n  ({\n    value: controlledValue,\n    defaultValue,\n    onChange,\n    format = \"MM/DD/YYYY\",\n    placeholder = \"Select date\",\n    disabled = false,\n    readOnly = false,\n    clearable = true,\n    showToday = true,\n    minDate,\n    maxDate,\n    disabledDates,\n    size = \"md\",\n    placement = \"bottom\",\n    className,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState<Date | null>(defaultValue || null);\n    const [isOpen, setIsOpen] = React.useState(false);\n    const [viewDate, setViewDate] = React.useState(() => \n      controlledValue || defaultValue || new Date()\n    );\n    const [inputValue, setInputValue] = React.useState(\"\");\n    \n    const containerRef = React.useRef<HTMLDivElement>(null);\n    const inputRef = React.useRef<HTMLInputElement>(null);\n    const combinedRef = React.useMemo(() => ref || containerRef, [ref]);\n\n    const isControlled = controlledValue !== undefined;\n    const currentValue = isControlled ? controlledValue : internalValue;\n\n    React.useEffect(() => {\n      if (currentValue) {\n        setInputValue(formatDate(currentValue, format));\n      } else {\n        setInputValue(\"\");\n      }\n    }, [currentValue, format]);\n\n    const formatDate = (date: Date, formatStr: string): string => {\n      const day = date.getDate().toString().padStart(2, \"0\");\n      const month = (date.getMonth() + 1).toString().padStart(2, \"0\");\n      const year = date.getFullYear().toString();\n      \n      return formatStr\n        .replace(\"DD\", day)\n        .replace(\"MM\", month)\n        .replace(\"YYYY\", year)\n        .replace(\"YY\", year.slice(-2));\n    };\n\n    const parseDate = (dateStr: string): Date | null => {\n      const cleanStr = dateStr.replace(/[^\\d]/g, \"\");\n      if (cleanStr.length !== 8) return null;\n      \n      const month = parseInt(cleanStr.slice(0, 2), 10);\n      const day = parseInt(cleanStr.slice(2, 4), 10);\n      const year = parseInt(cleanStr.slice(4, 8), 10);\n      \n      if (month < 1 || month > 12 || day < 1 || day > 31) return null;\n      \n      const date = new Date(year, month - 1, day);\n      if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {\n        return null;\n      }\n      \n      return date;\n    };\n\n    const updateValue = (newValue: Date | null) => {\n      if (onChange) {\n        onChange(newValue);\n      }\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n    };\n\n    const isDateDisabled = (date: Date): boolean => {\n      if (minDate && date < minDate) return true;\n      if (maxDate && date > maxDate) return true;\n      if (disabledDates && disabledDates(date)) return true;\n      return false;\n    };\n\n    const isSameDay = (date1: Date, date2: Date): boolean => {\n      return date1.getDate() === date2.getDate() &&\n             date1.getMonth() === date2.getMonth() &&\n             date1.getFullYear() === date2.getFullYear();\n    };\n\n    const getDaysInMonth = (date: Date): Date[] => {\n      const year = date.getFullYear();\n      const month = date.getMonth();\n      const firstDay = new Date(year, month, 1);\n      const lastDay = new Date(year, month + 1, 0);\n      const startDate = new Date(firstDay);\n      \n      const startDay = firstDay.getDay();\n      startDate.setDate(startDate.getDate() - startDay);\n      \n      const days: Date[] = [];\n      const endDate = new Date(startDate);\n      endDate.setDate(endDate.getDate() + 41); // 6 weeks\n      \n      for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {\n        days.push(new Date(d));\n      }\n      \n      return days;\n    };\n\n    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n      const value = e.target.value;\n      setInputValue(value);\n      \n      const parsedDate = parseDate(value);\n      if (parsedDate && !isDateDisabled(parsedDate)) {\n        updateValue(parsedDate);\n        setViewDate(parsedDate);\n      }\n    };\n\n    const handleInputKeyDown = (e: React.KeyboardEvent) => {\n      if (e.key === \"Enter\") {\n        const parsedDate = parseDate(inputValue);\n        if (parsedDate && !isDateDisabled(parsedDate)) {\n          updateValue(parsedDate);\n          setIsOpen(false);\n        }\n      }\n      if (e.key === \"Escape\") {\n        setInputValue(currentValue ? formatDate(currentValue, format) : \"\");\n        setIsOpen(false);\n      }\n      if (e.key === \"ArrowDown\" && !isOpen) {\n        setIsOpen(true);\n      }\n    };\n\n    const handleDateClick = (date: Date) => {\n      if (!isDateDisabled(date)) {\n        updateValue(date);\n        setIsOpen(false);\n        inputRef.current?.focus();\n      }\n    };\n\n    const handleClear = () => {\n      updateValue(null);\n      setInputValue(\"\");\n      inputRef.current?.focus();\n    };\n\n    const handleTodayClick = () => {\n      const today = new Date();\n      if (!isDateDisabled(today)) {\n        updateValue(today);\n        setViewDate(today);\n        setIsOpen(false);\n      }\n    };\n\n    const navigateMonth = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setMonth(newDate.getMonth() + direction);\n      setViewDate(newDate);\n    };\n\n    const navigateYear = (direction: number) => {\n      const newDate = new Date(viewDate);\n      newDate.setFullYear(newDate.getFullYear() + direction);\n      setViewDate(newDate);\n    };\n\n    React.useEffect(() => {\n      const handleClickOutside = (event: MouseEvent) => {\n        if (\n          isOpen &&\n          combinedRef &&\n          \"current\" in combinedRef &&\n          combinedRef.current &&\n          !combinedRef.current.contains(event.target as Node)\n        ) {\n          setIsOpen(false);\n        }\n      };\n\n      document.addEventListener(\"mousedown\", handleClickOutside);\n      return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n    }, [isOpen, combinedRef]);\n\n    const classes = `date-picker ${classesBySize[size]} ${\n      disabled ? \"date-picker-disabled\" : \"\"\n    } ${isOpen ? \"date-picker-open\" : \"\"} ${className || \"\"}`.trim();\n\n    const today = new Date();\n    const days = getDaysInMonth(viewDate);\n\n    return (\n      <div {...rest} ref={combinedRef} className={classes}>\n        <div className=\"date-picker-input-wrapper\">\n          <input\n            ref={inputRef}\n            type=\"text\"\n            className=\"date-picker-input\"\n            value={inputValue}\n            onChange={handleInputChange}\n            onKeyDown={handleInputKeyDown}\n            onFocus={() => !disabled && !readOnly && setIsOpen(true)}\n            placeholder={placeholder}\n            disabled={disabled}\n            readOnly={readOnly}\n            aria-label=\"Date input\"\n            aria-expanded={isOpen}\n            aria-haspopup=\"dialog\"\n          />\n          \n          <div className=\"date-picker-suffix\">\n            {clearable && currentValue && !disabled && (\n              <button\n                type=\"button\"\n                className=\"date-picker-clear\"\n                onClick={handleClear}\n                aria-label=\"Clear date\"\n                tabIndex={-1}\n              >\n                ×\n              </button>\n            )}\n            <button\n              type=\"button\"\n              className=\"date-picker-calendar-icon\"\n              onClick={() => !disabled && setIsOpen(!isOpen)}\n              aria-label=\"Open calendar\"\n              disabled={disabled}\n              tabIndex={-1}\n            >\n              📅\n            </button>\n          </div>\n        </div>\n\n        {isOpen && (\n          <div\n            className={`date-picker-panel date-picker-panel-${placement}`}\n            role=\"dialog\"\n            aria-label=\"Date picker\"\n          >\n            <div className=\"date-picker-header\">\n              <div className=\"date-picker-nav\">\n                <button\n                  type=\"button\"\n                  className=\"date-picker-nav-button\"\n                  onClick={() => navigateYear(-1)}\n                  aria-label=\"Previous year\"\n                >\n                  «\n                </button>\n                <button\n                  type=\"button\"\n                  className=\"date-picker-nav-button\"\n                  onClick={() => navigateMonth(-1)}\n                  aria-label=\"Previous month\"\n                >\n                  ‹\n                </button>\n              </div>\n              \n              <div className=\"date-picker-month-year\">\n                {monthNames[viewDate.getMonth()]} {viewDate.getFullYear()}\n              </div>\n              \n              <div className=\"date-picker-nav\">\n                <button\n                  type=\"button\"\n                  className=\"date-picker-nav-button\"\n                  onClick={() => navigateMonth(1)}\n                  aria-label=\"Next month\"\n                >\n                  ›\n                </button>\n                <button\n                  type=\"button\"\n                  className=\"date-picker-nav-button\"\n                  onClick={() => navigateYear(1)}\n                  aria-label=\"Next year\"\n                >\n                  »\n                </button>\n              </div>\n            </div>\n\n            <div className=\"date-picker-calendar\">\n              <div className=\"date-picker-weekdays\">\n                {dayNames.map(day => (\n                  <div key={day} className=\"date-picker-weekday\">\n                    {day}\n                  </div>\n                ))}\n              </div>\n              \n              <div className=\"date-picker-days\">\n                {days.map((date, index) => {\n                  const isCurrentMonth = date.getMonth() === viewDate.getMonth();\n                  const isSelected = currentValue && isSameDay(date, currentValue);\n                  const isToday = isSameDay(date, today);\n                  const isDisabled = isDateDisabled(date);\n                  \n                  return (\n                    <button\n                      key={index}\n                      type=\"button\"\n                      className={`date-picker-day ${\n                        !isCurrentMonth ? \"date-picker-day-other-month\" : \"\"\n                      } ${isSelected ? \"date-picker-day-selected\" : \"\"} ${\n                        isToday ? \"date-picker-day-today\" : \"\"\n                      } ${isDisabled ? \"date-picker-day-disabled\" : \"\"}`}\n                      onClick={() => handleDateClick(date)}\n                      disabled={isDisabled}\n                      aria-label={formatDate(date, \"MM/DD/YYYY\")}\n                      aria-selected={isSelected}\n                    >\n                      {date.getDate()}\n                    </button>\n                  );\n                })}\n              </div>\n            </div>\n\n            {showToday && (\n              <div className=\"date-picker-footer\">\n                <button\n                  type=\"button\"\n                  className=\"date-picker-today-button\"\n                  onClick={handleTodayClick}\n                  disabled={isDateDisabled(today)}\n                >\n                  Today\n                </button>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  }\n);\nDatePicker.displayName = \"DatePicker\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { DatePicker } from \"../DatePicker\";\n\ntest(\"renders date picker input\", () => {\n  render(<DatePicker />);\n  expect(screen.getByLabelText(\"Date input\")).toBeInTheDocument();\n  expect(screen.getByLabelText(\"Open calendar\")).toBeInTheDocument();\n});\n\ntest(\"shows placeholder when no value\", () => {\n  render(<DatePicker placeholder=\"Choose a date\" />);\n  expect(screen.getByPlaceholderText(\"Choose a date\")).toBeInTheDocument();\n});\n\ntest(\"opens calendar on input focus\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker />);\n  \n  await user.click(screen.getByLabelText(\"Date input\"));\n  expect(screen.getByRole(\"dialog\", { name: /date picker/i })).toBeInTheDocument();\n});\n\ntest(\"opens calendar on calendar icon click\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n});\n\ntest(\"displays current month and year\", async () => {\n  const user = userEvent.setup();\n  const testDate = new Date(2024, 5, 15); // June 2024\n  render(<DatePicker defaultValue={testDate} />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n});\n\ntest(\"navigates between months\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker defaultValue={new Date(2024, 5, 15)} />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  await user.click(screen.getByLabelText(\"Next month\"));\n  expect(screen.getByText(\"July 2024\")).toBeInTheDocument();\n  \n  await user.click(screen.getByLabelText(\"Previous month\"));\n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n});\n\ntest(\"navigates between years\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker defaultValue={new Date(2024, 5, 15)} />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  await user.click(screen.getByLabelText(\"Next year\"));\n  expect(screen.getByText(\"June 2025\")).toBeInTheDocument();\n  \n  await user.click(screen.getByLabelText(\"Previous year\"));\n  expect(screen.getByText(\"June 2024\")).toBeInTheDocument();\n});\n\ntest(\"selects date on day click\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker onChange={onChange} />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  const dayButton = screen.getByLabelText(/06\\/15\\/\\d{4}/);\n  await user.click(dayButton);\n  \n  expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n});\n\ntest(\"shows selected date\", async () => {\n  const user = userEvent.setup();\n  const selectedDate = new Date(2024, 5, 15);\n  render(<DatePicker value={selectedDate} />);\n  \n  expect(screen.getByDisplayValue(\"06/15/2024\")).toBeInTheDocument();\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  const selectedDay = screen.getByLabelText(\"06/15/2024\");\n  expect(selectedDay).toHaveAttribute(\"aria-selected\", \"true\");\n});\n\ntest(\"handles today button\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker onChange={onChange} showToday />);\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  await user.click(screen.getByText(\"Today\"));\n  \n  expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n});\n\ntest(\"handles clear button\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker value={new Date(2024, 5, 15)} onChange={onChange} clearable />);\n  \n  await user.click(screen.getByLabelText(\"Clear date\"));\n  expect(onChange).toHaveBeenCalledWith(null);\n});\n\ntest(\"parses manual date input\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker onChange={onChange} />);\n  \n  const input = screen.getByLabelText(\"Date input\");\n  await user.clear(input);\n  await user.type(input, \"06/15/2024\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onChange).toHaveBeenCalledWith(expect.any(Date));\n});\n\ntest(\"respects min and max dates\", async () => {\n  const user = userEvent.setup();\n  const minDate = new Date(2024, 5, 10);\n  const maxDate = new Date(2024, 5, 20);\n  \n  render(\n    <DatePicker \n      defaultValue={new Date(2024, 5, 15)}\n      minDate={minDate}\n      maxDate={maxDate}\n    />\n  );\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  const disabledDay = screen.getByLabelText(\"06/05/2024\");\n  expect(disabledDay).toBeDisabled();\n});\n\ntest(\"handles custom disabled dates\", async () => {\n  const user = userEvent.setup();\n  const disabledDates = (date: Date) => date.getDay() === 0; // Disable Sundays\n  \n  render(\n    <DatePicker \n      defaultValue={new Date(2024, 5, 15)}\n      disabledDates={disabledDates}\n    />\n  );\n  \n  await user.click(screen.getByLabelText(\"Open calendar\"));\n  \n  // Find a Sunday and check if it's disabled\n  const sunday = screen.getByLabelText(\"06/02/2024\");\n  expect(sunday).toBeDisabled();\n});\n\ntest(\"closes on escape key\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker />);\n  \n  const input = screen.getByLabelText(\"Date input\");\n  await user.click(input);\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n  \n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<DatePicker disabled onChange={onChange} />);\n  \n  const input = screen.getByLabelText(\"Date input\");\n  const calendarButton = screen.getByLabelText(\"Open calendar\");\n  \n  expect(input).toBeDisabled();\n  expect(calendarButton).toBeDisabled();\n  \n  await user.click(input);\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"is read-only when readOnly prop is true\", async () => {\n  const user = userEvent.setup();\n  render(<DatePicker readOnly />);\n  \n  const input = screen.getByLabelText(\"Date input\");\n  expect(input).toHaveAttribute(\"readonly\");\n  \n  await user.click(input);\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<DatePicker size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"date-picker-lg\");\n});\n\ntest(\"formats date according to format prop\", () => {\n  const date = new Date(2024, 5, 15);\n  render(<DatePicker value={date} format=\"DD/MM/YYYY\" />);\n  expect(screen.getByDisplayValue(\"15/06/2024\")).toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  const date = new Date(2024, 5, 15);\n  render(<DatePicker value={date} onChange={onChange} />);\n  \n  expect(screen.getByDisplayValue(\"06/15/2024\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface DialogProps {\n  isOpen: boolean;\n  onClose: () => void;\n  title?: string;\n  children: React.ReactNode;\n}\n\nexport const Dialog = React.forwardRef<HTMLDivElement, DialogProps>(\n  ({ isOpen, onClose, title, children }, ref) => {\n    if (!isOpen) return null;\n\n    return (\n      <div className=\"dialog-overlay\">\n        <div ref={ref} className=\"dialog\" role=\"dialog\">\n          {title && (\n            <div className=\"dialog-header\">\n              <h2>{title}</h2>\n              <button onClick={onClose} aria-label=\"Close dialog\">\n                ×\n              </button>\n            </div>\n          )}\n          <div className=\"dialog-content\">\n            {children}\n          </div>\n        </div>\n      </div>\n    );\n  }\n);\nDialog.displayName = \"Dialog\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Dialog } from \"../Dialog\";\n\ntest(\"renders when open\", () => {\n  render(\n    <Dialog isOpen={true} onClose={() => { }}>\n      <p>Dialog content</p>\n    </Dialog>\n  );\n  expect(screen.getByText(\"Dialog content\")).toBeInTheDocument();\n});\n\ntest(\"does not render when closed\", () => {\n  render(\n    <Dialog isOpen={false} onClose={() => { }}>\n      <p>Dialog content</p>\n    </Dialog>\n  );\n  expect(screen.queryByText(\"Dialog content\")).not.toBeInTheDocument();\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface DialogProps {\n  isOpen: boolean;\n  onClose: () => void;\n  title?: string;\n  children: React.ReactNode;\n}\n\nexport const Dialog = React.forwardRef<HTMLDivElement, DialogProps>(\n  ({ isOpen, onClose, title, children }, ref) => {\n    if (!isOpen) return null;\n\n    return (\n      <div className=\"dialog-overlay\">\n        <div ref={ref} className=\"dialog\" role=\"dialog\">\n          {title && (\n            <div className=\"dialog-header\">\n              <h2>{title}</h2>\n              <button onClick={onClose} aria-label=\"Close dialog\">\n                ×\n              </button>\n            </div>\n          )}\n          <div className=\"dialog-content\">\n            {children}\n          </div>\n        </div>\n      </div>\n    );\n  }\n);\nDialog.displayName = \"Dialog\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Dialog } from \"../Dialog\";\n\ntest(\"renders when open\", () => {\n  render(\n    <Dialog isOpen={true} onClose={() => { }}>\n      <p>Dialog content</p>\n    </Dialog>\n  );\n  expect(screen.getByText(\"Dialog content\")).toBeInTheDocument();\n});\n\ntest(\"does not render when closed\", () => {\n  render(\n    <Dialog isOpen={false} onClose={() => { }}>\n      <p>Dialog content</p>\n    </Dialog>\n  );\n  expect(screen.queryByText(\"Dialog content\")).not.toBeInTheDocument();\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface DialogProps {\n  isOpen: boolean;\n  onClose: () => void;\n  title?: string;\n  children: React.ReactNode;\n}\n\nexport const Dialog = React.forwardRef<HTMLDivElement, DialogProps>(\n  ({ isOpen, onClose, title, children }, ref) => {\n    if (!isOpen) return null;\n\n    return (\n      <div className=\"dialog-overlay\">\n        <div ref={ref} className=\"dialog\" role=\"dialog\">\n          {title && (\n            <div className=\"dialog-header\">\n              <h2>{title}</h2>\n              <button onClick={onClose} aria-label=\"Close dialog\">\n                ×\n              </button>\n            </div>\n          )}\n          <div className=\"dialog-content\">\n            {children}\n          </div>\n        </div>\n      </div>\n    );\n  }\n);\nDialog.displayName = \"Dialog\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Dialog } from \"../Dialog\";\n\ntest(\"renders when open\", () => {\n  render(\n    <Dialog isOpen={true} onClose={() => { }}>\n      <p>Dialog content</p>\n    </Dialog>\n  );\n  expect(screen.getByText(\"Dialog content\")).toBeInTheDocument();\n});\n\ntest(\"does not render when closed\", () => {\n  render(\n    <Dialog isOpen={false} onClose={() => { }}>\n      <p>Dialog content</p>\n    </Dialog>\n  );\n  expect(screen.queryByText(\"Dialog content\")).not.toBeInTheDocument();\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface DividerProps extends React.HTMLAttributes<HTMLHRElement> {\n  label?: string;\n}\n\nexport const Divider = React.forwardRef<HTMLHRElement, DividerProps>(\n  ({ label, className, ...rest }, ref) => {\n    const classes = [\"divider\", className].filter(Boolean).join(\" \");\n\n    if (label) {\n      return (\n        <div className=\"divider-with-label\">\n          <hr {...rest} ref={ref} className={classes} />\n          <span className=\"divider-label\">{label}</span>\n        </div>\n      );\n    }\n\n    return (\n      <hr\n        {...rest}\n        ref={ref}\n        className={classes}\n      />\n    );\n  }\n);\nDivider.displayName = \"Divider\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Divider } from \"../Divider\";\n\ntest(\"renders divider\", () => {\n  const { container } = render(<Divider />);\n  expect(container.querySelector('hr')).toBeInTheDocument();\n});\n\ntest(\"renders with label\", () => {\n  render(<Divider label=\"OR\" />);\n  expect(screen.getByText(\"OR\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface DividerProps extends React.HTMLAttributes<HTMLHRElement> {\n  label?: string;\n}\n\nexport const Divider = React.forwardRef<HTMLHRElement, DividerProps>(\n  ({ label, className, ...rest }, ref) => {\n    const classes = [\"divider\", className].filter(Boolean).join(\" \");\n\n    if (label) {\n      return (\n        <div className=\"divider-with-label\">\n          <hr {...rest} ref={ref} className={classes} />\n          <span className=\"divider-label\">{label}</span>\n        </div>\n      );\n    }\n\n    return (\n      <hr\n        {...rest}\n        ref={ref}\n        className={classes}\n      />\n    );\n  }\n);\nDivider.displayName = \"Divider\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Divider } from \"../Divider\";\n\ntest(\"renders divider\", () => {\n  const { container } = render(<Divider />);\n  expect(container.querySelector('hr')).toBeInTheDocument();\n});\n\ntest(\"renders with label\", () => {\n  render(<Divider label=\"OR\" />);\n  expect(screen.getByText(\"OR\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface DividerProps extends React.HTMLAttributes<HTMLHRElement> {\n  label?: string;\n}\n\nexport const Divider = React.forwardRef<HTMLHRElement, DividerProps>(\n  ({ label, className, ...rest }, ref) => {\n    const classes = [\"divider\", className].filter(Boolean).join(\" \");\n\n    if (label) {\n      return (\n        <div className=\"divider-with-label\">\n          <hr {...rest} ref={ref} className={classes} />\n          <span className=\"divider-label\">{label}</span>\n        </div>\n      );\n    }\n\n    return (\n      <hr\n        {...rest}\n        ref={ref}\n        className={classes}\n      />\n    );\n  }\n);\nDivider.displayName = \"Divider\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Divider } from \"../Divider\";\n\ntest(\"renders divider\", () => {\n  const { container } = render(<Divider />);\n  expect(container.querySelector('hr')).toBeInTheDocument();\n});\n\ntest(\"renders with label\", () => {\n  render(<Divider label=\"OR\" />);\n  expect(screen.getByText(\"OR\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface DrawerProps extends React.HTMLAttributes<HTMLDivElement> {\n    open: boolean;\n    onClose: () => void;\n    placement?: \"left\" | \"right\" | \"top\" | \"bottom\";\n    size?: \"sm\" | \"md\" | \"lg\" | \"xl\" | \"full\";\n    closable?: boolean;\n    maskClosable?: boolean;\n    showMask?: boolean;\n    title?: string;\n    footer?: React.ReactNode;\n    children: React.ReactNode;\n}\n\nconst classesByPlacement: Record<NonNullable<DrawerProps[\"placement\"]>, string> = {\n    left: \"drawer-left\",\n    right: \"drawer-right\",\n    top: \"drawer-top\",\n    bottom: \"drawer-bottom\",\n};\n\nconst classesBySize: Record<NonNullable<DrawerProps[\"size\"]>, string> = {\n    sm: \"drawer-sm\",\n    md: \"drawer-md\",\n    lg: \"drawer-lg\",\n    xl: \"drawer-xl\",\n    full: \"drawer-full\",\n};\n\nexport const Drawer = React.forwardRef<HTMLDivElement, DrawerProps>(\n    ({\n        open,\n        onClose,\n        placement = \"right\",\n        size = \"md\",\n        closable = true,\n        maskClosable = true,\n        showMask = true,\n        title,\n        footer,\n        children,\n        className,\n        ...rest\n    }, ref) => {\n        const drawerId = React.useId();\n\n        // Handle ESC key\n        React.useEffect(() => {\n            const handleEscKey = (e: KeyboardEvent) => {\n                if (e.key === \"Escape\" && open && closable) {\n                    onClose();\n                }\n            };\n\n            if (open) {\n                document.addEventListener(\"keydown\", handleEscKey);\n                // Prevent body scroll when drawer is open\n                document.body.style.overflow = \"hidden\";\n            }\n\n            return () => {\n                document.removeEventListener(\"keydown\", handleEscKey);\n                document.body.style.overflow = \"\";\n            };\n        }, [open, closable, onClose]);\n\n        // Focus management\n        React.useEffect(() => {\n            if (open) {\n                const drawerElement = document.getElementById(drawerId);\n                if (drawerElement) {\n                    drawerElement.focus();\n                }\n            }\n        }, [open, drawerId]);\n\n        const handleMaskClick = (e: React.MouseEvent) => {\n            if (e.target === e.currentTarget && maskClosable) {\n                onClose();\n            }\n        };\n\n        const classes = `drawer ${classesByPlacement[placement]} ${classesBySize[size]} ${open ? \"drawer-open\" : \"drawer-closed\"\n            } ${className || \"\"}`.trim();\n\n        if (!open) {\n            return null;\n        }\n\n        return (\n            <div\n                className=\"drawer-wrapper\"\n                role=\"dialog\"\n                aria-modal=\"true\"\n                aria-labelledby={title ? `${drawerId}-title` : undefined}\n            >\n                {showMask && (\n                    <div\n                        className=\"drawer-mask\"\n                        onClick={handleMaskClick}\n                        aria-hidden=\"true\"\n                    />\n                )}\n\n                <div\n                    {...rest}\n                    ref={ref}\n                    id={drawerId}\n                    className={classes}\n                    tabIndex={-1}\n                    role=\"dialog\"\n                    aria-modal=\"true\"\n                >\n                    {(title || closable) && (\n                        <div className=\"drawer-header\">\n                            {title && (\n                                <h2 id={`${drawerId}-title`} className=\"drawer-title\">\n                                    {title}\n                                </h2>\n                            )}\n                            {closable && (\n                                <button\n                                    type=\"button\"\n                                    className=\"drawer-close\"\n                                    onClick={onClose}\n                                    aria-label=\"Close drawer\"\n                                >\n                                    ×\n                                </button>\n                            )}\n                        </div>\n                    )}\n\n                    <div className=\"drawer-body\">\n                        {children}\n                    </div>\n\n                    {footer && (\n                        <div className=\"drawer-footer\">\n                            {footer}\n                        </div>\n                    )}\n                </div>\n            </div>\n        );\n    }\n);\nDrawer.displayName = \"Drawer\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Drawer } from \"../Drawer\";\n\ntest(\"renders drawer when open\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose}>\n            <div>Drawer content</div>\n        </Drawer>\n    );\n\n    expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n    expect(screen.getByText(\"Drawer content\")).toBeInTheDocument();\n});\n\ntest(\"does not render drawer when closed\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open={false} onClose={onClose}>\n            <div>Drawer content</div>\n        </Drawer>\n    );\n\n    expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"shows title when provided\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} title=\"Drawer Title\">\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(screen.getByText(\"Drawer Title\")).toBeInTheDocument();\n});\n\ntest(\"shows close button when closable\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} closable>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(screen.getByLabelText(\"Close drawer\")).toBeInTheDocument();\n});\n\ntest(\"calls onClose when close button clicked\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} closable>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    await user.click(screen.getByLabelText(\"Close drawer\"));\n    expect(onClose).toHaveBeenCalledTimes(1);\n});\n\ntest(\"calls onClose when ESC key pressed\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} closable>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    await user.keyboard(\"{Escape}\");\n    expect(onClose).toHaveBeenCalledTimes(1);\n});\n\ntest(\"calls onClose when mask clicked and maskClosable is true\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} maskClosable>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    const mask = document.querySelector(\".drawer-mask\");\n    if (mask) {\n        await user.click(mask);\n        expect(onClose).toHaveBeenCalledTimes(1);\n    }\n});\n\ntest(\"does not call onClose when mask clicked and maskClosable is false\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} maskClosable={false}>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    const mask = document.querySelector(\".drawer-mask\");\n    if (mask) {\n        await user.click(mask);\n        expect(onClose).not.toHaveBeenCalled();\n    }\n});\n\ntest(\"does not show mask when showMask is false\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} showMask={false}>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(document.querySelector(\".drawer-mask\")).not.toBeInTheDocument();\n});\n\ntest(\"applies placement classes\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} placement=\"left\">\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(document.querySelector(\".drawer\")).toHaveClass(\"drawer-left\");\n});\n\ntest(\"applies size classes\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} size=\"lg\">\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(document.querySelector(\".drawer\")).toHaveClass(\"drawer-lg\");\n});\n\ntest(\"renders footer when provided\", () => {\n    const onClose = vi.fn();\n    const footer = <button>Action</button>;\n\n    render(\n        <Drawer open onClose={onClose} footer={footer}>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(screen.getByText(\"Action\")).toBeInTheDocument();\n    expect(document.querySelector(\".drawer-footer\")).toBeInTheDocument();\n});\n\ntest(\"has proper accessibility attributes\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} title=\"Test Drawer\">\n            <div>Content</div>\n        </Drawer>\n    );\n\n    const dialog = screen.getByRole(\"dialog\");\n    expect(dialog).toHaveAttribute(\"aria-modal\", \"true\");\n    expect(dialog).toHaveAttribute(\"aria-labelledby\");\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface DrawerProps extends React.HTMLAttributes<HTMLDivElement> {\n    open: boolean;\n    onClose: () => void;\n    placement?: \"left\" | \"right\" | \"top\" | \"bottom\";\n    size?: \"sm\" | \"md\" | \"lg\" | \"xl\" | \"full\";\n    closable?: boolean;\n    maskClosable?: boolean;\n    showMask?: boolean;\n    title?: string;\n    footer?: React.ReactNode;\n    children: React.ReactNode;\n}\n\nconst classesByPlacement: Record<NonNullable<DrawerProps[\"placement\"]>, string> = {\n    left: \"drawer-left\",\n    right: \"drawer-right\",\n    top: \"drawer-top\",\n    bottom: \"drawer-bottom\",\n};\n\nconst classesBySize: Record<NonNullable<DrawerProps[\"size\"]>, string> = {\n    sm: \"drawer-sm\",\n    md: \"drawer-md\",\n    lg: \"drawer-lg\",\n    xl: \"drawer-xl\",\n    full: \"drawer-full\",\n};\n\nexport const Drawer = React.forwardRef<HTMLDivElement, DrawerProps>(\n    ({\n        open,\n        onClose,\n        placement = \"right\",\n        size = \"md\",\n        closable = true,\n        maskClosable = true,\n        showMask = true,\n        title,\n        footer,\n        children,\n        className,\n        ...rest\n    }, ref) => {\n        const drawerId = React.useId();\n\n        // Handle ESC key\n        React.useEffect(() => {\n            const handleEscKey = (e: KeyboardEvent) => {\n                if (e.key === \"Escape\" && open && closable) {\n                    onClose();\n                }\n            };\n\n            if (open) {\n                document.addEventListener(\"keydown\", handleEscKey);\n                // Prevent body scroll when drawer is open\n                document.body.style.overflow = \"hidden\";\n            }\n\n            return () => {\n                document.removeEventListener(\"keydown\", handleEscKey);\n                document.body.style.overflow = \"\";\n            };\n        }, [open, closable, onClose]);\n\n        // Focus management\n        React.useEffect(() => {\n            if (open) {\n                const drawerElement = document.getElementById(drawerId);\n                if (drawerElement) {\n                    drawerElement.focus();\n                }\n            }\n        }, [open, drawerId]);\n\n        const handleMaskClick = (e: React.MouseEvent) => {\n            if (e.target === e.currentTarget && maskClosable) {\n                onClose();\n            }\n        };\n\n        const classes = `drawer ${classesByPlacement[placement]} ${classesBySize[size]} ${open ? \"drawer-open\" : \"drawer-closed\"\n            } ${className || \"\"}`.trim();\n\n        if (!open) {\n            return null;\n        }\n\n        return (\n            <div\n                className=\"drawer-wrapper\"\n                role=\"dialog\"\n                aria-modal=\"true\"\n                aria-labelledby={title ? `${drawerId}-title` : undefined}\n            >\n                {showMask && (\n                    <div\n                        className=\"drawer-mask\"\n                        onClick={handleMaskClick}\n                        aria-hidden=\"true\"\n                    />\n                )}\n\n                <div\n                    {...rest}\n                    ref={ref}\n                    id={drawerId}\n                    className={classes}\n                    tabIndex={-1}\n                    role=\"dialog\"\n                    aria-modal=\"true\"\n                >\n                    {(title || closable) && (\n                        <div className=\"drawer-header\">\n                            {title && (\n                                <h2 id={`${drawerId}-title`} className=\"drawer-title\">\n                                    {title}\n                                </h2>\n                            )}\n                            {closable && (\n                                <button\n                                    type=\"button\"\n                                    className=\"drawer-close\"\n                                    onClick={onClose}\n                                    aria-label=\"Close drawer\"\n                                >\n                                    ×\n                                </button>\n                            )}\n                        </div>\n                    )}\n\n                    <div className=\"drawer-body\">\n                        {children}\n                    </div>\n\n                    {footer && (\n                        <div className=\"drawer-footer\">\n                            {footer}\n                        </div>\n                    )}\n                </div>\n            </div>\n        );\n    }\n);\nDrawer.displayName = \"Drawer\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Drawer } from \"../Drawer\";\n\ntest(\"renders drawer when open\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose}>\n            <div>Drawer content</div>\n        </Drawer>\n    );\n\n    expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n    expect(screen.getByText(\"Drawer content\")).toBeInTheDocument();\n});\n\ntest(\"does not render drawer when closed\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open={false} onClose={onClose}>\n            <div>Drawer content</div>\n        </Drawer>\n    );\n\n    expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"shows title when provided\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} title=\"Drawer Title\">\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(screen.getByText(\"Drawer Title\")).toBeInTheDocument();\n});\n\ntest(\"shows close button when closable\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} closable>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(screen.getByLabelText(\"Close drawer\")).toBeInTheDocument();\n});\n\ntest(\"calls onClose when close button clicked\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} closable>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    await user.click(screen.getByLabelText(\"Close drawer\"));\n    expect(onClose).toHaveBeenCalledTimes(1);\n});\n\ntest(\"calls onClose when ESC key pressed\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} closable>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    await user.keyboard(\"{Escape}\");\n    expect(onClose).toHaveBeenCalledTimes(1);\n});\n\ntest(\"calls onClose when mask clicked and maskClosable is true\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} maskClosable>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    const mask = document.querySelector(\".drawer-mask\");\n    if (mask) {\n        await user.click(mask);\n        expect(onClose).toHaveBeenCalledTimes(1);\n    }\n});\n\ntest(\"does not call onClose when mask clicked and maskClosable is false\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} maskClosable={false}>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    const mask = document.querySelector(\".drawer-mask\");\n    if (mask) {\n        await user.click(mask);\n        expect(onClose).not.toHaveBeenCalled();\n    }\n});\n\ntest(\"does not show mask when showMask is false\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} showMask={false}>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(document.querySelector(\".drawer-mask\")).not.toBeInTheDocument();\n});\n\ntest(\"applies placement classes\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} placement=\"left\">\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(document.querySelector(\".drawer\")).toHaveClass(\"drawer-left\");\n});\n\ntest(\"applies size classes\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} size=\"lg\">\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(document.querySelector(\".drawer\")).toHaveClass(\"drawer-lg\");\n});\n\ntest(\"renders footer when provided\", () => {\n    const onClose = vi.fn();\n    const footer = <button>Action</button>;\n\n    render(\n        <Drawer open onClose={onClose} footer={footer}>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(screen.getByText(\"Action\")).toBeInTheDocument();\n    expect(document.querySelector(\".drawer-footer\")).toBeInTheDocument();\n});\n\ntest(\"has proper accessibility attributes\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} title=\"Test Drawer\">\n            <div>Content</div>\n        </Drawer>\n    );\n\n    const dialog = screen.getByRole(\"dialog\");\n    expect(dialog).toHaveAttribute(\"aria-modal\", \"true\");\n    expect(dialog).toHaveAttribute(\"aria-labelledby\");\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface DrawerProps extends React.HTMLAttributes<HTMLDivElement> {\n    open: boolean;\n    onClose: () => void;\n    placement?: \"left\" | \"right\" | \"top\" | \"bottom\";\n    size?: \"sm\" | \"md\" | \"lg\" | \"xl\" | \"full\";\n    closable?: boolean;\n    maskClosable?: boolean;\n    showMask?: boolean;\n    title?: string;\n    footer?: React.ReactNode;\n    children: React.ReactNode;\n}\n\nconst classesByPlacement: Record<NonNullable<DrawerProps[\"placement\"]>, string> = {\n    left: \"drawer-left\",\n    right: \"drawer-right\",\n    top: \"drawer-top\",\n    bottom: \"drawer-bottom\",\n};\n\nconst classesBySize: Record<NonNullable<DrawerProps[\"size\"]>, string> = {\n    sm: \"drawer-sm\",\n    md: \"drawer-md\",\n    lg: \"drawer-lg\",\n    xl: \"drawer-xl\",\n    full: \"drawer-full\",\n};\n\nexport const Drawer = React.forwardRef<HTMLDivElement, DrawerProps>(\n    ({\n        open,\n        onClose,\n        placement = \"right\",\n        size = \"md\",\n        closable = true,\n        maskClosable = true,\n        showMask = true,\n        title,\n        footer,\n        children,\n        className,\n        ...rest\n    }, ref) => {\n        const drawerId = React.useId();\n\n        // Handle ESC key\n        React.useEffect(() => {\n            const handleEscKey = (e: KeyboardEvent) => {\n                if (e.key === \"Escape\" && open && closable) {\n                    onClose();\n                }\n            };\n\n            if (open) {\n                document.addEventListener(\"keydown\", handleEscKey);\n                // Prevent body scroll when drawer is open\n                document.body.style.overflow = \"hidden\";\n            }\n\n            return () => {\n                document.removeEventListener(\"keydown\", handleEscKey);\n                document.body.style.overflow = \"\";\n            };\n        }, [open, closable, onClose]);\n\n        // Focus management\n        React.useEffect(() => {\n            if (open) {\n                const drawerElement = document.getElementById(drawerId);\n                if (drawerElement) {\n                    drawerElement.focus();\n                }\n            }\n        }, [open, drawerId]);\n\n        const handleMaskClick = (e: React.MouseEvent) => {\n            if (e.target === e.currentTarget && maskClosable) {\n                onClose();\n            }\n        };\n\n        const classes = `drawer ${classesByPlacement[placement]} ${classesBySize[size]} ${open ? \"drawer-open\" : \"drawer-closed\"\n            } ${className || \"\"}`.trim();\n\n        if (!open) {\n            return null;\n        }\n\n        return (\n            <div\n                className=\"drawer-wrapper\"\n                role=\"dialog\"\n                aria-modal=\"true\"\n                aria-labelledby={title ? `${drawerId}-title` : undefined}\n            >\n                {showMask && (\n                    <div\n                        className=\"drawer-mask\"\n                        onClick={handleMaskClick}\n                        aria-hidden=\"true\"\n                    />\n                )}\n\n                <div\n                    {...rest}\n                    ref={ref}\n                    id={drawerId}\n                    className={classes}\n                    tabIndex={-1}\n                    role=\"dialog\"\n                    aria-modal=\"true\"\n                >\n                    {(title || closable) && (\n                        <div className=\"drawer-header\">\n                            {title && (\n                                <h2 id={`${drawerId}-title`} className=\"drawer-title\">\n                                    {title}\n                                </h2>\n                            )}\n                            {closable && (\n                                <button\n                                    type=\"button\"\n                                    className=\"drawer-close\"\n                                    onClick={onClose}\n                                    aria-label=\"Close drawer\"\n                                >\n                                    ×\n                                </button>\n                            )}\n                        </div>\n                    )}\n\n                    <div className=\"drawer-body\">\n                        {children}\n                    </div>\n\n                    {footer && (\n                        <div className=\"drawer-footer\">\n                            {footer}\n                        </div>\n                    )}\n                </div>\n            </div>\n        );\n    }\n);\nDrawer.displayName = \"Drawer\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Drawer } from \"../Drawer\";\n\ntest(\"renders drawer when open\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose}>\n            <div>Drawer content</div>\n        </Drawer>\n    );\n\n    expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n    expect(screen.getByText(\"Drawer content\")).toBeInTheDocument();\n});\n\ntest(\"does not render drawer when closed\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open={false} onClose={onClose}>\n            <div>Drawer content</div>\n        </Drawer>\n    );\n\n    expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"shows title when provided\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} title=\"Drawer Title\">\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(screen.getByText(\"Drawer Title\")).toBeInTheDocument();\n});\n\ntest(\"shows close button when closable\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} closable>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(screen.getByLabelText(\"Close drawer\")).toBeInTheDocument();\n});\n\ntest(\"calls onClose when close button clicked\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} closable>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    await user.click(screen.getByLabelText(\"Close drawer\"));\n    expect(onClose).toHaveBeenCalledTimes(1);\n});\n\ntest(\"calls onClose when ESC key pressed\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} closable>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    await user.keyboard(\"{Escape}\");\n    expect(onClose).toHaveBeenCalledTimes(1);\n});\n\ntest(\"calls onClose when mask clicked and maskClosable is true\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} maskClosable>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    const mask = document.querySelector(\".drawer-mask\");\n    if (mask) {\n        await user.click(mask);\n        expect(onClose).toHaveBeenCalledTimes(1);\n    }\n});\n\ntest(\"does not call onClose when mask clicked and maskClosable is false\", async () => {\n    const user = userEvent.setup();\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} maskClosable={false}>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    const mask = document.querySelector(\".drawer-mask\");\n    if (mask) {\n        await user.click(mask);\n        expect(onClose).not.toHaveBeenCalled();\n    }\n});\n\ntest(\"does not show mask when showMask is false\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} showMask={false}>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(document.querySelector(\".drawer-mask\")).not.toBeInTheDocument();\n});\n\ntest(\"applies placement classes\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} placement=\"left\">\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(document.querySelector(\".drawer\")).toHaveClass(\"drawer-left\");\n});\n\ntest(\"applies size classes\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} size=\"lg\">\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(document.querySelector(\".drawer\")).toHaveClass(\"drawer-lg\");\n});\n\ntest(\"renders footer when provided\", () => {\n    const onClose = vi.fn();\n    const footer = <button>Action</button>;\n\n    render(\n        <Drawer open onClose={onClose} footer={footer}>\n            <div>Content</div>\n        </Drawer>\n    );\n\n    expect(screen.getByText(\"Action\")).toBeInTheDocument();\n    expect(document.querySelector(\".drawer-footer\")).toBeInTheDocument();\n});\n\ntest(\"has proper accessibility attributes\", () => {\n    const onClose = vi.fn();\n    render(\n        <Drawer open onClose={onClose} title=\"Test Drawer\">\n            <div>Content</div>\n        </Drawer>\n    );\n\n    const dialog = screen.getByRole(\"dialog\");\n    expect(dialog).toHaveAttribute(\"aria-modal\", \"true\");\n    expect(dialog).toHaveAttribute(\"aria-labelledby\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface DropdownOption {\n  value: string;\n  label: string;\n  disabled?: boolean;\n}\n\nexport interface DropdownProps extends Omit<React.SelectHTMLAttributes<HTMLSelectElement>, 'onChange'> {\n  options: DropdownOption[];\n  placeholder?: string;\n  onChange?: (value: string) => void;\n}\n\nexport const Dropdown = React.forwardRef<HTMLSelectElement, DropdownProps>(\n  ({ options, placeholder, onChange, className, ...rest }, ref) => {\n    const handleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n      onChange?.(e.target.value);\n    };\n\n    return (\n      <select\n        {...rest}\n        ref={ref}\n        className={[\"dropdown\", className].filter(Boolean).join(\" \")}\n        onChange={handleChange}\n      >\n        {placeholder && (\n          <option value=\"\" disabled>\n            {placeholder}\n          </option>\n        )}\n        {options.map((option) => (\n          <option\n            key={option.value}\n            value={option.value}\n            disabled={option.disabled}\n          >\n            {option.label}\n          </option>\n        ))}\n      </select>\n    );\n  }\n);\nDropdown.displayName = \"Dropdown\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Dropdown } from \"../Dropdown\";\n\nconst mockOptions = [\n  { value: \"option1\", label: \"Option 1\" },\n  { value: \"option2\", label: \"Option 2\" }\n];\n\ntest(\"renders with options\", () => {\n  render(<Dropdown options={mockOptions} />);\n  expect(screen.getByRole(\"combobox\")).toBeInTheDocument();\n  expect(screen.getByRole(\"option\", { name: \"Option 1\" })).toBeInTheDocument();\n});\n\ntest(\"calls onChange when selection changes\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Dropdown options={mockOptions} onChange={onChange} />);\n\n  await user.selectOptions(screen.getByRole(\"combobox\"), \"option1\");\n  expect(onChange).toHaveBeenCalledWith(\"option1\");\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface DropdownOption {\n  value: string;\n  label: string;\n  disabled?: boolean;\n}\n\nexport interface DropdownProps extends Omit<React.SelectHTMLAttributes<HTMLSelectElement>, 'onChange'> {\n  options: DropdownOption[];\n  placeholder?: string;\n  onChange?: (value: string) => void;\n}\n\nexport const Dropdown = React.forwardRef<HTMLSelectElement, DropdownProps>(\n  ({ options, placeholder, onChange, className, ...rest }, ref) => {\n    const handleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n      onChange?.(e.target.value);\n    };\n\n    return (\n      <select\n        {...rest}\n        ref={ref}\n        className={[\"dropdown\", className].filter(Boolean).join(\" \")}\n        onChange={handleChange}\n      >\n        {placeholder && (\n          <option value=\"\" disabled>\n            {placeholder}\n          </option>\n        )}\n        {options.map((option) => (\n          <option\n            key={option.value}\n            value={option.value}\n            disabled={option.disabled}\n          >\n            {option.label}\n          </option>\n        ))}\n      </select>\n    );\n  }\n);\nDropdown.displayName = \"Dropdown\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Dropdown } from \"../Dropdown\";\n\nconst mockOptions = [\n  { value: \"option1\", label: \"Option 1\" },\n  { value: \"option2\", label: \"Option 2\" }\n];\n\ntest(\"renders with options\", () => {\n  render(<Dropdown options={mockOptions} />);\n  expect(screen.getByRole(\"combobox\")).toBeInTheDocument();\n  expect(screen.getByRole(\"option\", { name: \"Option 1\" })).toBeInTheDocument();\n});\n\ntest(\"calls onChange when selection changes\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Dropdown options={mockOptions} onChange={onChange} />);\n\n  await user.selectOptions(screen.getByRole(\"combobox\"), \"option1\");\n  expect(onChange).toHaveBeenCalledWith(\"option1\");\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface DropdownOption {\n  value: string;\n  label: string;\n  disabled?: boolean;\n}\n\nexport interface DropdownProps extends Omit<React.SelectHTMLAttributes<HTMLSelectElement>, 'onChange'> {\n  options: DropdownOption[];\n  placeholder?: string;\n  onChange?: (value: string) => void;\n}\n\nexport const Dropdown = React.forwardRef<HTMLSelectElement, DropdownProps>(\n  ({ options, placeholder, onChange, className, ...rest }, ref) => {\n    const handleChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\n      onChange?.(e.target.value);\n    };\n\n    return (\n      <select\n        {...rest}\n        ref={ref}\n        className={[\"dropdown\", className].filter(Boolean).join(\" \")}\n        onChange={handleChange}\n      >\n        {placeholder && (\n          <option value=\"\" disabled>\n            {placeholder}\n          </option>\n        )}\n        {options.map((option) => (\n          <option\n            key={option.value}\n            value={option.value}\n            disabled={option.disabled}\n          >\n            {option.label}\n          </option>\n        ))}\n      </select>\n    );\n  }\n);\nDropdown.displayName = \"Dropdown\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Dropdown } from \"../Dropdown\";\n\nconst mockOptions = [\n  { value: \"option1\", label: \"Option 1\" },\n  { value: \"option2\", label: \"Option 2\" }\n];\n\ntest(\"renders with options\", () => {\n  render(<Dropdown options={mockOptions} />);\n  expect(screen.getByRole(\"combobox\")).toBeInTheDocument();\n  expect(screen.getByRole(\"option\", { name: \"Option 1\" })).toBeInTheDocument();\n});\n\ntest(\"calls onChange when selection changes\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Dropdown options={mockOptions} onChange={onChange} />);\n\n  await user.selectOptions(screen.getByRole(\"combobox\"), \"option1\");\n  expect(onChange).toHaveBeenCalledWith(\"option1\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface ImageProps extends React.ImgHTMLAttributes<HTMLImageElement> {\n  src: string;\n  alt: string;\n  fallback?: string | React.ReactNode;\n  placeholder?: string | React.ReactNode;\n  preview?: boolean;\n  previewSrc?: string;\n  lazy?: boolean;\n  objectFit?: \"fill\" | \"contain\" | \"cover\" | \"none\" | \"scale-down\";\n  borderRadius?: string | number;\n  onLoad?: () => void;\n  onError?: () => void;\n  onPreview?: () => void;\n  width?: string | number;\n  height?: string | number;\n  rootMargin?: string;\n  threshold?: number;\n}\n\nexport const Image = React.forwardRef<HTMLImageElement, ImageProps>(\n  ({\n    src,\n    alt,\n    fallback,\n    placeholder,\n    preview = false,\n    previewSrc,\n    lazy = false,\n    objectFit = \"cover\",\n    borderRadius,\n    onLoad,\n    onError,\n    onPreview,\n    width,\n    height,\n    rootMargin = \"50px\",\n    threshold = 0.1,\n    className,\n    style,\n    ...rest\n  }, ref) => {\n    const [imageState, setImageState] = React.useState<\"loading\" | \"loaded\" | \"error\">(\"loading\");\n    const [isVisible, setIsVisible] = React.useState(!lazy);\n    const [showPreview, setShowPreview] = React.useState(false);\n    const imgRef = React.useRef<HTMLImageElement>(null);\n    const combinedRef = React.useMemo(() => ref || imgRef, [ref]);\n\n    // Intersection Observer for lazy loading\n    React.useEffect(() => {\n      if (!lazy || isVisible) return;\n\n      const observer = new IntersectionObserver(\n        ([entry]) => {\n          if (entry.isIntersecting) {\n            setIsVisible(true);\n            observer.disconnect();\n          }\n        },\n        {\n          rootMargin,\n          threshold,\n        }\n      );\n\n      if (combinedRef && \"current\" in combinedRef && combinedRef.current) {\n        observer.observe(combinedRef.current);\n      }\n\n      return () => observer.disconnect();\n    }, [lazy, isVisible, rootMargin, threshold, combinedRef]);\n\n    const handleLoad = () => {\n      setImageState(\"loaded\");\n      if (onLoad) {\n        onLoad();\n      }\n    };\n\n    const handleError = () => {\n      setImageState(\"error\");\n      if (onError) {\n        onError();\n      }\n    };\n\n    const handleImageClick = () => {\n      if (preview) {\n        setShowPreview(true);\n        if (onPreview) {\n          onPreview();\n        }\n      }\n    };\n\n    const handlePreviewClose = () => {\n      setShowPreview(false);\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n      if (preview && (e.key === \"Enter\" || e.key === \" \")) {\n        e.preventDefault();\n        handleImageClick();\n      }\n    };\n\n    const containerStyle: React.CSSProperties = {\n      ...style,\n      width: typeof width === \"number\" ? `${width}px` : width,\n      height: typeof height === \"number\" ? `${height}px` : height,\n      borderRadius: typeof borderRadius === \"number\" ? `${borderRadius}px` : borderRadius,\n      overflow: \"hidden\",\n      position: \"relative\",\n      display: \"inline-block\",\n    };\n\n    const imageStyle: React.CSSProperties = {\n      width: \"100%\",\n      height: \"100%\",\n      objectFit,\n      cursor: preview ? \"pointer\" : \"default\",\n    };\n\n    const classes = `image-container ${preview ? \"image-preview-enabled\" : \"\"} ${\n      imageState === \"loading\" ? \"image-loading\" : \"\"\n    } ${imageState === \"error\" ? \"image-error\" : \"\"} ${className || \"\"}`.trim();\n\n    const renderPlaceholder = () => {\n      if (typeof placeholder === \"string\") {\n        return (\n          <div className=\"image-placeholder\">\n            <div className=\"image-placeholder-content\">{placeholder}</div>\n          </div>\n        );\n      }\n      if (React.isValidElement(placeholder)) {\n        return <div className=\"image-placeholder\">{placeholder}</div>;\n      }\n      return (\n        <div className=\"image-placeholder\">\n          <div className=\"image-placeholder-content\">\n            <div className=\"image-placeholder-icon\">🖼️</div>\n            <div className=\"image-placeholder-text\">Loading...</div>\n          </div>\n        </div>\n      );\n    };\n\n    const renderFallback = () => {\n      if (typeof fallback === \"string\") {\n        return (\n          <div className=\"image-fallback\">\n            <img\n              src={fallback}\n              alt={alt}\n              style={imageStyle}\n              onError={() => {\n                setImageState(\"error\");\n              }}\n            />\n          </div>\n        );\n      }\n      if (React.isValidElement(fallback)) {\n        return <div className=\"image-fallback\">{fallback}</div>;\n      }\n      return (\n        <div className=\"image-fallback\">\n          <div className=\"image-fallback-content\">\n            <div className=\"image-fallback-icon\">❌</div>\n            <div className=\"image-fallback-text\">Failed to load image</div>\n          </div>\n        </div>\n      );\n    };\n\n    const renderPreview = () => {\n      if (!showPreview) return null;\n\n      return (\n        <div\n          className=\"image-preview-overlay\"\n          onClick={handlePreviewClose}\n          onKeyDown={(e) => {\n            if (e.key === \"Escape\") {\n              handlePreviewClose();\n            }\n          }}\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"Image preview\"\n          tabIndex={-1}\n        >\n          <div className=\"image-preview-container\">\n            <button\n              type=\"button\"\n              className=\"image-preview-close\"\n              onClick={handlePreviewClose}\n              aria-label=\"Close preview\"\n            >\n              ×\n            </button>\n            <img\n              src={previewSrc || src}\n              alt={alt}\n              className=\"image-preview-image\"\n              onError={(e) => {\n                if (previewSrc && e.currentTarget.src !== src) {\n                  e.currentTarget.src = src;\n                }\n              }}\n            />\n          </div>\n        </div>\n      );\n    };\n\n    React.useEffect(() => {\n      const handleEscape = (e: KeyboardEvent) => {\n        if (e.key === \"Escape\" && showPreview) {\n          setShowPreview(false);\n        }\n      };\n\n      if (showPreview) {\n        document.addEventListener(\"keydown\", handleEscape);\n        document.body.style.overflow = \"hidden\";\n      }\n\n      return () => {\n        document.removeEventListener(\"keydown\", handleEscape);\n        document.body.style.overflow = \"\";\n      };\n    }, [showPreview]);\n\n    return (\n      <>\n        <div className={classes} style={containerStyle}>\n          {imageState === \"loading\" && renderPlaceholder()}\n          \n          {imageState === \"error\" && renderFallback()}\n          \n          {isVisible && imageState !== \"error\" && (\n            <img\n              {...rest}\n              ref={combinedRef}\n              src={src}\n              alt={alt}\n              style={{\n                ...imageStyle,\n                opacity: imageState === \"loaded\" ? 1 : 0,\n                transition: \"opacity 0.3s ease\",\n              }}\n              onLoad={handleLoad}\n              onError={handleError}\n              onClick={handleImageClick}\n              onKeyDown={handleKeyDown}\n              tabIndex={preview ? 0 : -1}\n              role={preview ? \"button\" : undefined}\n              aria-label={preview ? `Preview ${alt}` : undefined}\n            />\n          )}\n          \n          {preview && imageState === \"loaded\" && (\n            <div className=\"image-preview-indicator\">\n              <div className=\"image-preview-icon\">🔍</div>\n            </div>\n          )}\n        </div>\n        \n        {renderPreview()}\n      </>\n    );\n  }\n);\nImage.displayName = \"Image\";",
    "output": "import { render, screen, fireEvent, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Image } from \"../Image\";\n\nconst mockIntersectionObserver = vi.fn();\nmockIntersectionObserver.mockReturnValue({\n  observe: () => null,\n  unobserve: () => null,\n  disconnect: () => null\n});\nwindow.IntersectionObserver = mockIntersectionObserver;\n\ntest(\"renders image with src and alt\", () => {\n  render(<Image src=\"test.jpg\" alt=\"Test image\" />);\n  \n  const img = screen.getByRole(\"img\");\n  expect(img).toHaveAttribute(\"src\", \"test.jpg\");\n  expect(img).toHaveAttribute(\"alt\", \"Test image\");\n});\n\ntest(\"shows placeholder while loading\", () => {\n  render(<Image src=\"test.jpg\" alt=\"Test image\" placeholder=\"Loading...\" />);\n  \n  expect(screen.getByText(\"🖼️\")).toBeInTheDocument();\n});\n\ntest(\"calls onLoad when image loads successfully\", async () => {\n  const onLoad = vi.fn();\n  render(<Image src=\"test.jpg\" alt=\"Test image\" onLoad={onLoad} />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  expect(onLoad).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows fallback on image error\", async () => {\n  const onError = vi.fn();\n  render(\n    <Image \n      src=\"invalid.jpg\" \n      alt=\"Test image\" \n      fallback=\"fallback.jpg\"\n      onError={onError}\n    />\n  );\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.error(img);\n  \n  expect(onError).toHaveBeenCalledTimes(1);\n  \n  await waitFor(() => {\n    expect(screen.getByText(\"Failed to load image\")).toBeInTheDocument();\n  });\n});\n\ntest(\"shows custom fallback component\", async () => {\n  const CustomFallback = <div>Custom error message</div>;\n  render(\n    <Image \n      src=\"invalid.jpg\" \n      alt=\"Test image\" \n      fallback={CustomFallback}\n    />\n  );\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.error(img);\n  \n  await waitFor(() => {\n    expect(screen.getByText(\"Custom error message\")).toBeInTheDocument();\n  });\n});\n\ntest(\"enables preview mode\", async () => {\n  const user = userEvent.setup();\n  const onPreview = vi.fn();\n  \n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview onPreview={onPreview} />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    expect(screen.getByRole(\"button\", { name: \"Preview Test image\" })).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  \n  expect(onPreview).toHaveBeenCalledTimes(1);\n  expect(screen.getByRole(\"dialog\", { name: \"Image preview\" })).toBeInTheDocument();\n});\n\ntest(\"closes preview on escape key\", async () => {\n  const user = userEvent.setup();\n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n  \n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"closes preview on close button click\", async () => {\n  const user = userEvent.setup();\n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  \n  const closeButton = screen.getByLabelText(\"Close preview\");\n  await user.click(closeButton);\n  \n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"uses custom preview source\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Image \n      src=\"test.jpg\" \n      alt=\"Test image\" \n      preview \n      previewSrc=\"high-res.jpg\"\n    />\n  );\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  \n  const previewImage = screen.getByRole(\"dialog\").querySelector(\"img\");\n  expect(previewImage).toHaveAttribute(\"src\", \"high-res.jpg\");\n});\n\ntest(\"applies custom dimensions\", () => {\n  const { container } = render(\n    <Image src=\"test.jpg\" alt=\"Test image\" width={200} height={150} />\n  );\n  \n  const imageContainer = container.firstChild as HTMLElement;\n  expect(imageContainer).toHaveStyle({\n    width: \"200px\",\n    height: \"150px\"\n  });\n});\n\ntest(\"applies border radius\", () => {\n  const { container } = render(\n    <Image src=\"test.jpg\" alt=\"Test image\" borderRadius={8} />\n  );\n  \n  const imageContainer = container.firstChild as HTMLElement;\n  expect(imageContainer).toHaveStyle({ borderRadius: \"8px\" });\n});\n\ntest(\"applies object fit styles\", () => {\n  render(<Image src=\"test.jpg\" alt=\"Test image\" objectFit=\"contain\" />);\n  \n  const img = screen.getByRole(\"img\");\n  expect(img).toHaveStyle({ objectFit: \"contain\" });\n});\n\ntest(\"supports lazy loading\", () => {\n  const mockObserve = vi.fn();\n  mockIntersectionObserver.mockReturnValue({\n    observe: mockObserve,\n    unobserve: vi.fn(),\n    disconnect: vi.fn()\n  });\n  \n  render(<Image src=\"test.jpg\" alt=\"Test image\" lazy />);\n  \n  expect(mockObserve).toHaveBeenCalled();\n});\n\ntest(\"loads immediately when not lazy\", () => {\n  render(<Image src=\"test.jpg\" alt=\"Test image\" lazy={false} />);\n  \n  const img = screen.getByRole(\"img\");\n  expect(img).toHaveAttribute(\"src\", \"test.jpg\");\n});\n\ntest(\"handles keyboard navigation for preview\", async () => {\n  const user = userEvent.setup();\n  const onPreview = vi.fn();\n  \n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview onPreview={onPreview} />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n  previewButton.focus();\n  \n  await user.keyboard(\"{Enter}\");\n  expect(onPreview).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows custom placeholder component\", () => {\n  const CustomPlaceholder = <div>Custom loading...</div>;\n  render(\n    <Image src=\"test.jpg\" alt=\"Test image\" placeholder={CustomPlaceholder} />\n  );\n  \n  expect(screen.getByText(\"Custom loading...\")).toBeInTheDocument();\n});\n\ntest(\"applies custom className\", () => {\n  const { container } = render(\n    <Image src=\"test.jpg\" alt=\"Test image\" className=\"custom-image\" />\n  );\n  \n  expect(container.firstChild).toHaveClass(\"custom-image\");\n});\n\ntest(\"forwards additional props to img element\", () => {\n  render(\n    <Image \n      src=\"test.jpg\" \n      alt=\"Test image\" \n      data-testid=\"custom-image\"\n      title=\"Custom title\"\n    />\n  );\n  \n  const img = screen.getByTestId(\"custom-image\");\n  expect(img).toHaveAttribute(\"title\", \"Custom title\");\n});\n\ntest(\"handles fallback image error\", async () => {\n  render(\n    <Image \n      src=\"invalid.jpg\" \n      alt=\"Test image\" \n      fallback=\"also-invalid.jpg\"\n    />\n  );\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.error(img);\n  \n  await waitFor(() => {\n    const fallbackImg = screen.getByRole(\"img\");\n    fireEvent.error(fallbackImg);\n  });\n  \n  await waitFor(() => {\n    expect(screen.getByText(\"Failed to load image\")).toBeInTheDocument();\n  });\n});\n\ntest(\"shows preview indicator when preview is enabled and image is loaded\", async () => {\n  const { container } = render(<Image src=\"test.jpg\" alt=\"Test image\" preview />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    expect(container.querySelector(\".image-preview-indicator\")).toBeInTheDocument();\n  });\n});\n\ntest(\"prevents body scroll when preview is open\", async () => {\n  const user = userEvent.setup();\n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  \n  expect(document.body.style.overflow).toBe(\"hidden\");\n  \n  // Close preview\n  await user.keyboard(\"{Escape}\");\n  expect(document.body.style.overflow).toBe(\"\");\n})"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface ImageProps extends React.ImgHTMLAttributes<HTMLImageElement> {\n  src: string;\n  alt: string;\n  fallback?: string | React.ReactNode;\n  placeholder?: string | React.ReactNode;\n  preview?: boolean;\n  previewSrc?: string;\n  lazy?: boolean;\n  objectFit?: \"fill\" | \"contain\" | \"cover\" | \"none\" | \"scale-down\";\n  borderRadius?: string | number;\n  onLoad?: () => void;\n  onError?: () => void;\n  onPreview?: () => void;\n  width?: string | number;\n  height?: string | number;\n  rootMargin?: string;\n  threshold?: number;\n}\n\nexport const Image = React.forwardRef<HTMLImageElement, ImageProps>(\n  ({\n    src,\n    alt,\n    fallback,\n    placeholder,\n    preview = false,\n    previewSrc,\n    lazy = false,\n    objectFit = \"cover\",\n    borderRadius,\n    onLoad,\n    onError,\n    onPreview,\n    width,\n    height,\n    rootMargin = \"50px\",\n    threshold = 0.1,\n    className,\n    style,\n    ...rest\n  }, ref) => {\n    const [imageState, setImageState] = React.useState<\"loading\" | \"loaded\" | \"error\">(\"loading\");\n    const [isVisible, setIsVisible] = React.useState(!lazy);\n    const [showPreview, setShowPreview] = React.useState(false);\n    const imgRef = React.useRef<HTMLImageElement>(null);\n    const combinedRef = React.useMemo(() => ref || imgRef, [ref]);\n\n    // Intersection Observer for lazy loading\n    React.useEffect(() => {\n      if (!lazy || isVisible) return;\n\n      const observer = new IntersectionObserver(\n        ([entry]) => {\n          if (entry.isIntersecting) {\n            setIsVisible(true);\n            observer.disconnect();\n          }\n        },\n        {\n          rootMargin,\n          threshold,\n        }\n      );\n\n      if (combinedRef && \"current\" in combinedRef && combinedRef.current) {\n        observer.observe(combinedRef.current);\n      }\n\n      return () => observer.disconnect();\n    }, [lazy, isVisible, rootMargin, threshold, combinedRef]);\n\n    const handleLoad = () => {\n      setImageState(\"loaded\");\n      if (onLoad) {\n        onLoad();\n      }\n    };\n\n    const handleError = () => {\n      setImageState(\"error\");\n      if (onError) {\n        onError();\n      }\n    };\n\n    const handleImageClick = () => {\n      if (preview) {\n        setShowPreview(true);\n        if (onPreview) {\n          onPreview();\n        }\n      }\n    };\n\n    const handlePreviewClose = () => {\n      setShowPreview(false);\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n      if (preview && (e.key === \"Enter\" || e.key === \" \")) {\n        e.preventDefault();\n        handleImageClick();\n      }\n    };\n\n    const containerStyle: React.CSSProperties = {\n      ...style,\n      width: typeof width === \"number\" ? `${width}px` : width,\n      height: typeof height === \"number\" ? `${height}px` : height,\n      borderRadius: typeof borderRadius === \"number\" ? `${borderRadius}px` : borderRadius,\n      overflow: \"hidden\",\n      position: \"relative\",\n      display: \"inline-block\",\n    };\n\n    const imageStyle: React.CSSProperties = {\n      width: \"100%\",\n      height: \"100%\",\n      objectFit,\n      cursor: preview ? \"pointer\" : \"default\",\n    };\n\n    const classes = `image-container ${preview ? \"image-preview-enabled\" : \"\"} ${\n      imageState === \"loading\" ? \"image-loading\" : \"\"\n    } ${imageState === \"error\" ? \"image-error\" : \"\"} ${className || \"\"}`.trim();\n\n    const renderPlaceholder = () => {\n      if (typeof placeholder === \"string\") {\n        return (\n          <div className=\"image-placeholder\">\n            <div className=\"image-placeholder-content\">{placeholder}</div>\n          </div>\n        );\n      }\n      if (React.isValidElement(placeholder)) {\n        return <div className=\"image-placeholder\">{placeholder}</div>;\n      }\n      return (\n        <div className=\"image-placeholder\">\n          <div className=\"image-placeholder-content\">\n            <div className=\"image-placeholder-icon\">🖼️</div>\n            <div className=\"image-placeholder-text\">Loading...</div>\n          </div>\n        </div>\n      );\n    };\n\n    const renderFallback = () => {\n      if (typeof fallback === \"string\") {\n        return (\n          <div className=\"image-fallback\">\n            <img\n              src={fallback}\n              alt={alt}\n              style={imageStyle}\n              onError={() => {\n                setImageState(\"error\");\n              }}\n            />\n          </div>\n        );\n      }\n      if (React.isValidElement(fallback)) {\n        return <div className=\"image-fallback\">{fallback}</div>;\n      }\n      return (\n        <div className=\"image-fallback\">\n          <div className=\"image-fallback-content\">\n            <div className=\"image-fallback-icon\">❌</div>\n            <div className=\"image-fallback-text\">Failed to load image</div>\n          </div>\n        </div>\n      );\n    };\n\n    const renderPreview = () => {\n      if (!showPreview) return null;\n\n      return (\n        <div\n          className=\"image-preview-overlay\"\n          onClick={handlePreviewClose}\n          onKeyDown={(e) => {\n            if (e.key === \"Escape\") {\n              handlePreviewClose();\n            }\n          }}\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"Image preview\"\n          tabIndex={-1}\n        >\n          <div className=\"image-preview-container\">\n            <button\n              type=\"button\"\n              className=\"image-preview-close\"\n              onClick={handlePreviewClose}\n              aria-label=\"Close preview\"\n            >\n              ×\n            </button>\n            <img\n              src={previewSrc || src}\n              alt={alt}\n              className=\"image-preview-image\"\n              onError={(e) => {\n                if (previewSrc && e.currentTarget.src !== src) {\n                  e.currentTarget.src = src;\n                }\n              }}\n            />\n          </div>\n        </div>\n      );\n    };\n\n    React.useEffect(() => {\n      const handleEscape = (e: KeyboardEvent) => {\n        if (e.key === \"Escape\" && showPreview) {\n          setShowPreview(false);\n        }\n      };\n\n      if (showPreview) {\n        document.addEventListener(\"keydown\", handleEscape);\n        document.body.style.overflow = \"hidden\";\n      }\n\n      return () => {\n        document.removeEventListener(\"keydown\", handleEscape);\n        document.body.style.overflow = \"\";\n      };\n    }, [showPreview]);\n\n    return (\n      <>\n        <div className={classes} style={containerStyle}>\n          {imageState === \"loading\" && renderPlaceholder()}\n          \n          {imageState === \"error\" && renderFallback()}\n          \n          {isVisible && imageState !== \"error\" && (\n            <img\n              {...rest}\n              ref={combinedRef}\n              src={src}\n              alt={alt}\n              style={{\n                ...imageStyle,\n                opacity: imageState === \"loaded\" ? 1 : 0,\n                transition: \"opacity 0.3s ease\",\n              }}\n              onLoad={handleLoad}\n              onError={handleError}\n              onClick={handleImageClick}\n              onKeyDown={handleKeyDown}\n              tabIndex={preview ? 0 : -1}\n              role={preview ? \"button\" : undefined}\n              aria-label={preview ? `Preview ${alt}` : undefined}\n            />\n          )}\n          \n          {preview && imageState === \"loaded\" && (\n            <div className=\"image-preview-indicator\">\n              <div className=\"image-preview-icon\">🔍</div>\n            </div>\n          )}\n        </div>\n        \n        {renderPreview()}\n      </>\n    );\n  }\n);\nImage.displayName = \"Image\";",
    "output": "import { render, screen, fireEvent, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Image } from \"../Image\";\n\nconst mockIntersectionObserver = vi.fn();\nmockIntersectionObserver.mockReturnValue({\n  observe: () => null,\n  unobserve: () => null,\n  disconnect: () => null\n});\nwindow.IntersectionObserver = mockIntersectionObserver;\n\ntest(\"renders image with src and alt\", () => {\n  render(<Image src=\"test.jpg\" alt=\"Test image\" />);\n  \n  const img = screen.getByRole(\"img\");\n  expect(img).toHaveAttribute(\"src\", \"test.jpg\");\n  expect(img).toHaveAttribute(\"alt\", \"Test image\");\n});\n\ntest(\"shows placeholder while loading\", () => {\n  render(<Image src=\"test.jpg\" alt=\"Test image\" placeholder=\"Loading...\" />);\n  \n  expect(screen.getByText(\"🖼️\")).toBeInTheDocument();\n});\n\ntest(\"calls onLoad when image loads successfully\", async () => {\n  const onLoad = vi.fn();\n  render(<Image src=\"test.jpg\" alt=\"Test image\" onLoad={onLoad} />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  expect(onLoad).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows fallback on image error\", async () => {\n  const onError = vi.fn();\n  render(\n    <Image \n      src=\"invalid.jpg\" \n      alt=\"Test image\" \n      fallback=\"fallback.jpg\"\n      onError={onError}\n    />\n  );\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.error(img);\n  \n  expect(onError).toHaveBeenCalledTimes(1);\n  \n  await waitFor(() => {\n    expect(screen.getByText(\"Failed to load image\")).toBeInTheDocument();\n  });\n});\n\ntest(\"shows custom fallback component\", async () => {\n  const CustomFallback = <div>Custom error message</div>;\n  render(\n    <Image \n      src=\"invalid.jpg\" \n      alt=\"Test image\" \n      fallback={CustomFallback}\n    />\n  );\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.error(img);\n  \n  await waitFor(() => {\n    expect(screen.getByText(\"Custom error message\")).toBeInTheDocument();\n  });\n});\n\ntest(\"enables preview mode\", async () => {\n  const user = userEvent.setup();\n  const onPreview = vi.fn();\n  \n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview onPreview={onPreview} />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    expect(screen.getByRole(\"button\", { name: \"Preview Test image\" })).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  \n  expect(onPreview).toHaveBeenCalledTimes(1);\n  expect(screen.getByRole(\"dialog\", { name: \"Image preview\" })).toBeInTheDocument();\n});\n\ntest(\"closes preview on escape key\", async () => {\n  const user = userEvent.setup();\n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n  \n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"closes preview on close button click\", async () => {\n  const user = userEvent.setup();\n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  \n  const closeButton = screen.getByLabelText(\"Close preview\");\n  await user.click(closeButton);\n  \n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"uses custom preview source\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Image \n      src=\"test.jpg\" \n      alt=\"Test image\" \n      preview \n      previewSrc=\"high-res.jpg\"\n    />\n  );\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  \n  const previewImage = screen.getByRole(\"dialog\").querySelector(\"img\");\n  expect(previewImage).toHaveAttribute(\"src\", \"high-res.jpg\");\n});\n\ntest(\"applies custom dimensions\", () => {\n  const { container } = render(\n    <Image src=\"test.jpg\" alt=\"Test image\" width={200} height={150} />\n  );\n  \n  const imageContainer = container.firstChild as HTMLElement;\n  expect(imageContainer).toHaveStyle({\n    width: \"200px\",\n    height: \"150px\"\n  });\n});\n\ntest(\"applies border radius\", () => {\n  const { container } = render(\n    <Image src=\"test.jpg\" alt=\"Test image\" borderRadius={8} />\n  );\n  \n  const imageContainer = container.firstChild as HTMLElement;\n  expect(imageContainer).toHaveStyle({ borderRadius: \"8px\" });\n});\n\ntest(\"applies object fit styles\", () => {\n  render(<Image src=\"test.jpg\" alt=\"Test image\" objectFit=\"contain\" />);\n  \n  const img = screen.getByRole(\"img\");\n  expect(img).toHaveStyle({ objectFit: \"contain\" });\n});\n\ntest(\"supports lazy loading\", () => {\n  const mockObserve = vi.fn();\n  mockIntersectionObserver.mockReturnValue({\n    observe: mockObserve,\n    unobserve: vi.fn(),\n    disconnect: vi.fn()\n  });\n  \n  render(<Image src=\"test.jpg\" alt=\"Test image\" lazy />);\n  \n  expect(mockObserve).toHaveBeenCalled();\n});\n\ntest(\"loads immediately when not lazy\", () => {\n  render(<Image src=\"test.jpg\" alt=\"Test image\" lazy={false} />);\n  \n  const img = screen.getByRole(\"img\");\n  expect(img).toHaveAttribute(\"src\", \"test.jpg\");\n});\n\ntest(\"handles keyboard navigation for preview\", async () => {\n  const user = userEvent.setup();\n  const onPreview = vi.fn();\n  \n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview onPreview={onPreview} />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n  previewButton.focus();\n  \n  await user.keyboard(\"{Enter}\");\n  expect(onPreview).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows custom placeholder component\", () => {\n  const CustomPlaceholder = <div>Custom loading...</div>;\n  render(\n    <Image src=\"test.jpg\" alt=\"Test image\" placeholder={CustomPlaceholder} />\n  );\n  \n  expect(screen.getByText(\"Custom loading...\")).toBeInTheDocument();\n});\n\ntest(\"applies custom className\", () => {\n  const { container } = render(\n    <Image src=\"test.jpg\" alt=\"Test image\" className=\"custom-image\" />\n  );\n  \n  expect(container.firstChild).toHaveClass(\"custom-image\");\n});\n\ntest(\"forwards additional props to img element\", () => {\n  render(\n    <Image \n      src=\"test.jpg\" \n      alt=\"Test image\" \n      data-testid=\"custom-image\"\n      title=\"Custom title\"\n    />\n  );\n  \n  const img = screen.getByTestId(\"custom-image\");\n  expect(img).toHaveAttribute(\"title\", \"Custom title\");\n});\n\ntest(\"handles fallback image error\", async () => {\n  render(\n    <Image \n      src=\"invalid.jpg\" \n      alt=\"Test image\" \n      fallback=\"also-invalid.jpg\"\n    />\n  );\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.error(img);\n  \n  await waitFor(() => {\n    const fallbackImg = screen.getByRole(\"img\");\n    fireEvent.error(fallbackImg);\n  });\n  \n  await waitFor(() => {\n    expect(screen.getByText(\"Failed to load image\")).toBeInTheDocument();\n  });\n});\n\ntest(\"shows preview indicator when preview is enabled and image is loaded\", async () => {\n  const { container } = render(<Image src=\"test.jpg\" alt=\"Test image\" preview />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    expect(container.querySelector(\".image-preview-indicator\")).toBeInTheDocument();\n  });\n});\n\ntest(\"prevents body scroll when preview is open\", async () => {\n  const user = userEvent.setup();\n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  \n  expect(document.body.style.overflow).toBe(\"hidden\");\n  \n  // Close preview\n  await user.keyboard(\"{Escape}\");\n  expect(document.body.style.overflow).toBe(\"\");\n})"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface ImageProps extends React.ImgHTMLAttributes<HTMLImageElement> {\n  src: string;\n  alt: string;\n  fallback?: string | React.ReactNode;\n  placeholder?: string | React.ReactNode;\n  preview?: boolean;\n  previewSrc?: string;\n  lazy?: boolean;\n  objectFit?: \"fill\" | \"contain\" | \"cover\" | \"none\" | \"scale-down\";\n  borderRadius?: string | number;\n  onLoad?: () => void;\n  onError?: () => void;\n  onPreview?: () => void;\n  width?: string | number;\n  height?: string | number;\n  rootMargin?: string;\n  threshold?: number;\n}\n\nexport const Image = React.forwardRef<HTMLImageElement, ImageProps>(\n  ({\n    src,\n    alt,\n    fallback,\n    placeholder,\n    preview = false,\n    previewSrc,\n    lazy = false,\n    objectFit = \"cover\",\n    borderRadius,\n    onLoad,\n    onError,\n    onPreview,\n    width,\n    height,\n    rootMargin = \"50px\",\n    threshold = 0.1,\n    className,\n    style,\n    ...rest\n  }, ref) => {\n    const [imageState, setImageState] = React.useState<\"loading\" | \"loaded\" | \"error\">(\"loading\");\n    const [isVisible, setIsVisible] = React.useState(!lazy);\n    const [showPreview, setShowPreview] = React.useState(false);\n    const imgRef = React.useRef<HTMLImageElement>(null);\n    const combinedRef = React.useMemo(() => ref || imgRef, [ref]);\n\n    // Intersection Observer for lazy loading\n    React.useEffect(() => {\n      if (!lazy || isVisible) return;\n\n      const observer = new IntersectionObserver(\n        ([entry]) => {\n          if (entry.isIntersecting) {\n            setIsVisible(true);\n            observer.disconnect();\n          }\n        },\n        {\n          rootMargin,\n          threshold,\n        }\n      );\n\n      if (combinedRef && \"current\" in combinedRef && combinedRef.current) {\n        observer.observe(combinedRef.current);\n      }\n\n      return () => observer.disconnect();\n    }, [lazy, isVisible, rootMargin, threshold, combinedRef]);\n\n    const handleLoad = () => {\n      setImageState(\"loaded\");\n      if (onLoad) {\n        onLoad();\n      }\n    };\n\n    const handleError = () => {\n      setImageState(\"error\");\n      if (onError) {\n        onError();\n      }\n    };\n\n    const handleImageClick = () => {\n      if (preview) {\n        setShowPreview(true);\n        if (onPreview) {\n          onPreview();\n        }\n      }\n    };\n\n    const handlePreviewClose = () => {\n      setShowPreview(false);\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent) => {\n      if (preview && (e.key === \"Enter\" || e.key === \" \")) {\n        e.preventDefault();\n        handleImageClick();\n      }\n    };\n\n    const containerStyle: React.CSSProperties = {\n      ...style,\n      width: typeof width === \"number\" ? `${width}px` : width,\n      height: typeof height === \"number\" ? `${height}px` : height,\n      borderRadius: typeof borderRadius === \"number\" ? `${borderRadius}px` : borderRadius,\n      overflow: \"hidden\",\n      position: \"relative\",\n      display: \"inline-block\",\n    };\n\n    const imageStyle: React.CSSProperties = {\n      width: \"100%\",\n      height: \"100%\",\n      objectFit,\n      cursor: preview ? \"pointer\" : \"default\",\n    };\n\n    const classes = `image-container ${preview ? \"image-preview-enabled\" : \"\"} ${\n      imageState === \"loading\" ? \"image-loading\" : \"\"\n    } ${imageState === \"error\" ? \"image-error\" : \"\"} ${className || \"\"}`.trim();\n\n    const renderPlaceholder = () => {\n      if (typeof placeholder === \"string\") {\n        return (\n          <div className=\"image-placeholder\">\n            <div className=\"image-placeholder-content\">{placeholder}</div>\n          </div>\n        );\n      }\n      if (React.isValidElement(placeholder)) {\n        return <div className=\"image-placeholder\">{placeholder}</div>;\n      }\n      return (\n        <div className=\"image-placeholder\">\n          <div className=\"image-placeholder-content\">\n            <div className=\"image-placeholder-icon\">🖼️</div>\n            <div className=\"image-placeholder-text\">Loading...</div>\n          </div>\n        </div>\n      );\n    };\n\n    const renderFallback = () => {\n      if (typeof fallback === \"string\") {\n        return (\n          <div className=\"image-fallback\">\n            <img\n              src={fallback}\n              alt={alt}\n              style={imageStyle}\n              onError={() => {\n                setImageState(\"error\");\n              }}\n            />\n          </div>\n        );\n      }\n      if (React.isValidElement(fallback)) {\n        return <div className=\"image-fallback\">{fallback}</div>;\n      }\n      return (\n        <div className=\"image-fallback\">\n          <div className=\"image-fallback-content\">\n            <div className=\"image-fallback-icon\">❌</div>\n            <div className=\"image-fallback-text\">Failed to load image</div>\n          </div>\n        </div>\n      );\n    };\n\n    const renderPreview = () => {\n      if (!showPreview) return null;\n\n      return (\n        <div\n          className=\"image-preview-overlay\"\n          onClick={handlePreviewClose}\n          onKeyDown={(e) => {\n            if (e.key === \"Escape\") {\n              handlePreviewClose();\n            }\n          }}\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-label=\"Image preview\"\n          tabIndex={-1}\n        >\n          <div className=\"image-preview-container\">\n            <button\n              type=\"button\"\n              className=\"image-preview-close\"\n              onClick={handlePreviewClose}\n              aria-label=\"Close preview\"\n            >\n              ×\n            </button>\n            <img\n              src={previewSrc || src}\n              alt={alt}\n              className=\"image-preview-image\"\n              onError={(e) => {\n                if (previewSrc && e.currentTarget.src !== src) {\n                  e.currentTarget.src = src;\n                }\n              }}\n            />\n          </div>\n        </div>\n      );\n    };\n\n    React.useEffect(() => {\n      const handleEscape = (e: KeyboardEvent) => {\n        if (e.key === \"Escape\" && showPreview) {\n          setShowPreview(false);\n        }\n      };\n\n      if (showPreview) {\n        document.addEventListener(\"keydown\", handleEscape);\n        document.body.style.overflow = \"hidden\";\n      }\n\n      return () => {\n        document.removeEventListener(\"keydown\", handleEscape);\n        document.body.style.overflow = \"\";\n      };\n    }, [showPreview]);\n\n    return (\n      <>\n        <div className={classes} style={containerStyle}>\n          {imageState === \"loading\" && renderPlaceholder()}\n          \n          {imageState === \"error\" && renderFallback()}\n          \n          {isVisible && imageState !== \"error\" && (\n            <img\n              {...rest}\n              ref={combinedRef}\n              src={src}\n              alt={alt}\n              style={{\n                ...imageStyle,\n                opacity: imageState === \"loaded\" ? 1 : 0,\n                transition: \"opacity 0.3s ease\",\n              }}\n              onLoad={handleLoad}\n              onError={handleError}\n              onClick={handleImageClick}\n              onKeyDown={handleKeyDown}\n              tabIndex={preview ? 0 : -1}\n              role={preview ? \"button\" : undefined}\n              aria-label={preview ? `Preview ${alt}` : undefined}\n            />\n          )}\n          \n          {preview && imageState === \"loaded\" && (\n            <div className=\"image-preview-indicator\">\n              <div className=\"image-preview-icon\">🔍</div>\n            </div>\n          )}\n        </div>\n        \n        {renderPreview()}\n      </>\n    );\n  }\n);\nImage.displayName = \"Image\";",
    "output": "import { render, screen, fireEvent, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Image } from \"../Image\";\n\nconst mockIntersectionObserver = vi.fn();\nmockIntersectionObserver.mockReturnValue({\n  observe: () => null,\n  unobserve: () => null,\n  disconnect: () => null\n});\nwindow.IntersectionObserver = mockIntersectionObserver;\n\ntest(\"renders image with src and alt\", () => {\n  render(<Image src=\"test.jpg\" alt=\"Test image\" />);\n  \n  const img = screen.getByRole(\"img\");\n  expect(img).toHaveAttribute(\"src\", \"test.jpg\");\n  expect(img).toHaveAttribute(\"alt\", \"Test image\");\n});\n\ntest(\"shows placeholder while loading\", () => {\n  render(<Image src=\"test.jpg\" alt=\"Test image\" placeholder=\"Loading...\" />);\n  \n  expect(screen.getByText(\"🖼️\")).toBeInTheDocument();\n});\n\ntest(\"calls onLoad when image loads successfully\", async () => {\n  const onLoad = vi.fn();\n  render(<Image src=\"test.jpg\" alt=\"Test image\" onLoad={onLoad} />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  expect(onLoad).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows fallback on image error\", async () => {\n  const onError = vi.fn();\n  render(\n    <Image \n      src=\"invalid.jpg\" \n      alt=\"Test image\" \n      fallback=\"fallback.jpg\"\n      onError={onError}\n    />\n  );\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.error(img);\n  \n  expect(onError).toHaveBeenCalledTimes(1);\n  \n  await waitFor(() => {\n    expect(screen.getByText(\"Failed to load image\")).toBeInTheDocument();\n  });\n});\n\ntest(\"shows custom fallback component\", async () => {\n  const CustomFallback = <div>Custom error message</div>;\n  render(\n    <Image \n      src=\"invalid.jpg\" \n      alt=\"Test image\" \n      fallback={CustomFallback}\n    />\n  );\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.error(img);\n  \n  await waitFor(() => {\n    expect(screen.getByText(\"Custom error message\")).toBeInTheDocument();\n  });\n});\n\ntest(\"enables preview mode\", async () => {\n  const user = userEvent.setup();\n  const onPreview = vi.fn();\n  \n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview onPreview={onPreview} />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    expect(screen.getByRole(\"button\", { name: \"Preview Test image\" })).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  \n  expect(onPreview).toHaveBeenCalledTimes(1);\n  expect(screen.getByRole(\"dialog\", { name: \"Image preview\" })).toBeInTheDocument();\n});\n\ntest(\"closes preview on escape key\", async () => {\n  const user = userEvent.setup();\n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  expect(screen.getByRole(\"dialog\")).toBeInTheDocument();\n  \n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"closes preview on close button click\", async () => {\n  const user = userEvent.setup();\n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  \n  const closeButton = screen.getByLabelText(\"Close preview\");\n  await user.click(closeButton);\n  \n  expect(screen.queryByRole(\"dialog\")).not.toBeInTheDocument();\n});\n\ntest(\"uses custom preview source\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Image \n      src=\"test.jpg\" \n      alt=\"Test image\" \n      preview \n      previewSrc=\"high-res.jpg\"\n    />\n  );\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  \n  const previewImage = screen.getByRole(\"dialog\").querySelector(\"img\");\n  expect(previewImage).toHaveAttribute(\"src\", \"high-res.jpg\");\n});\n\ntest(\"applies custom dimensions\", () => {\n  const { container } = render(\n    <Image src=\"test.jpg\" alt=\"Test image\" width={200} height={150} />\n  );\n  \n  const imageContainer = container.firstChild as HTMLElement;\n  expect(imageContainer).toHaveStyle({\n    width: \"200px\",\n    height: \"150px\"\n  });\n});\n\ntest(\"applies border radius\", () => {\n  const { container } = render(\n    <Image src=\"test.jpg\" alt=\"Test image\" borderRadius={8} />\n  );\n  \n  const imageContainer = container.firstChild as HTMLElement;\n  expect(imageContainer).toHaveStyle({ borderRadius: \"8px\" });\n});\n\ntest(\"applies object fit styles\", () => {\n  render(<Image src=\"test.jpg\" alt=\"Test image\" objectFit=\"contain\" />);\n  \n  const img = screen.getByRole(\"img\");\n  expect(img).toHaveStyle({ objectFit: \"contain\" });\n});\n\ntest(\"supports lazy loading\", () => {\n  const mockObserve = vi.fn();\n  mockIntersectionObserver.mockReturnValue({\n    observe: mockObserve,\n    unobserve: vi.fn(),\n    disconnect: vi.fn()\n  });\n  \n  render(<Image src=\"test.jpg\" alt=\"Test image\" lazy />);\n  \n  expect(mockObserve).toHaveBeenCalled();\n});\n\ntest(\"loads immediately when not lazy\", () => {\n  render(<Image src=\"test.jpg\" alt=\"Test image\" lazy={false} />);\n  \n  const img = screen.getByRole(\"img\");\n  expect(img).toHaveAttribute(\"src\", \"test.jpg\");\n});\n\ntest(\"handles keyboard navigation for preview\", async () => {\n  const user = userEvent.setup();\n  const onPreview = vi.fn();\n  \n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview onPreview={onPreview} />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n  previewButton.focus();\n  \n  await user.keyboard(\"{Enter}\");\n  expect(onPreview).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows custom placeholder component\", () => {\n  const CustomPlaceholder = <div>Custom loading...</div>;\n  render(\n    <Image src=\"test.jpg\" alt=\"Test image\" placeholder={CustomPlaceholder} />\n  );\n  \n  expect(screen.getByText(\"Custom loading...\")).toBeInTheDocument();\n});\n\ntest(\"applies custom className\", () => {\n  const { container } = render(\n    <Image src=\"test.jpg\" alt=\"Test image\" className=\"custom-image\" />\n  );\n  \n  expect(container.firstChild).toHaveClass(\"custom-image\");\n});\n\ntest(\"forwards additional props to img element\", () => {\n  render(\n    <Image \n      src=\"test.jpg\" \n      alt=\"Test image\" \n      data-testid=\"custom-image\"\n      title=\"Custom title\"\n    />\n  );\n  \n  const img = screen.getByTestId(\"custom-image\");\n  expect(img).toHaveAttribute(\"title\", \"Custom title\");\n});\n\ntest(\"handles fallback image error\", async () => {\n  render(\n    <Image \n      src=\"invalid.jpg\" \n      alt=\"Test image\" \n      fallback=\"also-invalid.jpg\"\n    />\n  );\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.error(img);\n  \n  await waitFor(() => {\n    const fallbackImg = screen.getByRole(\"img\");\n    fireEvent.error(fallbackImg);\n  });\n  \n  await waitFor(() => {\n    expect(screen.getByText(\"Failed to load image\")).toBeInTheDocument();\n  });\n});\n\ntest(\"shows preview indicator when preview is enabled and image is loaded\", async () => {\n  const { container } = render(<Image src=\"test.jpg\" alt=\"Test image\" preview />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    expect(container.querySelector(\".image-preview-indicator\")).toBeInTheDocument();\n  });\n});\n\ntest(\"prevents body scroll when preview is open\", async () => {\n  const user = userEvent.setup();\n  render(<Image src=\"test.jpg\" alt=\"Test image\" preview />);\n  \n  const img = screen.getByRole(\"img\");\n  fireEvent.load(img);\n  \n  await waitFor(() => {\n    const previewButton = screen.getByRole(\"button\", { name: \"Preview Test image\" });\n    expect(previewButton).toBeInTheDocument();\n  });\n  \n  await user.click(screen.getByRole(\"button\", { name: \"Preview Test image\" }));\n  \n  expect(document.body.style.overflow).toBe(\"hidden\");\n  \n  // Close preview\n  await user.keyboard(\"{Escape}\");\n  expect(document.body.style.overflow).toBe(\"\");\n})"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {\n    label?: string;\n    error?: string;\n    helperText?: string;\n    variant?: \"default\" | \"filled\" | \"outlined\";\n}\n\nconst classesByVariant: Record<NonNullable<InputProps[\"variant\"]>, string> = {\n    default: \"input input-default\",\n    filled: \"input input-filled\",\n    outlined: \"input input-outlined\",\n};\n\nexport const Input = React.forwardRef<HTMLInputElement, InputProps>(\n    ({ label, error, helperText, variant = \"default\", className, id, ...rest }, ref) => {\n        const inputId = id || React.useId();\n        const errorId = error ? `${inputId}-error` : undefined;\n        const helperTextId = helperText ? `${inputId}-helper` : undefined;\n\n        const classes = `${classesByVariant[variant]} ${error ? \"input-error\" : \"\"} ${className || \"\"}`.trim();\n\n        return (\n            <div className=\"input-wrapper\">\n                {label && (\n                    <label htmlFor={inputId} className=\"input-label\">\n                        {label}\n                    </label>\n                )}\n                <input\n                    {...rest}\n                    ref={ref}\n                    id={inputId}\n                    className={classes}\n                    aria-invalid={error ? true : undefined}\n                    aria-describedby={[errorId, helperTextId].filter(Boolean).join(\" \") || undefined}\n                />\n                {error && (\n                    <div id={errorId} className=\"input-error-text\" role=\"alert\">\n                        {error}\n                    </div>\n                )}\n                {helperText && !error && (\n                    <div id={helperTextId} className=\"input-helper-text\">\n                        {helperText}\n                    </div>\n                )}\n            </div>\n        );\n    }\n);\nInput.displayName = \"Input\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Input } from \"../Input\";\n\ntest(\"renders with label\", () => {\n    render(<Input label=\"Email\" />);\n    expect(screen.getByLabelText(\"Email\")).toBeInTheDocument();\n});\n\ntest(\"handles user input\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Input label=\"Name\" onChange={onChange} />);\n\n    const input = screen.getByLabelText(\"Name\");\n    await user.type(input, \"John\");\n\n    expect(onChange).toHaveBeenCalledTimes(4);\n    expect(input).toHaveValue(\"John\");\n});\n\ntest(\"shows error state\", () => {\n    render(<Input label=\"Email\" error=\"Invalid email\" />);\n    const input = screen.getByLabelText(\"Email\");\n\n    expect(input).toHaveClass(\"input-error\");\n    expect(input).toHaveAttribute(\"aria-invalid\", \"true\");\n    expect(screen.getByRole(\"alert\")).toHaveTextContent(\"Invalid email\");\n});\n\ntest(\"shows helper text\", () => {\n    render(<Input label=\"Password\" helperText=\"Must be at least 8 characters\" />);\n    expect(screen.getByText(\"Must be at least 8 characters\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Input variant=\"outlined\" />);\n    expect(screen.getByRole(\"textbox\")).toHaveClass(\"input\", \"input-outlined\");\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {\n    label?: string;\n    error?: string;\n    helperText?: string;\n    variant?: \"default\" | \"filled\" | \"outlined\";\n}\n\nconst classesByVariant: Record<NonNullable<InputProps[\"variant\"]>, string> = {\n    default: \"input input-default\",\n    filled: \"input input-filled\",\n    outlined: \"input input-outlined\",\n};\n\nexport const Input = React.forwardRef<HTMLInputElement, InputProps>(\n    ({ label, error, helperText, variant = \"default\", className, id, ...rest }, ref) => {\n        const inputId = id || React.useId();\n        const errorId = error ? `${inputId}-error` : undefined;\n        const helperTextId = helperText ? `${inputId}-helper` : undefined;\n\n        const classes = `${classesByVariant[variant]} ${error ? \"input-error\" : \"\"} ${className || \"\"}`.trim();\n\n        return (\n            <div className=\"input-wrapper\">\n                {label && (\n                    <label htmlFor={inputId} className=\"input-label\">\n                        {label}\n                    </label>\n                )}\n                <input\n                    {...rest}\n                    ref={ref}\n                    id={inputId}\n                    className={classes}\n                    aria-invalid={error ? true : undefined}\n                    aria-describedby={[errorId, helperTextId].filter(Boolean).join(\" \") || undefined}\n                />\n                {error && (\n                    <div id={errorId} className=\"input-error-text\" role=\"alert\">\n                        {error}\n                    </div>\n                )}\n                {helperText && !error && (\n                    <div id={helperTextId} className=\"input-helper-text\">\n                        {helperText}\n                    </div>\n                )}\n            </div>\n        );\n    }\n);\nInput.displayName = \"Input\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Input } from \"../Input\";\n\ntest(\"renders with label\", () => {\n    render(<Input label=\"Email\" />);\n    expect(screen.getByLabelText(\"Email\")).toBeInTheDocument();\n});\n\ntest(\"handles user input\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Input label=\"Name\" onChange={onChange} />);\n\n    const input = screen.getByLabelText(\"Name\");\n    await user.type(input, \"John\");\n\n    expect(onChange).toHaveBeenCalledTimes(4);\n    expect(input).toHaveValue(\"John\");\n});\n\ntest(\"shows error state\", () => {\n    render(<Input label=\"Email\" error=\"Invalid email\" />);\n    const input = screen.getByLabelText(\"Email\");\n\n    expect(input).toHaveClass(\"input-error\");\n    expect(input).toHaveAttribute(\"aria-invalid\", \"true\");\n    expect(screen.getByRole(\"alert\")).toHaveTextContent(\"Invalid email\");\n});\n\ntest(\"shows helper text\", () => {\n    render(<Input label=\"Password\" helperText=\"Must be at least 8 characters\" />);\n    expect(screen.getByText(\"Must be at least 8 characters\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Input variant=\"outlined\" />);\n    expect(screen.getByRole(\"textbox\")).toHaveClass(\"input\", \"input-outlined\");\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface InputProps extends React.InputHTMLAttributes<HTMLInputElement> {\n    label?: string;\n    error?: string;\n    helperText?: string;\n    variant?: \"default\" | \"filled\" | \"outlined\";\n}\n\nconst classesByVariant: Record<NonNullable<InputProps[\"variant\"]>, string> = {\n    default: \"input input-default\",\n    filled: \"input input-filled\",\n    outlined: \"input input-outlined\",\n};\n\nexport const Input = React.forwardRef<HTMLInputElement, InputProps>(\n    ({ label, error, helperText, variant = \"default\", className, id, ...rest }, ref) => {\n        const inputId = id || React.useId();\n        const errorId = error ? `${inputId}-error` : undefined;\n        const helperTextId = helperText ? `${inputId}-helper` : undefined;\n\n        const classes = `${classesByVariant[variant]} ${error ? \"input-error\" : \"\"} ${className || \"\"}`.trim();\n\n        return (\n            <div className=\"input-wrapper\">\n                {label && (\n                    <label htmlFor={inputId} className=\"input-label\">\n                        {label}\n                    </label>\n                )}\n                <input\n                    {...rest}\n                    ref={ref}\n                    id={inputId}\n                    className={classes}\n                    aria-invalid={error ? true : undefined}\n                    aria-describedby={[errorId, helperTextId].filter(Boolean).join(\" \") || undefined}\n                />\n                {error && (\n                    <div id={errorId} className=\"input-error-text\" role=\"alert\">\n                        {error}\n                    </div>\n                )}\n                {helperText && !error && (\n                    <div id={helperTextId} className=\"input-helper-text\">\n                        {helperText}\n                    </div>\n                )}\n            </div>\n        );\n    }\n);\nInput.displayName = \"Input\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Input } from \"../Input\";\n\ntest(\"renders with label\", () => {\n    render(<Input label=\"Email\" />);\n    expect(screen.getByLabelText(\"Email\")).toBeInTheDocument();\n});\n\ntest(\"handles user input\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Input label=\"Name\" onChange={onChange} />);\n\n    const input = screen.getByLabelText(\"Name\");\n    await user.type(input, \"John\");\n\n    expect(onChange).toHaveBeenCalledTimes(4);\n    expect(input).toHaveValue(\"John\");\n});\n\ntest(\"shows error state\", () => {\n    render(<Input label=\"Email\" error=\"Invalid email\" />);\n    const input = screen.getByLabelText(\"Email\");\n\n    expect(input).toHaveClass(\"input-error\");\n    expect(input).toHaveAttribute(\"aria-invalid\", \"true\");\n    expect(screen.getByRole(\"alert\")).toHaveTextContent(\"Invalid email\");\n});\n\ntest(\"shows helper text\", () => {\n    render(<Input label=\"Password\" helperText=\"Must be at least 8 characters\" />);\n    expect(screen.getByText(\"Must be at least 8 characters\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Input variant=\"outlined\" />);\n    expect(screen.getByRole(\"textbox\")).toHaveClass(\"input\", \"input-outlined\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface KanbanCard {\n  id: string;\n  title: string;\n  description?: string;\n  assignee?: string;\n  priority?: \"low\" | \"medium\" | \"high\" | \"urgent\";\n  tags?: string[];\n  dueDate?: Date;\n  coverImage?: string;\n  customContent?: React.ReactNode;\n}\n\nexport interface KanbanColumn {\n  id: string;\n  title: string;\n  cards: KanbanCard[];\n  color?: string;\n  limit?: number;\n  collapsed?: boolean;\n}\n\nexport interface KanbanProps extends React.HTMLAttributes<HTMLDivElement> {\n  columns: KanbanColumn[];\n  onCardMove?: (cardId: string, fromColumnId: string, toColumnId: string, newIndex: number) => void;\n  onColumnMove?: (columnId: string, newIndex: number) => void;\n  onCardClick?: (card: KanbanCard) => void;\n  onCardEdit?: (card: KanbanCard) => void;\n  onCardDelete?: (cardId: string) => void;\n  onAddCard?: (columnId: string) => void;\n  onAddColumn?: () => void;\n  cardRender?: (card: KanbanCard) => React.ReactNode;\n  columnHeaderRender?: (column: KanbanColumn) => React.ReactNode;\n  readonly?: boolean;\n  showColumnLimits?: boolean;\n  allowColumnCollapse?: boolean;\n}\n\nconst priorityColors = {\n  low: \"#52c41a\",\n  medium: \"#faad14\", \n  high: \"#fa541c\",\n  urgent: \"#f5222d\"\n};\n\nexport const Kanban = React.forwardRef<HTMLDivElement, KanbanProps>(\n  ({\n    columns,\n    onCardMove,\n    onColumnMove,\n    onCardClick,\n    onCardEdit,\n    onCardDelete,\n    onAddCard,\n    onAddColumn,\n    cardRender,\n    columnHeaderRender,\n    readonly = false,\n    showColumnLimits = true,\n    allowColumnCollapse = false,\n    className,\n    ...rest\n  }, ref) => {\n    const [draggedCard, setDraggedCard] = React.useState<{\n      card: KanbanCard;\n      fromColumnId: string;\n    } | null>(null);\n    const [draggedColumn, setDraggedColumn] = React.useState<string | null>(null);\n    const [dragOverColumn, setDragOverColumn] = React.useState<string | null>(null);\n    const [dragOverCardIndex, setDragOverCardIndex] = React.useState<number | null>(null);\n\n    const classes = `kanban ${readonly ? \"kanban-readonly\" : \"\"} ${className || \"\"}`.trim();\n\n    const handleCardDragStart = (e: React.DragEvent, card: KanbanCard, columnId: string) => {\n      if (readonly) return;\n      \n      setDraggedCard({ card, fromColumnId: columnId });\n      e.dataTransfer.effectAllowed = \"move\";\n      e.dataTransfer.setData(\"text/plain\", card.id);\n    };\n\n    const handleCardDragEnd = () => {\n      setDraggedCard(null);\n      setDragOverColumn(null);\n      setDragOverCardIndex(null);\n    };\n\n    const handleColumnDragStart = (e: React.DragEvent, columnId: string) => {\n      if (readonly) return;\n      \n      setDraggedColumn(columnId);\n      e.dataTransfer.effectAllowed = \"move\";\n      e.dataTransfer.setData(\"text/plain\", columnId);\n    };\n\n    const handleColumnDragEnd = () => {\n      setDraggedColumn(null);\n    };\n\n    const handleColumnDragOver = (e: React.DragEvent, columnId: string) => {\n      e.preventDefault();\n      e.dataTransfer.dropEffect = \"move\";\n      \n      if (draggedCard) {\n        setDragOverColumn(columnId);\n      }\n    };\n\n    const handleCardDragOver = (e: React.DragEvent, columnId: string, cardIndex: number) => {\n      e.preventDefault();\n      e.stopPropagation();\n      e.dataTransfer.dropEffect = \"move\";\n      \n      if (draggedCard) {\n        setDragOverColumn(columnId);\n        setDragOverCardIndex(cardIndex);\n      }\n    };\n\n    const handleColumnDrop = (e: React.DragEvent, targetColumnId: string) => {\n      e.preventDefault();\n      \n      if (draggedCard && onCardMove) {\n        const targetColumn = columns.find(col => col.id === targetColumnId);\n        const newIndex = targetColumn ? targetColumn.cards.length : 0;\n        \n        onCardMove(\n          draggedCard.card.id,\n          draggedCard.fromColumnId,\n          targetColumnId,\n          newIndex\n        );\n      }\n      \n      if (draggedColumn && onColumnMove) {\n        const targetIndex = columns.findIndex(col => col.id === targetColumnId);\n        onColumnMove(draggedColumn, targetIndex);\n      }\n      \n      setDraggedCard(null);\n      setDraggedColumn(null);\n      setDragOverColumn(null);\n      setDragOverCardIndex(null);\n    };\n\n    const handleCardDrop = (e: React.DragEvent, targetColumnId: string, targetIndex: number) => {\n      e.preventDefault();\n      e.stopPropagation();\n      \n      if (draggedCard && onCardMove) {\n        onCardMove(\n          draggedCard.card.id,\n          draggedCard.fromColumnId,\n          targetColumnId,\n          targetIndex\n        );\n      }\n      \n      setDraggedCard(null);\n      setDragOverColumn(null);\n      setDragOverCardIndex(null);\n    };\n\n    const handleCardClick = (card: KanbanCard) => {\n      if (onCardClick) {\n        onCardClick(card);\n      }\n    };\n\n    const handleCardEdit = (e: React.MouseEvent, card: KanbanCard) => {\n      e.stopPropagation();\n      if (onCardEdit) {\n        onCardEdit(card);\n      }\n    };\n\n    const handleCardDelete = (e: React.MouseEvent, cardId: string) => {\n      e.stopPropagation();\n      if (onCardDelete) {\n        onCardDelete(cardId);\n      }\n    };\n\n    const formatDate = (date: Date): string => {\n      return date.toLocaleDateString();\n    };\n\n    const isOverdue = (date: Date): boolean => {\n      return date < new Date();\n    };\n\n    const renderCard = (card: KanbanCard, columnId: string, index: number) => {\n      if (cardRender) {\n        return cardRender(card);\n      }\n\n      const isDragging = draggedCard?.card.id === card.id;\n      const isDragOver = dragOverColumn === columnId && dragOverCardIndex === index;\n\n      return (\n        <div\n          key={card.id}\n          className={`kanban-card ${isDragging ? \"kanban-card-dragging\" : \"\"} ${\n            isDragOver ? \"kanban-card-drag-over\" : \"\"\n          }`}\n          draggable={!readonly}\n          onDragStart={(e) => handleCardDragStart(e, card, columnId)}\n          onDragEnd={handleCardDragEnd}\n          onDragOver={(e) => handleCardDragOver(e, columnId, index)}\n          onDrop={(e) => handleCardDrop(e, columnId, index)}\n          onClick={() => handleCardClick(card)}\n          role=\"button\"\n          tabIndex={0}\n          aria-label={`Card: ${card.title}`}\n          onKeyDown={(e) => {\n            if (e.key === \"Enter\" || e.key === \" \") {\n              e.preventDefault();\n              handleCardClick(card);\n            }\n          }}\n        >\n          {card.coverImage && (\n            <div className=\"kanban-card-cover\">\n              <img src={card.coverImage} alt=\"\" />\n            </div>\n          )}\n          \n          <div className=\"kanban-card-content\">\n            <div className=\"kanban-card-header\">\n              <h4 className=\"kanban-card-title\">{card.title}</h4>\n              {!readonly && (\n                <div className=\"kanban-card-actions\">\n                  {onCardEdit && (\n                    <button\n                      type=\"button\"\n                      className=\"kanban-card-action\"\n                      onClick={(e) => handleCardEdit(e, card)}\n                      aria-label=\"Edit card\"\n                    >\n                      ✏️\n                    </button>\n                  )}\n                  {onCardDelete && (\n                    <button\n                      type=\"button\"\n                      className=\"kanban-card-action\"\n                      onClick={(e) => handleCardDelete(e, card.id)}\n                      aria-label=\"Delete card\"\n                    >\n                      🗑️\n                    </button>\n                  )}\n                </div>\n              )}\n            </div>\n            \n            {card.description && (\n              <p className=\"kanban-card-description\">{card.description}</p>\n            )}\n            \n            {card.customContent && (\n              <div className=\"kanban-card-custom\">{card.customContent}</div>\n            )}\n            \n            <div className=\"kanban-card-footer\">\n              {card.priority && (\n                <span\n                  className=\"kanban-card-priority\"\n                  style={{ backgroundColor: priorityColors[card.priority] }}\n                >\n                  {card.priority}\n                </span>\n              )}\n              \n              {card.assignee && (\n                <div className=\"kanban-card-assignee\" title={card.assignee}>\n                  {card.assignee.charAt(0).toUpperCase()}\n                </div>\n              )}\n              \n              {card.dueDate && (\n                <div\n                  className={`kanban-card-due-date ${\n                    isOverdue(card.dueDate) ? \"kanban-card-overdue\" : \"\"\n                  }`}\n                >\n                  📅 {formatDate(card.dueDate)}\n                </div>\n              )}\n            </div>\n            \n            {card.tags && card.tags.length > 0 && (\n              <div className=\"kanban-card-tags\">\n                {card.tags.map(tag => (\n                  <span key={tag} className=\"kanban-card-tag\">\n                    {tag}\n                  </span>\n                ))}\n              </div>\n            )}\n          </div>\n        </div>\n      );\n    };\n\n    const renderColumn = (column: KanbanColumn, index: number) => {\n      const isDragging = draggedColumn === column.id;\n      const isDragOver = dragOverColumn === column.id;\n      const isOverLimit = column.limit && column.cards.length > column.limit;\n\n      return (\n        <div\n          key={column.id}\n          className={`kanban-column ${isDragging ? \"kanban-column-dragging\" : \"\"} ${\n            isDragOver ? \"kanban-column-drag-over\" : \"\"\n          } ${isOverLimit ? \"kanban-column-over-limit\" : \"\"} ${\n            column.collapsed ? \"kanban-column-collapsed\" : \"\"\n          }`}\n          draggable={!readonly}\n          onDragStart={(e) => handleColumnDragStart(e, column.id)}\n          onDragEnd={handleColumnDragEnd}\n          onDragOver={(e) => handleColumnDragOver(e, column.id)}\n          onDrop={(e) => handleColumnDrop(e, column.id)}\n          style={{ borderTopColor: column.color }}\n        >\n          {columnHeaderRender ? columnHeaderRender(column) : (\n            <div className=\"kanban-column-header\">\n              <div className=\"kanban-column-title-section\">\n                <h3 className=\"kanban-column-title\">{column.title}</h3>\n                <span className=\"kanban-column-count\">\n                  {column.cards.length}\n                  {showColumnLimits && column.limit && ` / ${column.limit}`}\n                </span>\n              </div>\n              \n              <div className=\"kanban-column-actions\">\n                {allowColumnCollapse && (\n                  <button\n                    type=\"button\"\n                    className=\"kanban-column-action\"\n                    aria-label={column.collapsed ? \"Expand column\" : \"Collapse column\"}\n                  >\n                    {column.collapsed ? \"+\" : \"−\"}\n                  </button>\n                )}\n                \n                {onAddCard && !readonly && (\n                  <button\n                    type=\"button\"\n                    className=\"kanban-column-action\"\n                    onClick={() => onAddCard(column.id)}\n                    aria-label=\"Add card\"\n                  >\n                    +\n                  </button>\n                )}\n              </div>\n            </div>\n          )}\n          \n          {!column.collapsed && (\n            <div className=\"kanban-column-content\">\n              <div className=\"kanban-cards\">\n                {column.cards.map((card, cardIndex) => (\n                  <React.Fragment key={card.id}>\n                    {draggedCard && \n                     dragOverColumn === column.id && \n                     dragOverCardIndex === cardIndex && (\n                      <div className=\"kanban-card-drop-zone\" />\n                    )}\n                    {renderCard(card, column.id, cardIndex)}\n                  </React.Fragment>\n                ))}\n                \n                {draggedCard && \n                 dragOverColumn === column.id && \n                 (dragOverCardIndex === null || dragOverCardIndex >= column.cards.length) && (\n                  <div className=\"kanban-card-drop-zone\" />\n                )}\n              </div>\n            </div>\n          )}\n        </div>\n      );\n    };\n\n    return (\n      <div {...rest} ref={ref} className={classes}>\n        <div className=\"kanban-board\">\n          {columns.map((column, index) => renderColumn(column, index))}\n          \n          {onAddColumn && !readonly && (\n            <div className=\"kanban-add-column\">\n              <button\n                type=\"button\"\n                className=\"kanban-add-column-button\"\n                onClick={onAddColumn}\n                aria-label=\"Add column\"\n              >\n                + Add Column\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n);\nKanban.displayName = \"Kanban\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Kanban } from \"../Kanban\";\n\nconst mockColumns = [\n  {\n    id: \"todo\",\n    title: \"To Do\",\n    cards: [\n      {\n        id: \"card1\",\n        title: \"Task 1\",\n        description: \"First task\",\n        priority: \"high\" as const,\n        assignee: \"John Doe\",\n        tags: [\"urgent\", \"frontend\"]\n      },\n      {\n        id: \"card2\", \n        title: \"Task 2\",\n        dueDate: new Date(\"2024-12-01\")\n      }\n    ],\n    limit: 5\n  },\n  {\n    id: \"inprogress\",\n    title: \"In Progress\", \n    cards: [\n      {\n        id: \"card3\",\n        title: \"Task 3\",\n        description: \"Task in progress\"\n      }\n    ]\n  },\n  {\n    id: \"done\",\n    title: \"Done\",\n    cards: []\n  }\n];\n\ntest(\"renders kanban board with columns\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"To Do\")).toBeInTheDocument();\n  expect(screen.getByText(\"In Progress\")).toBeInTheDocument();\n  expect(screen.getByText(\"Done\")).toBeInTheDocument();\n});\n\ntest(\"renders cards in columns\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"Task 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Task 2\")).toBeInTheDocument();\n  expect(screen.getByText(\"Task 3\")).toBeInTheDocument();\n});\n\ntest(\"shows card details\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"First task\")).toBeInTheDocument();\n  expect(screen.getByText(\"high\")).toBeInTheDocument();\n  expect(screen.getByText(\"urgent\")).toBeInTheDocument();\n  expect(screen.getByText(\"frontend\")).toBeInTheDocument();\n});\n\ntest(\"shows column counts\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"2\")).toBeInTheDocument(); // To Do count\n  expect(screen.getByText(\"1\")).toBeInTheDocument(); // In Progress count\n  expect(screen.getByText(\"0\")).toBeInTheDocument(); // Done count\n});\n\ntest(\"shows column limits when enabled\", () => {\n  render(<Kanban columns={mockColumns} showColumnLimits />);\n  \n  expect(screen.getByText(\"2 / 5\")).toBeInTheDocument(); // To Do with limit\n});\n\ntest(\"handles card clicks\", async () => {\n  const user = userEvent.setup();\n  const onCardClick = vi.fn();\n  render(<Kanban columns={mockColumns} onCardClick={onCardClick} />);\n  \n  await user.click(screen.getByText(\"Task 1\"));\n  expect(onCardClick).toHaveBeenCalledWith(mockColumns[0].cards[0]);\n});\n\ntest(\"shows card actions when not readonly\", () => {\n  render(<Kanban columns={mockColumns} onCardEdit={vi.fn()} onCardDelete={vi.fn()} />);\n  \n  expect(screen.getAllByLabelText(\"Edit card\")).toHaveLength(3);\n  expect(screen.getAllByLabelText(\"Delete card\")).toHaveLength(3);\n});\n\ntest(\"handles card edit\", async () => {\n  const user = userEvent.setup();\n  const onCardEdit = vi.fn();\n  render(<Kanban columns={mockColumns} onCardEdit={onCardEdit} />);\n  \n  const editButtons = screen.getAllByLabelText(\"Edit card\");\n  await user.click(editButtons[0]);\n  \n  expect(onCardEdit).toHaveBeenCalledWith(mockColumns[0].cards[0]);\n});\n\ntest(\"handles card delete\", async () => {\n  const user = userEvent.setup();\n  const onCardDelete = vi.fn();\n  render(<Kanban columns={mockColumns} onCardDelete={onCardDelete} />);\n  \n  const deleteButtons = screen.getAllByLabelText(\"Delete card\");\n  await user.click(deleteButtons[0]);\n  \n  expect(onCardDelete).toHaveBeenCalledWith(\"card1\");\n});\n\ntest(\"shows add card button\", () => {\n  render(<Kanban columns={mockColumns} onAddCard={vi.fn()} />);\n  \n  expect(screen.getAllByLabelText(\"Add card\")).toHaveLength(3);\n});\n\ntest(\"handles add card\", async () => {\n  const user = userEvent.setup();\n  const onAddCard = vi.fn();\n  render(<Kanban columns={mockColumns} onAddCard={onAddCard} />);\n  \n  const addButtons = screen.getAllByLabelText(\"Add card\");\n  await user.click(addButtons[0]);\n  \n  expect(onAddCard).toHaveBeenCalledWith(\"todo\");\n});\n\ntest(\"shows add column button\", () => {\n  render(<Kanban columns={mockColumns} onAddColumn={vi.fn()} />);\n  \n  expect(screen.getByText(\"+ Add Column\")).toBeInTheDocument();\n});\n\ntest(\"handles add column\", async () => {\n  const user = userEvent.setup();\n  const onAddColumn = vi.fn();\n  render(<Kanban columns={mockColumns} onAddColumn={onAddColumn} />);\n  \n  await user.click(screen.getByText(\"+ Add Column\"));\n  expect(onAddColumn).toHaveBeenCalled();\n});\n\ntest(\"shows assignee initials\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"J\")).toBeInTheDocument(); // John Doe's initial\n});\n\ntest(\"shows due dates\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(/12\\/1\\/2024/)).toBeInTheDocument();\n});\n\ntest(\"highlights overdue tasks\", () => {\n  const overdueColumns = [\n    {\n      id: \"overdue\",\n      title: \"Overdue\",\n      cards: [\n        {\n          id: \"overdue1\",\n          title: \"Overdue Task\",\n          dueDate: new Date(\"2020-01-01\") // Past date\n        }\n      ]\n    }\n  ];\n  \n  render(<Kanban columns={overdueColumns} />);\n  \n  const dueDateElement = screen.getByText(/1\\/1\\/2020/).closest('.kanban-card-due-date');\n  expect(dueDateElement).toHaveClass(\"kanban-card-overdue\");\n});\n\ntest(\"is readonly when readonly prop is true\", () => {\n  render(<Kanban columns={mockColumns} readonly onCardEdit={vi.fn()} onCardDelete={vi.fn()} />);\n  \n  expect(screen.queryByLabelText(\"Edit card\")).not.toBeInTheDocument();\n  expect(screen.queryByLabelText(\"Delete card\")).not.toBeInTheDocument();\n});\n\ntest(\"shows priority colors\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  const priorityElement = screen.getByText(\"high\");\n  expect(priorityElement).toHaveStyle({ backgroundColor: \"#fa541c\" });\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  const onCardClick = vi.fn();\n  render(<Kanban columns={mockColumns} onCardClick={onCardClick} />);\n  \n  const card = screen.getByLabelText(\"Card: Task 1\");\n  card.focus();\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onCardClick).toHaveBeenCalledWith(mockColumns[0].cards[0]);\n});\n\ntest(\"uses custom card renderer\", () => {\n  const cardRender = (card: any) => <div>Custom {card.title}</div>;\n  render(<Kanban columns={mockColumns} cardRender={cardRender} />);\n  \n  expect(screen.getByText(\"Custom Task 1\")).toBeInTheDocument();\n});\n\ntest(\"uses custom column header renderer\", () => {\n  const columnHeaderRender = (column: any) => <div>Custom {column.title}</div>;\n  render(<Kanban columns={mockColumns} columnHeaderRender={columnHeaderRender} />);\n  \n  expect(screen.getByText(\"Custom To Do\")).toBeInTheDocument();\n});\n\ntest(\"shows collapsed columns\", () => {\n  const collapsedColumns = [\n    { ...mockColumns[0], collapsed: true }\n  ];\n  \n  render(<Kanban columns={collapsedColumns} allowColumnCollapse />);\n  \n  const column = screen.getByText(\"To Do\").closest(\".kanban-column\");\n  expect(column).toHaveClass(\"kanban-column-collapsed\");\n});\n\ntest(\"shows over-limit styling\", () => {\n  const overLimitColumns = [\n    {\n      ...mockColumns[0],\n      limit: 1, // Less than current card count (2)\n    }\n  ];\n  \n  render(<Kanban columns={overLimitColumns} />);\n  \n  const column = screen.getByText(\"To Do\").closest(\".kanban-column\");\n  expect(column).toHaveClass(\"kanban-column-over-limit\");\n});\n\ntest(\"handles drag and drop operations\", () => {\n  const onCardMove = vi.fn();\n  render(<Kanban columns={mockColumns} onCardMove={onCardMove} />);\n  \n  const cards = screen.getAllByRole(\"button\");\n  const firstCard = cards.find(card => card.getAttribute(\"aria-label\")?.includes(\"Task 1\"));\n  \n  expect(firstCard).toHaveAttribute(\"draggable\", \"true\");\n});\n\ntest(\"renders cover images\", () => {\n  const columnsWithImages = [\n    {\n      id: \"visual\",\n      title: \"Visual\",\n      cards: [\n        {\n          id: \"card-with-image\",\n          title: \"Visual Task\",\n          coverImage: \"https://example.com/image.jpg\"\n        }\n      ]\n    }\n  ];\n  \n  render(<Kanban columns={columnsWithImages} />);\n  \n  const image = screen.getByRole(\"img\");\n  expect(image).toHaveAttribute(\"src\", \"https://example.com/image.jpg\");\n});\n\ntest(\"renders custom content in cards\", () => {\n  const columnsWithCustomContent = [\n    {\n      id: \"custom\",\n      title: \"Custom\",\n      cards: [\n        {\n          id: \"custom-card\",\n          title: \"Custom Task\",\n          customContent: <div>Custom Content</div>\n        }\n      ]\n    }\n  ];\n  \n  render(<Kanban columns={columnsWithCustomContent} />);\n  \n  expect(screen.getByText(\"Custom Content\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface KanbanCard {\n  id: string;\n  title: string;\n  description?: string;\n  assignee?: string;\n  priority?: \"low\" | \"medium\" | \"high\" | \"urgent\";\n  tags?: string[];\n  dueDate?: Date;\n  coverImage?: string;\n  customContent?: React.ReactNode;\n}\n\nexport interface KanbanColumn {\n  id: string;\n  title: string;\n  cards: KanbanCard[];\n  color?: string;\n  limit?: number;\n  collapsed?: boolean;\n}\n\nexport interface KanbanProps extends React.HTMLAttributes<HTMLDivElement> {\n  columns: KanbanColumn[];\n  onCardMove?: (cardId: string, fromColumnId: string, toColumnId: string, newIndex: number) => void;\n  onColumnMove?: (columnId: string, newIndex: number) => void;\n  onCardClick?: (card: KanbanCard) => void;\n  onCardEdit?: (card: KanbanCard) => void;\n  onCardDelete?: (cardId: string) => void;\n  onAddCard?: (columnId: string) => void;\n  onAddColumn?: () => void;\n  cardRender?: (card: KanbanCard) => React.ReactNode;\n  columnHeaderRender?: (column: KanbanColumn) => React.ReactNode;\n  readonly?: boolean;\n  showColumnLimits?: boolean;\n  allowColumnCollapse?: boolean;\n}\n\nconst priorityColors = {\n  low: \"#52c41a\",\n  medium: \"#faad14\", \n  high: \"#fa541c\",\n  urgent: \"#f5222d\"\n};\n\nexport const Kanban = React.forwardRef<HTMLDivElement, KanbanProps>(\n  ({\n    columns,\n    onCardMove,\n    onColumnMove,\n    onCardClick,\n    onCardEdit,\n    onCardDelete,\n    onAddCard,\n    onAddColumn,\n    cardRender,\n    columnHeaderRender,\n    readonly = false,\n    showColumnLimits = true,\n    allowColumnCollapse = false,\n    className,\n    ...rest\n  }, ref) => {\n    const [draggedCard, setDraggedCard] = React.useState<{\n      card: KanbanCard;\n      fromColumnId: string;\n    } | null>(null);\n    const [draggedColumn, setDraggedColumn] = React.useState<string | null>(null);\n    const [dragOverColumn, setDragOverColumn] = React.useState<string | null>(null);\n    const [dragOverCardIndex, setDragOverCardIndex] = React.useState<number | null>(null);\n\n    const classes = `kanban ${readonly ? \"kanban-readonly\" : \"\"} ${className || \"\"}`.trim();\n\n    const handleCardDragStart = (e: React.DragEvent, card: KanbanCard, columnId: string) => {\n      if (readonly) return;\n      \n      setDraggedCard({ card, fromColumnId: columnId });\n      e.dataTransfer.effectAllowed = \"move\";\n      e.dataTransfer.setData(\"text/plain\", card.id);\n    };\n\n    const handleCardDragEnd = () => {\n      setDraggedCard(null);\n      setDragOverColumn(null);\n      setDragOverCardIndex(null);\n    };\n\n    const handleColumnDragStart = (e: React.DragEvent, columnId: string) => {\n      if (readonly) return;\n      \n      setDraggedColumn(columnId);\n      e.dataTransfer.effectAllowed = \"move\";\n      e.dataTransfer.setData(\"text/plain\", columnId);\n    };\n\n    const handleColumnDragEnd = () => {\n      setDraggedColumn(null);\n    };\n\n    const handleColumnDragOver = (e: React.DragEvent, columnId: string) => {\n      e.preventDefault();\n      e.dataTransfer.dropEffect = \"move\";\n      \n      if (draggedCard) {\n        setDragOverColumn(columnId);\n      }\n    };\n\n    const handleCardDragOver = (e: React.DragEvent, columnId: string, cardIndex: number) => {\n      e.preventDefault();\n      e.stopPropagation();\n      e.dataTransfer.dropEffect = \"move\";\n      \n      if (draggedCard) {\n        setDragOverColumn(columnId);\n        setDragOverCardIndex(cardIndex);\n      }\n    };\n\n    const handleColumnDrop = (e: React.DragEvent, targetColumnId: string) => {\n      e.preventDefault();\n      \n      if (draggedCard && onCardMove) {\n        const targetColumn = columns.find(col => col.id === targetColumnId);\n        const newIndex = targetColumn ? targetColumn.cards.length : 0;\n        \n        onCardMove(\n          draggedCard.card.id,\n          draggedCard.fromColumnId,\n          targetColumnId,\n          newIndex\n        );\n      }\n      \n      if (draggedColumn && onColumnMove) {\n        const targetIndex = columns.findIndex(col => col.id === targetColumnId);\n        onColumnMove(draggedColumn, targetIndex);\n      }\n      \n      setDraggedCard(null);\n      setDraggedColumn(null);\n      setDragOverColumn(null);\n      setDragOverCardIndex(null);\n    };\n\n    const handleCardDrop = (e: React.DragEvent, targetColumnId: string, targetIndex: number) => {\n      e.preventDefault();\n      e.stopPropagation();\n      \n      if (draggedCard && onCardMove) {\n        onCardMove(\n          draggedCard.card.id,\n          draggedCard.fromColumnId,\n          targetColumnId,\n          targetIndex\n        );\n      }\n      \n      setDraggedCard(null);\n      setDragOverColumn(null);\n      setDragOverCardIndex(null);\n    };\n\n    const handleCardClick = (card: KanbanCard) => {\n      if (onCardClick) {\n        onCardClick(card);\n      }\n    };\n\n    const handleCardEdit = (e: React.MouseEvent, card: KanbanCard) => {\n      e.stopPropagation();\n      if (onCardEdit) {\n        onCardEdit(card);\n      }\n    };\n\n    const handleCardDelete = (e: React.MouseEvent, cardId: string) => {\n      e.stopPropagation();\n      if (onCardDelete) {\n        onCardDelete(cardId);\n      }\n    };\n\n    const formatDate = (date: Date): string => {\n      return date.toLocaleDateString();\n    };\n\n    const isOverdue = (date: Date): boolean => {\n      return date < new Date();\n    };\n\n    const renderCard = (card: KanbanCard, columnId: string, index: number) => {\n      if (cardRender) {\n        return cardRender(card);\n      }\n\n      const isDragging = draggedCard?.card.id === card.id;\n      const isDragOver = dragOverColumn === columnId && dragOverCardIndex === index;\n\n      return (\n        <div\n          key={card.id}\n          className={`kanban-card ${isDragging ? \"kanban-card-dragging\" : \"\"} ${\n            isDragOver ? \"kanban-card-drag-over\" : \"\"\n          }`}\n          draggable={!readonly}\n          onDragStart={(e) => handleCardDragStart(e, card, columnId)}\n          onDragEnd={handleCardDragEnd}\n          onDragOver={(e) => handleCardDragOver(e, columnId, index)}\n          onDrop={(e) => handleCardDrop(e, columnId, index)}\n          onClick={() => handleCardClick(card)}\n          role=\"button\"\n          tabIndex={0}\n          aria-label={`Card: ${card.title}`}\n          onKeyDown={(e) => {\n            if (e.key === \"Enter\" || e.key === \" \") {\n              e.preventDefault();\n              handleCardClick(card);\n            }\n          }}\n        >\n          {card.coverImage && (\n            <div className=\"kanban-card-cover\">\n              <img src={card.coverImage} alt=\"\" />\n            </div>\n          )}\n          \n          <div className=\"kanban-card-content\">\n            <div className=\"kanban-card-header\">\n              <h4 className=\"kanban-card-title\">{card.title}</h4>\n              {!readonly && (\n                <div className=\"kanban-card-actions\">\n                  {onCardEdit && (\n                    <button\n                      type=\"button\"\n                      className=\"kanban-card-action\"\n                      onClick={(e) => handleCardEdit(e, card)}\n                      aria-label=\"Edit card\"\n                    >\n                      ✏️\n                    </button>\n                  )}\n                  {onCardDelete && (\n                    <button\n                      type=\"button\"\n                      className=\"kanban-card-action\"\n                      onClick={(e) => handleCardDelete(e, card.id)}\n                      aria-label=\"Delete card\"\n                    >\n                      🗑️\n                    </button>\n                  )}\n                </div>\n              )}\n            </div>\n            \n            {card.description && (\n              <p className=\"kanban-card-description\">{card.description}</p>\n            )}\n            \n            {card.customContent && (\n              <div className=\"kanban-card-custom\">{card.customContent}</div>\n            )}\n            \n            <div className=\"kanban-card-footer\">\n              {card.priority && (\n                <span\n                  className=\"kanban-card-priority\"\n                  style={{ backgroundColor: priorityColors[card.priority] }}\n                >\n                  {card.priority}\n                </span>\n              )}\n              \n              {card.assignee && (\n                <div className=\"kanban-card-assignee\" title={card.assignee}>\n                  {card.assignee.charAt(0).toUpperCase()}\n                </div>\n              )}\n              \n              {card.dueDate && (\n                <div\n                  className={`kanban-card-due-date ${\n                    isOverdue(card.dueDate) ? \"kanban-card-overdue\" : \"\"\n                  }`}\n                >\n                  📅 {formatDate(card.dueDate)}\n                </div>\n              )}\n            </div>\n            \n            {card.tags && card.tags.length > 0 && (\n              <div className=\"kanban-card-tags\">\n                {card.tags.map(tag => (\n                  <span key={tag} className=\"kanban-card-tag\">\n                    {tag}\n                  </span>\n                ))}\n              </div>\n            )}\n          </div>\n        </div>\n      );\n    };\n\n    const renderColumn = (column: KanbanColumn, index: number) => {\n      const isDragging = draggedColumn === column.id;\n      const isDragOver = dragOverColumn === column.id;\n      const isOverLimit = column.limit && column.cards.length > column.limit;\n\n      return (\n        <div\n          key={column.id}\n          className={`kanban-column ${isDragging ? \"kanban-column-dragging\" : \"\"} ${\n            isDragOver ? \"kanban-column-drag-over\" : \"\"\n          } ${isOverLimit ? \"kanban-column-over-limit\" : \"\"} ${\n            column.collapsed ? \"kanban-column-collapsed\" : \"\"\n          }`}\n          draggable={!readonly}\n          onDragStart={(e) => handleColumnDragStart(e, column.id)}\n          onDragEnd={handleColumnDragEnd}\n          onDragOver={(e) => handleColumnDragOver(e, column.id)}\n          onDrop={(e) => handleColumnDrop(e, column.id)}\n          style={{ borderTopColor: column.color }}\n        >\n          {columnHeaderRender ? columnHeaderRender(column) : (\n            <div className=\"kanban-column-header\">\n              <div className=\"kanban-column-title-section\">\n                <h3 className=\"kanban-column-title\">{column.title}</h3>\n                <span className=\"kanban-column-count\">\n                  {column.cards.length}\n                  {showColumnLimits && column.limit && ` / ${column.limit}`}\n                </span>\n              </div>\n              \n              <div className=\"kanban-column-actions\">\n                {allowColumnCollapse && (\n                  <button\n                    type=\"button\"\n                    className=\"kanban-column-action\"\n                    aria-label={column.collapsed ? \"Expand column\" : \"Collapse column\"}\n                  >\n                    {column.collapsed ? \"+\" : \"−\"}\n                  </button>\n                )}\n                \n                {onAddCard && !readonly && (\n                  <button\n                    type=\"button\"\n                    className=\"kanban-column-action\"\n                    onClick={() => onAddCard(column.id)}\n                    aria-label=\"Add card\"\n                  >\n                    +\n                  </button>\n                )}\n              </div>\n            </div>\n          )}\n          \n          {!column.collapsed && (\n            <div className=\"kanban-column-content\">\n              <div className=\"kanban-cards\">\n                {column.cards.map((card, cardIndex) => (\n                  <React.Fragment key={card.id}>\n                    {draggedCard && \n                     dragOverColumn === column.id && \n                     dragOverCardIndex === cardIndex && (\n                      <div className=\"kanban-card-drop-zone\" />\n                    )}\n                    {renderCard(card, column.id, cardIndex)}\n                  </React.Fragment>\n                ))}\n                \n                {draggedCard && \n                 dragOverColumn === column.id && \n                 (dragOverCardIndex === null || dragOverCardIndex >= column.cards.length) && (\n                  <div className=\"kanban-card-drop-zone\" />\n                )}\n              </div>\n            </div>\n          )}\n        </div>\n      );\n    };\n\n    return (\n      <div {...rest} ref={ref} className={classes}>\n        <div className=\"kanban-board\">\n          {columns.map((column, index) => renderColumn(column, index))}\n          \n          {onAddColumn && !readonly && (\n            <div className=\"kanban-add-column\">\n              <button\n                type=\"button\"\n                className=\"kanban-add-column-button\"\n                onClick={onAddColumn}\n                aria-label=\"Add column\"\n              >\n                + Add Column\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n);\nKanban.displayName = \"Kanban\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Kanban } from \"../Kanban\";\n\nconst mockColumns = [\n  {\n    id: \"todo\",\n    title: \"To Do\",\n    cards: [\n      {\n        id: \"card1\",\n        title: \"Task 1\",\n        description: \"First task\",\n        priority: \"high\" as const,\n        assignee: \"John Doe\",\n        tags: [\"urgent\", \"frontend\"]\n      },\n      {\n        id: \"card2\", \n        title: \"Task 2\",\n        dueDate: new Date(\"2024-12-01\")\n      }\n    ],\n    limit: 5\n  },\n  {\n    id: \"inprogress\",\n    title: \"In Progress\", \n    cards: [\n      {\n        id: \"card3\",\n        title: \"Task 3\",\n        description: \"Task in progress\"\n      }\n    ]\n  },\n  {\n    id: \"done\",\n    title: \"Done\",\n    cards: []\n  }\n];\n\ntest(\"renders kanban board with columns\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"To Do\")).toBeInTheDocument();\n  expect(screen.getByText(\"In Progress\")).toBeInTheDocument();\n  expect(screen.getByText(\"Done\")).toBeInTheDocument();\n});\n\ntest(\"renders cards in columns\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"Task 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Task 2\")).toBeInTheDocument();\n  expect(screen.getByText(\"Task 3\")).toBeInTheDocument();\n});\n\ntest(\"shows card details\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"First task\")).toBeInTheDocument();\n  expect(screen.getByText(\"high\")).toBeInTheDocument();\n  expect(screen.getByText(\"urgent\")).toBeInTheDocument();\n  expect(screen.getByText(\"frontend\")).toBeInTheDocument();\n});\n\ntest(\"shows column counts\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"2\")).toBeInTheDocument(); // To Do count\n  expect(screen.getByText(\"1\")).toBeInTheDocument(); // In Progress count\n  expect(screen.getByText(\"0\")).toBeInTheDocument(); // Done count\n});\n\ntest(\"shows column limits when enabled\", () => {\n  render(<Kanban columns={mockColumns} showColumnLimits />);\n  \n  expect(screen.getByText(\"2 / 5\")).toBeInTheDocument(); // To Do with limit\n});\n\ntest(\"handles card clicks\", async () => {\n  const user = userEvent.setup();\n  const onCardClick = vi.fn();\n  render(<Kanban columns={mockColumns} onCardClick={onCardClick} />);\n  \n  await user.click(screen.getByText(\"Task 1\"));\n  expect(onCardClick).toHaveBeenCalledWith(mockColumns[0].cards[0]);\n});\n\ntest(\"shows card actions when not readonly\", () => {\n  render(<Kanban columns={mockColumns} onCardEdit={vi.fn()} onCardDelete={vi.fn()} />);\n  \n  expect(screen.getAllByLabelText(\"Edit card\")).toHaveLength(3);\n  expect(screen.getAllByLabelText(\"Delete card\")).toHaveLength(3);\n});\n\ntest(\"handles card edit\", async () => {\n  const user = userEvent.setup();\n  const onCardEdit = vi.fn();\n  render(<Kanban columns={mockColumns} onCardEdit={onCardEdit} />);\n  \n  const editButtons = screen.getAllByLabelText(\"Edit card\");\n  await user.click(editButtons[0]);\n  \n  expect(onCardEdit).toHaveBeenCalledWith(mockColumns[0].cards[0]);\n});\n\ntest(\"handles card delete\", async () => {\n  const user = userEvent.setup();\n  const onCardDelete = vi.fn();\n  render(<Kanban columns={mockColumns} onCardDelete={onCardDelete} />);\n  \n  const deleteButtons = screen.getAllByLabelText(\"Delete card\");\n  await user.click(deleteButtons[0]);\n  \n  expect(onCardDelete).toHaveBeenCalledWith(\"card1\");\n});\n\ntest(\"shows add card button\", () => {\n  render(<Kanban columns={mockColumns} onAddCard={vi.fn()} />);\n  \n  expect(screen.getAllByLabelText(\"Add card\")).toHaveLength(3);\n});\n\ntest(\"handles add card\", async () => {\n  const user = userEvent.setup();\n  const onAddCard = vi.fn();\n  render(<Kanban columns={mockColumns} onAddCard={onAddCard} />);\n  \n  const addButtons = screen.getAllByLabelText(\"Add card\");\n  await user.click(addButtons[0]);\n  \n  expect(onAddCard).toHaveBeenCalledWith(\"todo\");\n});\n\ntest(\"shows add column button\", () => {\n  render(<Kanban columns={mockColumns} onAddColumn={vi.fn()} />);\n  \n  expect(screen.getByText(\"+ Add Column\")).toBeInTheDocument();\n});\n\ntest(\"handles add column\", async () => {\n  const user = userEvent.setup();\n  const onAddColumn = vi.fn();\n  render(<Kanban columns={mockColumns} onAddColumn={onAddColumn} />);\n  \n  await user.click(screen.getByText(\"+ Add Column\"));\n  expect(onAddColumn).toHaveBeenCalled();\n});\n\ntest(\"shows assignee initials\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"J\")).toBeInTheDocument(); // John Doe's initial\n});\n\ntest(\"shows due dates\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(/12\\/1\\/2024/)).toBeInTheDocument();\n});\n\ntest(\"highlights overdue tasks\", () => {\n  const overdueColumns = [\n    {\n      id: \"overdue\",\n      title: \"Overdue\",\n      cards: [\n        {\n          id: \"overdue1\",\n          title: \"Overdue Task\",\n          dueDate: new Date(\"2020-01-01\") // Past date\n        }\n      ]\n    }\n  ];\n  \n  render(<Kanban columns={overdueColumns} />);\n  \n  const dueDateElement = screen.getByText(/1\\/1\\/2020/).closest('.kanban-card-due-date');\n  expect(dueDateElement).toHaveClass(\"kanban-card-overdue\");\n});\n\ntest(\"is readonly when readonly prop is true\", () => {\n  render(<Kanban columns={mockColumns} readonly onCardEdit={vi.fn()} onCardDelete={vi.fn()} />);\n  \n  expect(screen.queryByLabelText(\"Edit card\")).not.toBeInTheDocument();\n  expect(screen.queryByLabelText(\"Delete card\")).not.toBeInTheDocument();\n});\n\ntest(\"shows priority colors\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  const priorityElement = screen.getByText(\"high\");\n  expect(priorityElement).toHaveStyle({ backgroundColor: \"#fa541c\" });\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  const onCardClick = vi.fn();\n  render(<Kanban columns={mockColumns} onCardClick={onCardClick} />);\n  \n  const card = screen.getByLabelText(\"Card: Task 1\");\n  card.focus();\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onCardClick).toHaveBeenCalledWith(mockColumns[0].cards[0]);\n});\n\ntest(\"uses custom card renderer\", () => {\n  const cardRender = (card: any) => <div>Custom {card.title}</div>;\n  render(<Kanban columns={mockColumns} cardRender={cardRender} />);\n  \n  expect(screen.getByText(\"Custom Task 1\")).toBeInTheDocument();\n});\n\ntest(\"uses custom column header renderer\", () => {\n  const columnHeaderRender = (column: any) => <div>Custom {column.title}</div>;\n  render(<Kanban columns={mockColumns} columnHeaderRender={columnHeaderRender} />);\n  \n  expect(screen.getByText(\"Custom To Do\")).toBeInTheDocument();\n});\n\ntest(\"shows collapsed columns\", () => {\n  const collapsedColumns = [\n    { ...mockColumns[0], collapsed: true }\n  ];\n  \n  render(<Kanban columns={collapsedColumns} allowColumnCollapse />);\n  \n  const column = screen.getByText(\"To Do\").closest(\".kanban-column\");\n  expect(column).toHaveClass(\"kanban-column-collapsed\");\n});\n\ntest(\"shows over-limit styling\", () => {\n  const overLimitColumns = [\n    {\n      ...mockColumns[0],\n      limit: 1, // Less than current card count (2)\n    }\n  ];\n  \n  render(<Kanban columns={overLimitColumns} />);\n  \n  const column = screen.getByText(\"To Do\").closest(\".kanban-column\");\n  expect(column).toHaveClass(\"kanban-column-over-limit\");\n});\n\ntest(\"handles drag and drop operations\", () => {\n  const onCardMove = vi.fn();\n  render(<Kanban columns={mockColumns} onCardMove={onCardMove} />);\n  \n  const cards = screen.getAllByRole(\"button\");\n  const firstCard = cards.find(card => card.getAttribute(\"aria-label\")?.includes(\"Task 1\"));\n  \n  expect(firstCard).toHaveAttribute(\"draggable\", \"true\");\n});\n\ntest(\"renders cover images\", () => {\n  const columnsWithImages = [\n    {\n      id: \"visual\",\n      title: \"Visual\",\n      cards: [\n        {\n          id: \"card-with-image\",\n          title: \"Visual Task\",\n          coverImage: \"https://example.com/image.jpg\"\n        }\n      ]\n    }\n  ];\n  \n  render(<Kanban columns={columnsWithImages} />);\n  \n  const image = screen.getByRole(\"img\");\n  expect(image).toHaveAttribute(\"src\", \"https://example.com/image.jpg\");\n});\n\ntest(\"renders custom content in cards\", () => {\n  const columnsWithCustomContent = [\n    {\n      id: \"custom\",\n      title: \"Custom\",\n      cards: [\n        {\n          id: \"custom-card\",\n          title: \"Custom Task\",\n          customContent: <div>Custom Content</div>\n        }\n      ]\n    }\n  ];\n  \n  render(<Kanban columns={columnsWithCustomContent} />);\n  \n  expect(screen.getByText(\"Custom Content\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface KanbanCard {\n  id: string;\n  title: string;\n  description?: string;\n  assignee?: string;\n  priority?: \"low\" | \"medium\" | \"high\" | \"urgent\";\n  tags?: string[];\n  dueDate?: Date;\n  coverImage?: string;\n  customContent?: React.ReactNode;\n}\n\nexport interface KanbanColumn {\n  id: string;\n  title: string;\n  cards: KanbanCard[];\n  color?: string;\n  limit?: number;\n  collapsed?: boolean;\n}\n\nexport interface KanbanProps extends React.HTMLAttributes<HTMLDivElement> {\n  columns: KanbanColumn[];\n  onCardMove?: (cardId: string, fromColumnId: string, toColumnId: string, newIndex: number) => void;\n  onColumnMove?: (columnId: string, newIndex: number) => void;\n  onCardClick?: (card: KanbanCard) => void;\n  onCardEdit?: (card: KanbanCard) => void;\n  onCardDelete?: (cardId: string) => void;\n  onAddCard?: (columnId: string) => void;\n  onAddColumn?: () => void;\n  cardRender?: (card: KanbanCard) => React.ReactNode;\n  columnHeaderRender?: (column: KanbanColumn) => React.ReactNode;\n  readonly?: boolean;\n  showColumnLimits?: boolean;\n  allowColumnCollapse?: boolean;\n}\n\nconst priorityColors = {\n  low: \"#52c41a\",\n  medium: \"#faad14\", \n  high: \"#fa541c\",\n  urgent: \"#f5222d\"\n};\n\nexport const Kanban = React.forwardRef<HTMLDivElement, KanbanProps>(\n  ({\n    columns,\n    onCardMove,\n    onColumnMove,\n    onCardClick,\n    onCardEdit,\n    onCardDelete,\n    onAddCard,\n    onAddColumn,\n    cardRender,\n    columnHeaderRender,\n    readonly = false,\n    showColumnLimits = true,\n    allowColumnCollapse = false,\n    className,\n    ...rest\n  }, ref) => {\n    const [draggedCard, setDraggedCard] = React.useState<{\n      card: KanbanCard;\n      fromColumnId: string;\n    } | null>(null);\n    const [draggedColumn, setDraggedColumn] = React.useState<string | null>(null);\n    const [dragOverColumn, setDragOverColumn] = React.useState<string | null>(null);\n    const [dragOverCardIndex, setDragOverCardIndex] = React.useState<number | null>(null);\n\n    const classes = `kanban ${readonly ? \"kanban-readonly\" : \"\"} ${className || \"\"}`.trim();\n\n    const handleCardDragStart = (e: React.DragEvent, card: KanbanCard, columnId: string) => {\n      if (readonly) return;\n      \n      setDraggedCard({ card, fromColumnId: columnId });\n      e.dataTransfer.effectAllowed = \"move\";\n      e.dataTransfer.setData(\"text/plain\", card.id);\n    };\n\n    const handleCardDragEnd = () => {\n      setDraggedCard(null);\n      setDragOverColumn(null);\n      setDragOverCardIndex(null);\n    };\n\n    const handleColumnDragStart = (e: React.DragEvent, columnId: string) => {\n      if (readonly) return;\n      \n      setDraggedColumn(columnId);\n      e.dataTransfer.effectAllowed = \"move\";\n      e.dataTransfer.setData(\"text/plain\", columnId);\n    };\n\n    const handleColumnDragEnd = () => {\n      setDraggedColumn(null);\n    };\n\n    const handleColumnDragOver = (e: React.DragEvent, columnId: string) => {\n      e.preventDefault();\n      e.dataTransfer.dropEffect = \"move\";\n      \n      if (draggedCard) {\n        setDragOverColumn(columnId);\n      }\n    };\n\n    const handleCardDragOver = (e: React.DragEvent, columnId: string, cardIndex: number) => {\n      e.preventDefault();\n      e.stopPropagation();\n      e.dataTransfer.dropEffect = \"move\";\n      \n      if (draggedCard) {\n        setDragOverColumn(columnId);\n        setDragOverCardIndex(cardIndex);\n      }\n    };\n\n    const handleColumnDrop = (e: React.DragEvent, targetColumnId: string) => {\n      e.preventDefault();\n      \n      if (draggedCard && onCardMove) {\n        const targetColumn = columns.find(col => col.id === targetColumnId);\n        const newIndex = targetColumn ? targetColumn.cards.length : 0;\n        \n        onCardMove(\n          draggedCard.card.id,\n          draggedCard.fromColumnId,\n          targetColumnId,\n          newIndex\n        );\n      }\n      \n      if (draggedColumn && onColumnMove) {\n        const targetIndex = columns.findIndex(col => col.id === targetColumnId);\n        onColumnMove(draggedColumn, targetIndex);\n      }\n      \n      setDraggedCard(null);\n      setDraggedColumn(null);\n      setDragOverColumn(null);\n      setDragOverCardIndex(null);\n    };\n\n    const handleCardDrop = (e: React.DragEvent, targetColumnId: string, targetIndex: number) => {\n      e.preventDefault();\n      e.stopPropagation();\n      \n      if (draggedCard && onCardMove) {\n        onCardMove(\n          draggedCard.card.id,\n          draggedCard.fromColumnId,\n          targetColumnId,\n          targetIndex\n        );\n      }\n      \n      setDraggedCard(null);\n      setDragOverColumn(null);\n      setDragOverCardIndex(null);\n    };\n\n    const handleCardClick = (card: KanbanCard) => {\n      if (onCardClick) {\n        onCardClick(card);\n      }\n    };\n\n    const handleCardEdit = (e: React.MouseEvent, card: KanbanCard) => {\n      e.stopPropagation();\n      if (onCardEdit) {\n        onCardEdit(card);\n      }\n    };\n\n    const handleCardDelete = (e: React.MouseEvent, cardId: string) => {\n      e.stopPropagation();\n      if (onCardDelete) {\n        onCardDelete(cardId);\n      }\n    };\n\n    const formatDate = (date: Date): string => {\n      return date.toLocaleDateString();\n    };\n\n    const isOverdue = (date: Date): boolean => {\n      return date < new Date();\n    };\n\n    const renderCard = (card: KanbanCard, columnId: string, index: number) => {\n      if (cardRender) {\n        return cardRender(card);\n      }\n\n      const isDragging = draggedCard?.card.id === card.id;\n      const isDragOver = dragOverColumn === columnId && dragOverCardIndex === index;\n\n      return (\n        <div\n          key={card.id}\n          className={`kanban-card ${isDragging ? \"kanban-card-dragging\" : \"\"} ${\n            isDragOver ? \"kanban-card-drag-over\" : \"\"\n          }`}\n          draggable={!readonly}\n          onDragStart={(e) => handleCardDragStart(e, card, columnId)}\n          onDragEnd={handleCardDragEnd}\n          onDragOver={(e) => handleCardDragOver(e, columnId, index)}\n          onDrop={(e) => handleCardDrop(e, columnId, index)}\n          onClick={() => handleCardClick(card)}\n          role=\"button\"\n          tabIndex={0}\n          aria-label={`Card: ${card.title}`}\n          onKeyDown={(e) => {\n            if (e.key === \"Enter\" || e.key === \" \") {\n              e.preventDefault();\n              handleCardClick(card);\n            }\n          }}\n        >\n          {card.coverImage && (\n            <div className=\"kanban-card-cover\">\n              <img src={card.coverImage} alt=\"\" />\n            </div>\n          )}\n          \n          <div className=\"kanban-card-content\">\n            <div className=\"kanban-card-header\">\n              <h4 className=\"kanban-card-title\">{card.title}</h4>\n              {!readonly && (\n                <div className=\"kanban-card-actions\">\n                  {onCardEdit && (\n                    <button\n                      type=\"button\"\n                      className=\"kanban-card-action\"\n                      onClick={(e) => handleCardEdit(e, card)}\n                      aria-label=\"Edit card\"\n                    >\n                      ✏️\n                    </button>\n                  )}\n                  {onCardDelete && (\n                    <button\n                      type=\"button\"\n                      className=\"kanban-card-action\"\n                      onClick={(e) => handleCardDelete(e, card.id)}\n                      aria-label=\"Delete card\"\n                    >\n                      🗑️\n                    </button>\n                  )}\n                </div>\n              )}\n            </div>\n            \n            {card.description && (\n              <p className=\"kanban-card-description\">{card.description}</p>\n            )}\n            \n            {card.customContent && (\n              <div className=\"kanban-card-custom\">{card.customContent}</div>\n            )}\n            \n            <div className=\"kanban-card-footer\">\n              {card.priority && (\n                <span\n                  className=\"kanban-card-priority\"\n                  style={{ backgroundColor: priorityColors[card.priority] }}\n                >\n                  {card.priority}\n                </span>\n              )}\n              \n              {card.assignee && (\n                <div className=\"kanban-card-assignee\" title={card.assignee}>\n                  {card.assignee.charAt(0).toUpperCase()}\n                </div>\n              )}\n              \n              {card.dueDate && (\n                <div\n                  className={`kanban-card-due-date ${\n                    isOverdue(card.dueDate) ? \"kanban-card-overdue\" : \"\"\n                  }`}\n                >\n                  📅 {formatDate(card.dueDate)}\n                </div>\n              )}\n            </div>\n            \n            {card.tags && card.tags.length > 0 && (\n              <div className=\"kanban-card-tags\">\n                {card.tags.map(tag => (\n                  <span key={tag} className=\"kanban-card-tag\">\n                    {tag}\n                  </span>\n                ))}\n              </div>\n            )}\n          </div>\n        </div>\n      );\n    };\n\n    const renderColumn = (column: KanbanColumn, index: number) => {\n      const isDragging = draggedColumn === column.id;\n      const isDragOver = dragOverColumn === column.id;\n      const isOverLimit = column.limit && column.cards.length > column.limit;\n\n      return (\n        <div\n          key={column.id}\n          className={`kanban-column ${isDragging ? \"kanban-column-dragging\" : \"\"} ${\n            isDragOver ? \"kanban-column-drag-over\" : \"\"\n          } ${isOverLimit ? \"kanban-column-over-limit\" : \"\"} ${\n            column.collapsed ? \"kanban-column-collapsed\" : \"\"\n          }`}\n          draggable={!readonly}\n          onDragStart={(e) => handleColumnDragStart(e, column.id)}\n          onDragEnd={handleColumnDragEnd}\n          onDragOver={(e) => handleColumnDragOver(e, column.id)}\n          onDrop={(e) => handleColumnDrop(e, column.id)}\n          style={{ borderTopColor: column.color }}\n        >\n          {columnHeaderRender ? columnHeaderRender(column) : (\n            <div className=\"kanban-column-header\">\n              <div className=\"kanban-column-title-section\">\n                <h3 className=\"kanban-column-title\">{column.title}</h3>\n                <span className=\"kanban-column-count\">\n                  {column.cards.length}\n                  {showColumnLimits && column.limit && ` / ${column.limit}`}\n                </span>\n              </div>\n              \n              <div className=\"kanban-column-actions\">\n                {allowColumnCollapse && (\n                  <button\n                    type=\"button\"\n                    className=\"kanban-column-action\"\n                    aria-label={column.collapsed ? \"Expand column\" : \"Collapse column\"}\n                  >\n                    {column.collapsed ? \"+\" : \"−\"}\n                  </button>\n                )}\n                \n                {onAddCard && !readonly && (\n                  <button\n                    type=\"button\"\n                    className=\"kanban-column-action\"\n                    onClick={() => onAddCard(column.id)}\n                    aria-label=\"Add card\"\n                  >\n                    +\n                  </button>\n                )}\n              </div>\n            </div>\n          )}\n          \n          {!column.collapsed && (\n            <div className=\"kanban-column-content\">\n              <div className=\"kanban-cards\">\n                {column.cards.map((card, cardIndex) => (\n                  <React.Fragment key={card.id}>\n                    {draggedCard && \n                     dragOverColumn === column.id && \n                     dragOverCardIndex === cardIndex && (\n                      <div className=\"kanban-card-drop-zone\" />\n                    )}\n                    {renderCard(card, column.id, cardIndex)}\n                  </React.Fragment>\n                ))}\n                \n                {draggedCard && \n                 dragOverColumn === column.id && \n                 (dragOverCardIndex === null || dragOverCardIndex >= column.cards.length) && (\n                  <div className=\"kanban-card-drop-zone\" />\n                )}\n              </div>\n            </div>\n          )}\n        </div>\n      );\n    };\n\n    return (\n      <div {...rest} ref={ref} className={classes}>\n        <div className=\"kanban-board\">\n          {columns.map((column, index) => renderColumn(column, index))}\n          \n          {onAddColumn && !readonly && (\n            <div className=\"kanban-add-column\">\n              <button\n                type=\"button\"\n                className=\"kanban-add-column-button\"\n                onClick={onAddColumn}\n                aria-label=\"Add column\"\n              >\n                + Add Column\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  }\n);\nKanban.displayName = \"Kanban\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Kanban } from \"../Kanban\";\n\nconst mockColumns = [\n  {\n    id: \"todo\",\n    title: \"To Do\",\n    cards: [\n      {\n        id: \"card1\",\n        title: \"Task 1\",\n        description: \"First task\",\n        priority: \"high\" as const,\n        assignee: \"John Doe\",\n        tags: [\"urgent\", \"frontend\"]\n      },\n      {\n        id: \"card2\", \n        title: \"Task 2\",\n        dueDate: new Date(\"2024-12-01\")\n      }\n    ],\n    limit: 5\n  },\n  {\n    id: \"inprogress\",\n    title: \"In Progress\", \n    cards: [\n      {\n        id: \"card3\",\n        title: \"Task 3\",\n        description: \"Task in progress\"\n      }\n    ]\n  },\n  {\n    id: \"done\",\n    title: \"Done\",\n    cards: []\n  }\n];\n\ntest(\"renders kanban board with columns\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"To Do\")).toBeInTheDocument();\n  expect(screen.getByText(\"In Progress\")).toBeInTheDocument();\n  expect(screen.getByText(\"Done\")).toBeInTheDocument();\n});\n\ntest(\"renders cards in columns\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"Task 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Task 2\")).toBeInTheDocument();\n  expect(screen.getByText(\"Task 3\")).toBeInTheDocument();\n});\n\ntest(\"shows card details\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"First task\")).toBeInTheDocument();\n  expect(screen.getByText(\"high\")).toBeInTheDocument();\n  expect(screen.getByText(\"urgent\")).toBeInTheDocument();\n  expect(screen.getByText(\"frontend\")).toBeInTheDocument();\n});\n\ntest(\"shows column counts\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"2\")).toBeInTheDocument(); // To Do count\n  expect(screen.getByText(\"1\")).toBeInTheDocument(); // In Progress count\n  expect(screen.getByText(\"0\")).toBeInTheDocument(); // Done count\n});\n\ntest(\"shows column limits when enabled\", () => {\n  render(<Kanban columns={mockColumns} showColumnLimits />);\n  \n  expect(screen.getByText(\"2 / 5\")).toBeInTheDocument(); // To Do with limit\n});\n\ntest(\"handles card clicks\", async () => {\n  const user = userEvent.setup();\n  const onCardClick = vi.fn();\n  render(<Kanban columns={mockColumns} onCardClick={onCardClick} />);\n  \n  await user.click(screen.getByText(\"Task 1\"));\n  expect(onCardClick).toHaveBeenCalledWith(mockColumns[0].cards[0]);\n});\n\ntest(\"shows card actions when not readonly\", () => {\n  render(<Kanban columns={mockColumns} onCardEdit={vi.fn()} onCardDelete={vi.fn()} />);\n  \n  expect(screen.getAllByLabelText(\"Edit card\")).toHaveLength(3);\n  expect(screen.getAllByLabelText(\"Delete card\")).toHaveLength(3);\n});\n\ntest(\"handles card edit\", async () => {\n  const user = userEvent.setup();\n  const onCardEdit = vi.fn();\n  render(<Kanban columns={mockColumns} onCardEdit={onCardEdit} />);\n  \n  const editButtons = screen.getAllByLabelText(\"Edit card\");\n  await user.click(editButtons[0]);\n  \n  expect(onCardEdit).toHaveBeenCalledWith(mockColumns[0].cards[0]);\n});\n\ntest(\"handles card delete\", async () => {\n  const user = userEvent.setup();\n  const onCardDelete = vi.fn();\n  render(<Kanban columns={mockColumns} onCardDelete={onCardDelete} />);\n  \n  const deleteButtons = screen.getAllByLabelText(\"Delete card\");\n  await user.click(deleteButtons[0]);\n  \n  expect(onCardDelete).toHaveBeenCalledWith(\"card1\");\n});\n\ntest(\"shows add card button\", () => {\n  render(<Kanban columns={mockColumns} onAddCard={vi.fn()} />);\n  \n  expect(screen.getAllByLabelText(\"Add card\")).toHaveLength(3);\n});\n\ntest(\"handles add card\", async () => {\n  const user = userEvent.setup();\n  const onAddCard = vi.fn();\n  render(<Kanban columns={mockColumns} onAddCard={onAddCard} />);\n  \n  const addButtons = screen.getAllByLabelText(\"Add card\");\n  await user.click(addButtons[0]);\n  \n  expect(onAddCard).toHaveBeenCalledWith(\"todo\");\n});\n\ntest(\"shows add column button\", () => {\n  render(<Kanban columns={mockColumns} onAddColumn={vi.fn()} />);\n  \n  expect(screen.getByText(\"+ Add Column\")).toBeInTheDocument();\n});\n\ntest(\"handles add column\", async () => {\n  const user = userEvent.setup();\n  const onAddColumn = vi.fn();\n  render(<Kanban columns={mockColumns} onAddColumn={onAddColumn} />);\n  \n  await user.click(screen.getByText(\"+ Add Column\"));\n  expect(onAddColumn).toHaveBeenCalled();\n});\n\ntest(\"shows assignee initials\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(\"J\")).toBeInTheDocument(); // John Doe's initial\n});\n\ntest(\"shows due dates\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  expect(screen.getByText(/12\\/1\\/2024/)).toBeInTheDocument();\n});\n\ntest(\"highlights overdue tasks\", () => {\n  const overdueColumns = [\n    {\n      id: \"overdue\",\n      title: \"Overdue\",\n      cards: [\n        {\n          id: \"overdue1\",\n          title: \"Overdue Task\",\n          dueDate: new Date(\"2020-01-01\") // Past date\n        }\n      ]\n    }\n  ];\n  \n  render(<Kanban columns={overdueColumns} />);\n  \n  const dueDateElement = screen.getByText(/1\\/1\\/2020/).closest('.kanban-card-due-date');\n  expect(dueDateElement).toHaveClass(\"kanban-card-overdue\");\n});\n\ntest(\"is readonly when readonly prop is true\", () => {\n  render(<Kanban columns={mockColumns} readonly onCardEdit={vi.fn()} onCardDelete={vi.fn()} />);\n  \n  expect(screen.queryByLabelText(\"Edit card\")).not.toBeInTheDocument();\n  expect(screen.queryByLabelText(\"Delete card\")).not.toBeInTheDocument();\n});\n\ntest(\"shows priority colors\", () => {\n  render(<Kanban columns={mockColumns} />);\n  \n  const priorityElement = screen.getByText(\"high\");\n  expect(priorityElement).toHaveStyle({ backgroundColor: \"#fa541c\" });\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  const onCardClick = vi.fn();\n  render(<Kanban columns={mockColumns} onCardClick={onCardClick} />);\n  \n  const card = screen.getByLabelText(\"Card: Task 1\");\n  card.focus();\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onCardClick).toHaveBeenCalledWith(mockColumns[0].cards[0]);\n});\n\ntest(\"uses custom card renderer\", () => {\n  const cardRender = (card: any) => <div>Custom {card.title}</div>;\n  render(<Kanban columns={mockColumns} cardRender={cardRender} />);\n  \n  expect(screen.getByText(\"Custom Task 1\")).toBeInTheDocument();\n});\n\ntest(\"uses custom column header renderer\", () => {\n  const columnHeaderRender = (column: any) => <div>Custom {column.title}</div>;\n  render(<Kanban columns={mockColumns} columnHeaderRender={columnHeaderRender} />);\n  \n  expect(screen.getByText(\"Custom To Do\")).toBeInTheDocument();\n});\n\ntest(\"shows collapsed columns\", () => {\n  const collapsedColumns = [\n    { ...mockColumns[0], collapsed: true }\n  ];\n  \n  render(<Kanban columns={collapsedColumns} allowColumnCollapse />);\n  \n  const column = screen.getByText(\"To Do\").closest(\".kanban-column\");\n  expect(column).toHaveClass(\"kanban-column-collapsed\");\n});\n\ntest(\"shows over-limit styling\", () => {\n  const overLimitColumns = [\n    {\n      ...mockColumns[0],\n      limit: 1, // Less than current card count (2)\n    }\n  ];\n  \n  render(<Kanban columns={overLimitColumns} />);\n  \n  const column = screen.getByText(\"To Do\").closest(\".kanban-column\");\n  expect(column).toHaveClass(\"kanban-column-over-limit\");\n});\n\ntest(\"handles drag and drop operations\", () => {\n  const onCardMove = vi.fn();\n  render(<Kanban columns={mockColumns} onCardMove={onCardMove} />);\n  \n  const cards = screen.getAllByRole(\"button\");\n  const firstCard = cards.find(card => card.getAttribute(\"aria-label\")?.includes(\"Task 1\"));\n  \n  expect(firstCard).toHaveAttribute(\"draggable\", \"true\");\n});\n\ntest(\"renders cover images\", () => {\n  const columnsWithImages = [\n    {\n      id: \"visual\",\n      title: \"Visual\",\n      cards: [\n        {\n          id: \"card-with-image\",\n          title: \"Visual Task\",\n          coverImage: \"https://example.com/image.jpg\"\n        }\n      ]\n    }\n  ];\n  \n  render(<Kanban columns={columnsWithImages} />);\n  \n  const image = screen.getByRole(\"img\");\n  expect(image).toHaveAttribute(\"src\", \"https://example.com/image.jpg\");\n});\n\ntest(\"renders custom content in cards\", () => {\n  const columnsWithCustomContent = [\n    {\n      id: \"custom\",\n      title: \"Custom\",\n      cards: [\n        {\n          id: \"custom-card\",\n          title: \"Custom Task\",\n          customContent: <div>Custom Content</div>\n        }\n      ]\n    }\n  ];\n  \n  render(<Kanban columns={columnsWithCustomContent} />);\n  \n  expect(screen.getByText(\"Custom Content\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface NotificationItem {\n  id: string;\n  title: string;\n  message?: string;\n  type?: \"info\" | \"success\" | \"warning\" | \"error\";\n  duration?: number;\n  closable?: boolean;\n  icon?: React.ReactNode;\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n  onClose?: () => void;\n}\n\nexport interface NotificationProps {\n  placement?: \"topLeft\" | \"topRight\" | \"bottomLeft\" | \"bottomRight\" | \"top\" | \"bottom\";\n  maxCount?: number;\n  zIndex?: number;\n}\n\n// Global notification manager\nclass NotificationManager {\n  private notifications: NotificationItem[] = [];\n  private listeners: ((notifications: NotificationItem[]) => void)[] = [];\n  private defaultDuration = 4500;\n\n  subscribe(listener: (notifications: NotificationItem[]) => void) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter(l => l !== listener);\n    };\n  }\n\n  notify() {\n    this.listeners.forEach(listener => listener([...this.notifications]));\n  }\n\n  add(notification: Omit<NotificationItem, \"id\">): string {\n    const id = `notification-${Date.now()}-${Math.random()}`;\n    const item: NotificationItem = {\n      ...notification,\n      id,\n      duration: notification.duration ?? this.defaultDuration,\n    };\n\n    this.notifications.push(item);\n    this.notify();\n\n    // Auto remove after duration\n    if (item.duration > 0) {\n      setTimeout(() => {\n        this.remove(id);\n      }, item.duration);\n    }\n\n    return id;\n  }\n\n  remove(id: string) {\n    const notification = this.notifications.find(n => n.id === id);\n    this.notifications = this.notifications.filter(n => n.id !== id);\n    \n    if (notification?.onClose) {\n      notification.onClose();\n    }\n    \n    this.notify();\n  }\n\n  clear() {\n    this.notifications = [];\n    this.notify();\n  }\n\n  // Convenience methods\n  info(title: string, message?: string, options?: Partial<NotificationItem>) {\n    return this.add({ title, message, type: \"info\", ...options });\n  }\n\n  success(title: string, message?: string, options?: Partial<NotificationItem>) {\n    return this.add({ title, message, type: \"success\", ...options });\n  }\n\n  warning(title: string, message?: string, options?: Partial<NotificationItem>) {\n    return this.add({ title, message, type: \"warning\", ...options });\n  }\n\n  error(title: string, message?: string, options?: Partial<NotificationItem>) {\n    return this.add({ title, message, type: \"error\", ...options });\n  }\n}\n\nconst notificationManager = new NotificationManager();\n\n// Individual notification component\nconst NotificationCard: React.FC<{\n  notification: NotificationItem;\n  onClose: (id: string) => void;\n}> = ({ notification, onClose }) => {\n  const [isVisible, setIsVisible] = React.useState(false);\n  const [isLeaving, setIsLeaving] = React.useState(false);\n\n  React.useEffect(() => {\n    // Trigger entrance animation\n    const timer = setTimeout(() => setIsVisible(true), 10);\n    return () => clearTimeout(timer);\n  }, []);\n\n  const handleClose = () => {\n    setIsLeaving(true);\n    setTimeout(() => {\n      onClose(notification.id);\n    }, 300); // Match CSS animation duration\n  };\n\n  const getIcon = () => {\n    if (notification.icon) return notification.icon;\n    \n    switch (notification.type) {\n      case \"success\": return \"✅\";\n      case \"warning\": return \"⚠️\";\n      case \"error\": return \"❌\";\n      default: return \"ℹ️\";\n    }\n  };\n\n  const classes = `notification-card notification-${notification.type || \"info\"} ${n    isVisible ? \"notification-enter\" : \"\"\n  } ${isLeaving ? \"notification-exit\" : \"\"}`.trim();\n\n  return (\n    <div className={classes} role=\"alert\" aria-live=\"polite\">\n      <div className=\"notification-icon\">\n        {getIcon()}\n      </div>\n      \n      <div className=\"notification-content\">\n        <div className=\"notification-title\">{notification.title}</div>\n        {notification.message && (\n          <div className=\"notification-message\">{notification.message}</div>\n        )}\n        \n        {notification.action && (\n          <div className=\"notification-actions\">\n            <button\n              type=\"button\"\n              className=\"notification-action-button\"\n              onClick={notification.action.onClick}\n            >\n              {notification.action.label}\n            </button>\n          </div>\n        )}\n      </div>\n      \n      {notification.closable !== false && (\n        <button\n          type=\"button\"\n          className=\"notification-close\"\n          onClick={handleClose}\n          aria-label=\"Close notification\"\n        >\n          ×\n        </button>\n      )}\n    </div>\n  );\n};\n\n// Main notification container component\nexport const Notification: React.FC<NotificationProps> = ({\n  placement = \"topRight\",\n  maxCount = 10,\n  zIndex = 1000,\n}) => {\n  const [notifications, setNotifications] = React.useState<NotificationItem[]>([]);\n\n  React.useEffect(() => {\n    return notificationManager.subscribe(setNotifications);\n  }, []);\n\n  const handleClose = (id: string) => {\n    notificationManager.remove(id);\n  };\n\n  const displayedNotifications = maxCount \n    ? notifications.slice(-maxCount)\n    : notifications;\n\n  const containerClasses = `notification-container notification-${placement}`;\n  \n  const containerStyle: React.CSSProperties = {\n    zIndex,\n  };\n\n  if (displayedNotifications.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className={containerClasses} style={containerStyle}>\n      {displayedNotifications.map(notification => (\n        <NotificationCard\n          key={notification.id}\n          notification={notification}\n          onClose={handleClose}\n        />\n      ))}\n    </div>\n  );\n};\n\n// Hook for using notifications\nexport const useNotification = () => {\n  return {\n    info: notificationManager.info.bind(notificationManager),\n    success: notificationManager.success.bind(notificationManager),\n    warning: notificationManager.warning.bind(notificationManager),\n    error: notificationManager.error.bind(notificationManager),\n    open: notificationManager.add.bind(notificationManager),\n    close: notificationManager.remove.bind(notificationManager),\n    clear: notificationManager.clear.bind(notificationManager),\n  };\n};\n\n// Static methods for imperative usage\nNotification.info = notificationManager.info.bind(notificationManager);\nNotification.success = notificationManager.success.bind(notificationManager);\nNotification.warning = notificationManager.warning.bind(notificationManager);\nNotification.error = notificationManager.error.bind(notificationManager);\nNotification.open = notificationManager.add.bind(notificationManager);\nNotification.close = notificationManager.remove.bind(notificationManager);\nNotification.clear = notificationManager.clear.bind(notificationManager);\n\nNotification.displayName = \"Notification\";",
    "output": "import { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Notification, useNotification } from \"../Notification\";\n\n// Test component that uses the hook\nconst TestComponent = () => {\n  const notification = useNotification();\n  \n  return (\n    <div>\n      <button onClick={() => notification.info(\"Info\", \"Info message\")}>\n        Show Info\n      </button>\n      <button onClick={() => notification.success(\"Success\", \"Success message\")}>\n        Show Success\n      </button>\n      <button onClick={() => notification.warning(\"Warning\", \"Warning message\")}>\n        Show Warning\n      </button>\n      <button onClick={() => notification.error(\"Error\", \"Error message\")}>\n        Show Error\n      </button>\n      <button onClick={() => notification.clear()}>\n        Clear All\n      </button>\n    </div>\n  );\n};\n\n// Test wrapper component\nconst TestWrapper = () => {\n  return (\n    <>\n      <TestComponent />\n      <Notification />\n    </>\n  );\n};\n\nbeforeEach(() => {\n  // Clear any existing notifications before each test\n  Notification.clear();\n});\n\ntest(\"renders notification container\", () => {\n  render(<Notification />);\n  // Container only renders when there are notifications\n  expect(document.querySelector(\".notification-container\")).not.toBeInTheDocument();\n});\n\ntest(\"shows info notification\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Info\"));\n  \n  expect(screen.getByText(\"Info\")).toBeInTheDocument();\n  expect(screen.getByText(\"Info message\")).toBeInTheDocument();\n  expect(screen.getByText(\"ℹ️\")).toBeInTheDocument();\n});\n\ntest(\"shows success notification\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Success\"));\n  \n  expect(screen.getByText(\"Success\")).toBeInTheDocument();\n  expect(screen.getByText(\"Success message\")).toBeInTheDocument();\n  expect(screen.getByText(\"✅\")).toBeInTheDocument();\n});\n\ntest(\"shows warning notification\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Warning\"));\n  \n  expect(screen.getByText(\"Warning\")).toBeInTheDocument();\n  expect(screen.getByText(\"Warning message\")).toBeInTheDocument();\n  expect(screen.getByText(\"⚠️\")).toBeInTheDocument();\n});\n\ntest(\"shows error notification\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Error\"));\n  \n  expect(screen.getByText(\"Error\")).toBeInTheDocument();\n  expect(screen.getByText(\"Error message\")).toBeInTheDocument();\n  expect(screen.getByText(\"❌\")).toBeInTheDocument();\n});\n\ntest(\"closes notification on close button click\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Info\"));\n  expect(screen.getByText(\"Info\")).toBeInTheDocument();\n  \n  const closeButton = screen.getByLabelText(\"Close notification\");\n  await user.click(closeButton);\n  \n  await waitFor(() => {\n    expect(screen.queryByText(\"Info\")).not.toBeInTheDocument();\n  });\n});\n\ntest(\"clears all notifications\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Info\"));\n  await user.click(screen.getByText(\"Show Success\"));\n  \n  expect(screen.getByText(\"Info\")).toBeInTheDocument();\n  expect(screen.getByText(\"Success\")).toBeInTheDocument();\n  \n  await user.click(screen.getByText(\"Clear All\"));\n  \n  await waitFor(() => {\n    expect(screen.queryByText(\"Info\")).not.toBeInTheDocument();\n    expect(screen.queryByText(\"Success\")).not.toBeInTheDocument();\n  });\n});\n\ntest(\"auto-removes notification after duration\", async () => {\n  const user = userEvent.setup();\n  \n  // Use a shorter duration for testing\n  const TestComponentWithDuration = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"Auto Remove\", \"Message\", { duration: 100 })}>\n        Show Auto Remove\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentWithDuration />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Auto Remove\"));\n  expect(screen.getByText(\"Auto Remove\")).toBeInTheDocument();\n  \n  await waitFor(() => {\n    expect(screen.queryByText(\"Auto Remove\")).not.toBeInTheDocument();\n  }, { timeout: 200 });\n});\n\ntest(\"shows custom icon\", async () => {\n  const user = userEvent.setup();\n  \n  const TestComponentWithIcon = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"Custom\", \"Message\", { icon: <span>🎉</span> })}>\n        Show Custom Icon\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentWithIcon />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Custom Icon\"));\n  expect(screen.getByText(\"🎉\")).toBeInTheDocument();\n});\n\ntest(\"shows action button\", async () => {\n  const user = userEvent.setup();\n  const actionFn = vi.fn();\n  \n  const TestComponentWithAction = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"Action\", \"Message\", { \n        action: { label: \"Undo\", onClick: actionFn }\n      })}>\n        Show Action\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentWithAction />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Action\"));\n  \n  const actionButton = screen.getByText(\"Undo\");\n  expect(actionButton).toBeInTheDocument();\n  \n  await user.click(actionButton);\n  expect(actionFn).toHaveBeenCalledTimes(1);\n});\n\ntest(\"handles non-closable notification\", async () => {\n  const user = userEvent.setup();\n  \n  const TestComponentNonClosable = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"Non Closable\", \"Message\", { closable: false })}>\n        Show Non Closable\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentNonClosable />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Non Closable\"));\n  expect(screen.getByText(\"Non Closable\")).toBeInTheDocument();\n  expect(screen.queryByLabelText(\"Close notification\")).not.toBeInTheDocument();\n});\n\ntest(\"respects maxCount limit\", async () => {\n  const user = userEvent.setup();\n  \n  const TestComponentMany = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => {\n        notification.info(\"Notification 1\");\n        notification.info(\"Notification 2\");\n        notification.info(\"Notification 3\");\n        notification.info(\"Notification 4\");\n      }}>\n        Show Many\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentMany />\n      <Notification maxCount={2} />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Many\"));\n  \n  // Should only show the last 2 notifications\n  expect(screen.queryByText(\"Notification 1\")).not.toBeInTheDocument();\n  expect(screen.queryByText(\"Notification 2\")).not.toBeInTheDocument();\n  expect(screen.getByText(\"Notification 3\")).toBeInTheDocument();\n  expect(screen.getByText(\"Notification 4\")).toBeInTheDocument();\n});\n\ntest(\"applies correct placement class\", () => {\n  render(<Notification placement=\"bottomLeft\" />);\n  \n  // Add a notification to make container render\n  Notification.info(\"Test\");\n  \n  const container = document.querySelector(\".notification-bottomLeft\");\n  expect(container).toBeInTheDocument();\n});\n\ntest(\"applies custom z-index\", () => {\n  render(<Notification zIndex={2000} />);\n  \n  // Add a notification to make container render\n  Notification.info(\"Test\");\n  \n  const container = document.querySelector(\".notification-container\") as HTMLElement;\n  expect(container).toHaveStyle({ zIndex: \"2000\" });\n});\n\ntest(\"calls onClose callback\", async () => {\n  const user = userEvent.setup();\n  const onClose = vi.fn();\n  \n  const TestComponentWithCallback = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"With Callback\", \"Message\", { onClose })}>\n        Show With Callback\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentWithCallback />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show With Callback\"));\n  \n  const closeButton = screen.getByLabelText(\"Close notification\");\n  await user.click(closeButton);\n  \n  await waitFor(() => {\n    expect(onClose).toHaveBeenCalledTimes(1);\n  });\n});\n\ntest(\"static methods work correctly\", async () => {\n  render(<Notification />);\n  \n  Notification.info(\"Static Info\");\n  expect(screen.getByText(\"Static Info\")).toBeInTheDocument();\n  \n  const id = Notification.success(\"Static Success\");\n  expect(screen.getByText(\"Static Success\")).toBeInTheDocument();\n  \n  Notification.close(id);\n  await waitFor(() => {\n    expect(screen.queryByText(\"Static Success\")).not.toBeInTheDocument();\n  });\n});\n\ntest(\"has proper accessibility attributes\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Info\"));\n  \n  const notification = screen.getByRole(\"alert\");\n  expect(notification).toHaveAttribute(\"aria-live\", \"polite\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface NotificationItem {\n  id: string;\n  title: string;\n  message?: string;\n  type?: \"info\" | \"success\" | \"warning\" | \"error\";\n  duration?: number;\n  closable?: boolean;\n  icon?: React.ReactNode;\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n  onClose?: () => void;\n}\n\nexport interface NotificationProps {\n  placement?: \"topLeft\" | \"topRight\" | \"bottomLeft\" | \"bottomRight\" | \"top\" | \"bottom\";\n  maxCount?: number;\n  zIndex?: number;\n}\n\n// Global notification manager\nclass NotificationManager {\n  private notifications: NotificationItem[] = [];\n  private listeners: ((notifications: NotificationItem[]) => void)[] = [];\n  private defaultDuration = 4500;\n\n  subscribe(listener: (notifications: NotificationItem[]) => void) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter(l => l !== listener);\n    };\n  }\n\n  notify() {\n    this.listeners.forEach(listener => listener([...this.notifications]));\n  }\n\n  add(notification: Omit<NotificationItem, \"id\">): string {\n    const id = `notification-${Date.now()}-${Math.random()}`;\n    const item: NotificationItem = {\n      ...notification,\n      id,\n      duration: notification.duration ?? this.defaultDuration,\n    };\n\n    this.notifications.push(item);\n    this.notify();\n\n    // Auto remove after duration\n    if (item.duration > 0) {\n      setTimeout(() => {\n        this.remove(id);\n      }, item.duration);\n    }\n\n    return id;\n  }\n\n  remove(id: string) {\n    const notification = this.notifications.find(n => n.id === id);\n    this.notifications = this.notifications.filter(n => n.id !== id);\n    \n    if (notification?.onClose) {\n      notification.onClose();\n    }\n    \n    this.notify();\n  }\n\n  clear() {\n    this.notifications = [];\n    this.notify();\n  }\n\n  // Convenience methods\n  info(title: string, message?: string, options?: Partial<NotificationItem>) {\n    return this.add({ title, message, type: \"info\", ...options });\n  }\n\n  success(title: string, message?: string, options?: Partial<NotificationItem>) {\n    return this.add({ title, message, type: \"success\", ...options });\n  }\n\n  warning(title: string, message?: string, options?: Partial<NotificationItem>) {\n    return this.add({ title, message, type: \"warning\", ...options });\n  }\n\n  error(title: string, message?: string, options?: Partial<NotificationItem>) {\n    return this.add({ title, message, type: \"error\", ...options });\n  }\n}\n\nconst notificationManager = new NotificationManager();\n\n// Individual notification component\nconst NotificationCard: React.FC<{\n  notification: NotificationItem;\n  onClose: (id: string) => void;\n}> = ({ notification, onClose }) => {\n  const [isVisible, setIsVisible] = React.useState(false);\n  const [isLeaving, setIsLeaving] = React.useState(false);\n\n  React.useEffect(() => {\n    // Trigger entrance animation\n    const timer = setTimeout(() => setIsVisible(true), 10);\n    return () => clearTimeout(timer);\n  }, []);\n\n  const handleClose = () => {\n    setIsLeaving(true);\n    setTimeout(() => {\n      onClose(notification.id);\n    }, 300); // Match CSS animation duration\n  };\n\n  const getIcon = () => {\n    if (notification.icon) return notification.icon;\n    \n    switch (notification.type) {\n      case \"success\": return \"✅\";\n      case \"warning\": return \"⚠️\";\n      case \"error\": return \"❌\";\n      default: return \"ℹ️\";\n    }\n  };\n\n  const classes = `notification-card notification-${notification.type || \"info\"} ${n    isVisible ? \"notification-enter\" : \"\"\n  } ${isLeaving ? \"notification-exit\" : \"\"}`.trim();\n\n  return (\n    <div className={classes} role=\"alert\" aria-live=\"polite\">\n      <div className=\"notification-icon\">\n        {getIcon()}\n      </div>\n      \n      <div className=\"notification-content\">\n        <div className=\"notification-title\">{notification.title}</div>\n        {notification.message && (\n          <div className=\"notification-message\">{notification.message}</div>\n        )}\n        \n        {notification.action && (\n          <div className=\"notification-actions\">\n            <button\n              type=\"button\"\n              className=\"notification-action-button\"\n              onClick={notification.action.onClick}\n            >\n              {notification.action.label}\n            </button>\n          </div>\n        )}\n      </div>\n      \n      {notification.closable !== false && (\n        <button\n          type=\"button\"\n          className=\"notification-close\"\n          onClick={handleClose}\n          aria-label=\"Close notification\"\n        >\n          ×\n        </button>\n      )}\n    </div>\n  );\n};\n\n// Main notification container component\nexport const Notification: React.FC<NotificationProps> = ({\n  placement = \"topRight\",\n  maxCount = 10,\n  zIndex = 1000,\n}) => {\n  const [notifications, setNotifications] = React.useState<NotificationItem[]>([]);\n\n  React.useEffect(() => {\n    return notificationManager.subscribe(setNotifications);\n  }, []);\n\n  const handleClose = (id: string) => {\n    notificationManager.remove(id);\n  };\n\n  const displayedNotifications = maxCount \n    ? notifications.slice(-maxCount)\n    : notifications;\n\n  const containerClasses = `notification-container notification-${placement}`;\n  \n  const containerStyle: React.CSSProperties = {\n    zIndex,\n  };\n\n  if (displayedNotifications.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className={containerClasses} style={containerStyle}>\n      {displayedNotifications.map(notification => (\n        <NotificationCard\n          key={notification.id}\n          notification={notification}\n          onClose={handleClose}\n        />\n      ))}\n    </div>\n  );\n};\n\n// Hook for using notifications\nexport const useNotification = () => {\n  return {\n    info: notificationManager.info.bind(notificationManager),\n    success: notificationManager.success.bind(notificationManager),\n    warning: notificationManager.warning.bind(notificationManager),\n    error: notificationManager.error.bind(notificationManager),\n    open: notificationManager.add.bind(notificationManager),\n    close: notificationManager.remove.bind(notificationManager),\n    clear: notificationManager.clear.bind(notificationManager),\n  };\n};\n\n// Static methods for imperative usage\nNotification.info = notificationManager.info.bind(notificationManager);\nNotification.success = notificationManager.success.bind(notificationManager);\nNotification.warning = notificationManager.warning.bind(notificationManager);\nNotification.error = notificationManager.error.bind(notificationManager);\nNotification.open = notificationManager.add.bind(notificationManager);\nNotification.close = notificationManager.remove.bind(notificationManager);\nNotification.clear = notificationManager.clear.bind(notificationManager);\n\nNotification.displayName = \"Notification\";",
    "output": "import { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Notification, useNotification } from \"../Notification\";\n\n// Test component that uses the hook\nconst TestComponent = () => {\n  const notification = useNotification();\n  \n  return (\n    <div>\n      <button onClick={() => notification.info(\"Info\", \"Info message\")}>\n        Show Info\n      </button>\n      <button onClick={() => notification.success(\"Success\", \"Success message\")}>\n        Show Success\n      </button>\n      <button onClick={() => notification.warning(\"Warning\", \"Warning message\")}>\n        Show Warning\n      </button>\n      <button onClick={() => notification.error(\"Error\", \"Error message\")}>\n        Show Error\n      </button>\n      <button onClick={() => notification.clear()}>\n        Clear All\n      </button>\n    </div>\n  );\n};\n\n// Test wrapper component\nconst TestWrapper = () => {\n  return (\n    <>\n      <TestComponent />\n      <Notification />\n    </>\n  );\n};\n\nbeforeEach(() => {\n  // Clear any existing notifications before each test\n  Notification.clear();\n});\n\ntest(\"renders notification container\", () => {\n  render(<Notification />);\n  // Container only renders when there are notifications\n  expect(document.querySelector(\".notification-container\")).not.toBeInTheDocument();\n});\n\ntest(\"shows info notification\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Info\"));\n  \n  expect(screen.getByText(\"Info\")).toBeInTheDocument();\n  expect(screen.getByText(\"Info message\")).toBeInTheDocument();\n  expect(screen.getByText(\"ℹ️\")).toBeInTheDocument();\n});\n\ntest(\"shows success notification\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Success\"));\n  \n  expect(screen.getByText(\"Success\")).toBeInTheDocument();\n  expect(screen.getByText(\"Success message\")).toBeInTheDocument();\n  expect(screen.getByText(\"✅\")).toBeInTheDocument();\n});\n\ntest(\"shows warning notification\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Warning\"));\n  \n  expect(screen.getByText(\"Warning\")).toBeInTheDocument();\n  expect(screen.getByText(\"Warning message\")).toBeInTheDocument();\n  expect(screen.getByText(\"⚠️\")).toBeInTheDocument();\n});\n\ntest(\"shows error notification\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Error\"));\n  \n  expect(screen.getByText(\"Error\")).toBeInTheDocument();\n  expect(screen.getByText(\"Error message\")).toBeInTheDocument();\n  expect(screen.getByText(\"❌\")).toBeInTheDocument();\n});\n\ntest(\"closes notification on close button click\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Info\"));\n  expect(screen.getByText(\"Info\")).toBeInTheDocument();\n  \n  const closeButton = screen.getByLabelText(\"Close notification\");\n  await user.click(closeButton);\n  \n  await waitFor(() => {\n    expect(screen.queryByText(\"Info\")).not.toBeInTheDocument();\n  });\n});\n\ntest(\"clears all notifications\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Info\"));\n  await user.click(screen.getByText(\"Show Success\"));\n  \n  expect(screen.getByText(\"Info\")).toBeInTheDocument();\n  expect(screen.getByText(\"Success\")).toBeInTheDocument();\n  \n  await user.click(screen.getByText(\"Clear All\"));\n  \n  await waitFor(() => {\n    expect(screen.queryByText(\"Info\")).not.toBeInTheDocument();\n    expect(screen.queryByText(\"Success\")).not.toBeInTheDocument();\n  });\n});\n\ntest(\"auto-removes notification after duration\", async () => {\n  const user = userEvent.setup();\n  \n  // Use a shorter duration for testing\n  const TestComponentWithDuration = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"Auto Remove\", \"Message\", { duration: 100 })}>\n        Show Auto Remove\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentWithDuration />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Auto Remove\"));\n  expect(screen.getByText(\"Auto Remove\")).toBeInTheDocument();\n  \n  await waitFor(() => {\n    expect(screen.queryByText(\"Auto Remove\")).not.toBeInTheDocument();\n  }, { timeout: 200 });\n});\n\ntest(\"shows custom icon\", async () => {\n  const user = userEvent.setup();\n  \n  const TestComponentWithIcon = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"Custom\", \"Message\", { icon: <span>🎉</span> })}>\n        Show Custom Icon\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentWithIcon />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Custom Icon\"));\n  expect(screen.getByText(\"🎉\")).toBeInTheDocument();\n});\n\ntest(\"shows action button\", async () => {\n  const user = userEvent.setup();\n  const actionFn = vi.fn();\n  \n  const TestComponentWithAction = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"Action\", \"Message\", { \n        action: { label: \"Undo\", onClick: actionFn }\n      })}>\n        Show Action\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentWithAction />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Action\"));\n  \n  const actionButton = screen.getByText(\"Undo\");\n  expect(actionButton).toBeInTheDocument();\n  \n  await user.click(actionButton);\n  expect(actionFn).toHaveBeenCalledTimes(1);\n});\n\ntest(\"handles non-closable notification\", async () => {\n  const user = userEvent.setup();\n  \n  const TestComponentNonClosable = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"Non Closable\", \"Message\", { closable: false })}>\n        Show Non Closable\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentNonClosable />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Non Closable\"));\n  expect(screen.getByText(\"Non Closable\")).toBeInTheDocument();\n  expect(screen.queryByLabelText(\"Close notification\")).not.toBeInTheDocument();\n});\n\ntest(\"respects maxCount limit\", async () => {\n  const user = userEvent.setup();\n  \n  const TestComponentMany = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => {\n        notification.info(\"Notification 1\");\n        notification.info(\"Notification 2\");\n        notification.info(\"Notification 3\");\n        notification.info(\"Notification 4\");\n      }}>\n        Show Many\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentMany />\n      <Notification maxCount={2} />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Many\"));\n  \n  // Should only show the last 2 notifications\n  expect(screen.queryByText(\"Notification 1\")).not.toBeInTheDocument();\n  expect(screen.queryByText(\"Notification 2\")).not.toBeInTheDocument();\n  expect(screen.getByText(\"Notification 3\")).toBeInTheDocument();\n  expect(screen.getByText(\"Notification 4\")).toBeInTheDocument();\n});\n\ntest(\"applies correct placement class\", () => {\n  render(<Notification placement=\"bottomLeft\" />);\n  \n  // Add a notification to make container render\n  Notification.info(\"Test\");\n  \n  const container = document.querySelector(\".notification-bottomLeft\");\n  expect(container).toBeInTheDocument();\n});\n\ntest(\"applies custom z-index\", () => {\n  render(<Notification zIndex={2000} />);\n  \n  // Add a notification to make container render\n  Notification.info(\"Test\");\n  \n  const container = document.querySelector(\".notification-container\") as HTMLElement;\n  expect(container).toHaveStyle({ zIndex: \"2000\" });\n});\n\ntest(\"calls onClose callback\", async () => {\n  const user = userEvent.setup();\n  const onClose = vi.fn();\n  \n  const TestComponentWithCallback = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"With Callback\", \"Message\", { onClose })}>\n        Show With Callback\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentWithCallback />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show With Callback\"));\n  \n  const closeButton = screen.getByLabelText(\"Close notification\");\n  await user.click(closeButton);\n  \n  await waitFor(() => {\n    expect(onClose).toHaveBeenCalledTimes(1);\n  });\n});\n\ntest(\"static methods work correctly\", async () => {\n  render(<Notification />);\n  \n  Notification.info(\"Static Info\");\n  expect(screen.getByText(\"Static Info\")).toBeInTheDocument();\n  \n  const id = Notification.success(\"Static Success\");\n  expect(screen.getByText(\"Static Success\")).toBeInTheDocument();\n  \n  Notification.close(id);\n  await waitFor(() => {\n    expect(screen.queryByText(\"Static Success\")).not.toBeInTheDocument();\n  });\n});\n\ntest(\"has proper accessibility attributes\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Info\"));\n  \n  const notification = screen.getByRole(\"alert\");\n  expect(notification).toHaveAttribute(\"aria-live\", \"polite\");\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface NotificationItem {\n  id: string;\n  title: string;\n  message?: string;\n  type?: \"info\" | \"success\" | \"warning\" | \"error\";\n  duration?: number;\n  closable?: boolean;\n  icon?: React.ReactNode;\n  action?: {\n    label: string;\n    onClick: () => void;\n  };\n  onClose?: () => void;\n}\n\nexport interface NotificationProps {\n  placement?: \"topLeft\" | \"topRight\" | \"bottomLeft\" | \"bottomRight\" | \"top\" | \"bottom\";\n  maxCount?: number;\n  zIndex?: number;\n}\n\n// Global notification manager\nclass NotificationManager {\n  private notifications: NotificationItem[] = [];\n  private listeners: ((notifications: NotificationItem[]) => void)[] = [];\n  private defaultDuration = 4500;\n\n  subscribe(listener: (notifications: NotificationItem[]) => void) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter(l => l !== listener);\n    };\n  }\n\n  notify() {\n    this.listeners.forEach(listener => listener([...this.notifications]));\n  }\n\n  add(notification: Omit<NotificationItem, \"id\">): string {\n    const id = `notification-${Date.now()}-${Math.random()}`;\n    const item: NotificationItem = {\n      ...notification,\n      id,\n      duration: notification.duration ?? this.defaultDuration,\n    };\n\n    this.notifications.push(item);\n    this.notify();\n\n    // Auto remove after duration\n    if (item.duration > 0) {\n      setTimeout(() => {\n        this.remove(id);\n      }, item.duration);\n    }\n\n    return id;\n  }\n\n  remove(id: string) {\n    const notification = this.notifications.find(n => n.id === id);\n    this.notifications = this.notifications.filter(n => n.id !== id);\n    \n    if (notification?.onClose) {\n      notification.onClose();\n    }\n    \n    this.notify();\n  }\n\n  clear() {\n    this.notifications = [];\n    this.notify();\n  }\n\n  // Convenience methods\n  info(title: string, message?: string, options?: Partial<NotificationItem>) {\n    return this.add({ title, message, type: \"info\", ...options });\n  }\n\n  success(title: string, message?: string, options?: Partial<NotificationItem>) {\n    return this.add({ title, message, type: \"success\", ...options });\n  }\n\n  warning(title: string, message?: string, options?: Partial<NotificationItem>) {\n    return this.add({ title, message, type: \"warning\", ...options });\n  }\n\n  error(title: string, message?: string, options?: Partial<NotificationItem>) {\n    return this.add({ title, message, type: \"error\", ...options });\n  }\n}\n\nconst notificationManager = new NotificationManager();\n\n// Individual notification component\nconst NotificationCard: React.FC<{\n  notification: NotificationItem;\n  onClose: (id: string) => void;\n}> = ({ notification, onClose }) => {\n  const [isVisible, setIsVisible] = React.useState(false);\n  const [isLeaving, setIsLeaving] = React.useState(false);\n\n  React.useEffect(() => {\n    // Trigger entrance animation\n    const timer = setTimeout(() => setIsVisible(true), 10);\n    return () => clearTimeout(timer);\n  }, []);\n\n  const handleClose = () => {\n    setIsLeaving(true);\n    setTimeout(() => {\n      onClose(notification.id);\n    }, 300); // Match CSS animation duration\n  };\n\n  const getIcon = () => {\n    if (notification.icon) return notification.icon;\n    \n    switch (notification.type) {\n      case \"success\": return \"✅\";\n      case \"warning\": return \"⚠️\";\n      case \"error\": return \"❌\";\n      default: return \"ℹ️\";\n    }\n  };\n\n  const classes = `notification-card notification-${notification.type || \"info\"} ${n    isVisible ? \"notification-enter\" : \"\"\n  } ${isLeaving ? \"notification-exit\" : \"\"}`.trim();\n\n  return (\n    <div className={classes} role=\"alert\" aria-live=\"polite\">\n      <div className=\"notification-icon\">\n        {getIcon()}\n      </div>\n      \n      <div className=\"notification-content\">\n        <div className=\"notification-title\">{notification.title}</div>\n        {notification.message && (\n          <div className=\"notification-message\">{notification.message}</div>\n        )}\n        \n        {notification.action && (\n          <div className=\"notification-actions\">\n            <button\n              type=\"button\"\n              className=\"notification-action-button\"\n              onClick={notification.action.onClick}\n            >\n              {notification.action.label}\n            </button>\n          </div>\n        )}\n      </div>\n      \n      {notification.closable !== false && (\n        <button\n          type=\"button\"\n          className=\"notification-close\"\n          onClick={handleClose}\n          aria-label=\"Close notification\"\n        >\n          ×\n        </button>\n      )}\n    </div>\n  );\n};\n\n// Main notification container component\nexport const Notification: React.FC<NotificationProps> = ({\n  placement = \"topRight\",\n  maxCount = 10,\n  zIndex = 1000,\n}) => {\n  const [notifications, setNotifications] = React.useState<NotificationItem[]>([]);\n\n  React.useEffect(() => {\n    return notificationManager.subscribe(setNotifications);\n  }, []);\n\n  const handleClose = (id: string) => {\n    notificationManager.remove(id);\n  };\n\n  const displayedNotifications = maxCount \n    ? notifications.slice(-maxCount)\n    : notifications;\n\n  const containerClasses = `notification-container notification-${placement}`;\n  \n  const containerStyle: React.CSSProperties = {\n    zIndex,\n  };\n\n  if (displayedNotifications.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className={containerClasses} style={containerStyle}>\n      {displayedNotifications.map(notification => (\n        <NotificationCard\n          key={notification.id}\n          notification={notification}\n          onClose={handleClose}\n        />\n      ))}\n    </div>\n  );\n};\n\n// Hook for using notifications\nexport const useNotification = () => {\n  return {\n    info: notificationManager.info.bind(notificationManager),\n    success: notificationManager.success.bind(notificationManager),\n    warning: notificationManager.warning.bind(notificationManager),\n    error: notificationManager.error.bind(notificationManager),\n    open: notificationManager.add.bind(notificationManager),\n    close: notificationManager.remove.bind(notificationManager),\n    clear: notificationManager.clear.bind(notificationManager),\n  };\n};\n\n// Static methods for imperative usage\nNotification.info = notificationManager.info.bind(notificationManager);\nNotification.success = notificationManager.success.bind(notificationManager);\nNotification.warning = notificationManager.warning.bind(notificationManager);\nNotification.error = notificationManager.error.bind(notificationManager);\nNotification.open = notificationManager.add.bind(notificationManager);\nNotification.close = notificationManager.remove.bind(notificationManager);\nNotification.clear = notificationManager.clear.bind(notificationManager);\n\nNotification.displayName = \"Notification\";",
    "output": "import { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Notification, useNotification } from \"../Notification\";\n\n// Test component that uses the hook\nconst TestComponent = () => {\n  const notification = useNotification();\n  \n  return (\n    <div>\n      <button onClick={() => notification.info(\"Info\", \"Info message\")}>\n        Show Info\n      </button>\n      <button onClick={() => notification.success(\"Success\", \"Success message\")}>\n        Show Success\n      </button>\n      <button onClick={() => notification.warning(\"Warning\", \"Warning message\")}>\n        Show Warning\n      </button>\n      <button onClick={() => notification.error(\"Error\", \"Error message\")}>\n        Show Error\n      </button>\n      <button onClick={() => notification.clear()}>\n        Clear All\n      </button>\n    </div>\n  );\n};\n\n// Test wrapper component\nconst TestWrapper = () => {\n  return (\n    <>\n      <TestComponent />\n      <Notification />\n    </>\n  );\n};\n\nbeforeEach(() => {\n  // Clear any existing notifications before each test\n  Notification.clear();\n});\n\ntest(\"renders notification container\", () => {\n  render(<Notification />);\n  // Container only renders when there are notifications\n  expect(document.querySelector(\".notification-container\")).not.toBeInTheDocument();\n});\n\ntest(\"shows info notification\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Info\"));\n  \n  expect(screen.getByText(\"Info\")).toBeInTheDocument();\n  expect(screen.getByText(\"Info message\")).toBeInTheDocument();\n  expect(screen.getByText(\"ℹ️\")).toBeInTheDocument();\n});\n\ntest(\"shows success notification\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Success\"));\n  \n  expect(screen.getByText(\"Success\")).toBeInTheDocument();\n  expect(screen.getByText(\"Success message\")).toBeInTheDocument();\n  expect(screen.getByText(\"✅\")).toBeInTheDocument();\n});\n\ntest(\"shows warning notification\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Warning\"));\n  \n  expect(screen.getByText(\"Warning\")).toBeInTheDocument();\n  expect(screen.getByText(\"Warning message\")).toBeInTheDocument();\n  expect(screen.getByText(\"⚠️\")).toBeInTheDocument();\n});\n\ntest(\"shows error notification\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Error\"));\n  \n  expect(screen.getByText(\"Error\")).toBeInTheDocument();\n  expect(screen.getByText(\"Error message\")).toBeInTheDocument();\n  expect(screen.getByText(\"❌\")).toBeInTheDocument();\n});\n\ntest(\"closes notification on close button click\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Info\"));\n  expect(screen.getByText(\"Info\")).toBeInTheDocument();\n  \n  const closeButton = screen.getByLabelText(\"Close notification\");\n  await user.click(closeButton);\n  \n  await waitFor(() => {\n    expect(screen.queryByText(\"Info\")).not.toBeInTheDocument();\n  });\n});\n\ntest(\"clears all notifications\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Info\"));\n  await user.click(screen.getByText(\"Show Success\"));\n  \n  expect(screen.getByText(\"Info\")).toBeInTheDocument();\n  expect(screen.getByText(\"Success\")).toBeInTheDocument();\n  \n  await user.click(screen.getByText(\"Clear All\"));\n  \n  await waitFor(() => {\n    expect(screen.queryByText(\"Info\")).not.toBeInTheDocument();\n    expect(screen.queryByText(\"Success\")).not.toBeInTheDocument();\n  });\n});\n\ntest(\"auto-removes notification after duration\", async () => {\n  const user = userEvent.setup();\n  \n  // Use a shorter duration for testing\n  const TestComponentWithDuration = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"Auto Remove\", \"Message\", { duration: 100 })}>\n        Show Auto Remove\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentWithDuration />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Auto Remove\"));\n  expect(screen.getByText(\"Auto Remove\")).toBeInTheDocument();\n  \n  await waitFor(() => {\n    expect(screen.queryByText(\"Auto Remove\")).not.toBeInTheDocument();\n  }, { timeout: 200 });\n});\n\ntest(\"shows custom icon\", async () => {\n  const user = userEvent.setup();\n  \n  const TestComponentWithIcon = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"Custom\", \"Message\", { icon: <span>🎉</span> })}>\n        Show Custom Icon\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentWithIcon />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Custom Icon\"));\n  expect(screen.getByText(\"🎉\")).toBeInTheDocument();\n});\n\ntest(\"shows action button\", async () => {\n  const user = userEvent.setup();\n  const actionFn = vi.fn();\n  \n  const TestComponentWithAction = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"Action\", \"Message\", { \n        action: { label: \"Undo\", onClick: actionFn }\n      })}>\n        Show Action\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentWithAction />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Action\"));\n  \n  const actionButton = screen.getByText(\"Undo\");\n  expect(actionButton).toBeInTheDocument();\n  \n  await user.click(actionButton);\n  expect(actionFn).toHaveBeenCalledTimes(1);\n});\n\ntest(\"handles non-closable notification\", async () => {\n  const user = userEvent.setup();\n  \n  const TestComponentNonClosable = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"Non Closable\", \"Message\", { closable: false })}>\n        Show Non Closable\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentNonClosable />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Non Closable\"));\n  expect(screen.getByText(\"Non Closable\")).toBeInTheDocument();\n  expect(screen.queryByLabelText(\"Close notification\")).not.toBeInTheDocument();\n});\n\ntest(\"respects maxCount limit\", async () => {\n  const user = userEvent.setup();\n  \n  const TestComponentMany = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => {\n        notification.info(\"Notification 1\");\n        notification.info(\"Notification 2\");\n        notification.info(\"Notification 3\");\n        notification.info(\"Notification 4\");\n      }}>\n        Show Many\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentMany />\n      <Notification maxCount={2} />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show Many\"));\n  \n  // Should only show the last 2 notifications\n  expect(screen.queryByText(\"Notification 1\")).not.toBeInTheDocument();\n  expect(screen.queryByText(\"Notification 2\")).not.toBeInTheDocument();\n  expect(screen.getByText(\"Notification 3\")).toBeInTheDocument();\n  expect(screen.getByText(\"Notification 4\")).toBeInTheDocument();\n});\n\ntest(\"applies correct placement class\", () => {\n  render(<Notification placement=\"bottomLeft\" />);\n  \n  // Add a notification to make container render\n  Notification.info(\"Test\");\n  \n  const container = document.querySelector(\".notification-bottomLeft\");\n  expect(container).toBeInTheDocument();\n});\n\ntest(\"applies custom z-index\", () => {\n  render(<Notification zIndex={2000} />);\n  \n  // Add a notification to make container render\n  Notification.info(\"Test\");\n  \n  const container = document.querySelector(\".notification-container\") as HTMLElement;\n  expect(container).toHaveStyle({ zIndex: \"2000\" });\n});\n\ntest(\"calls onClose callback\", async () => {\n  const user = userEvent.setup();\n  const onClose = vi.fn();\n  \n  const TestComponentWithCallback = () => {\n    const notification = useNotification();\n    return (\n      <button onClick={() => notification.info(\"With Callback\", \"Message\", { onClose })}>\n        Show With Callback\n      </button>\n    );\n  };\n  \n  render(\n    <>\n      <TestComponentWithCallback />\n      <Notification />\n    </>\n  );\n  \n  await user.click(screen.getByText(\"Show With Callback\"));\n  \n  const closeButton = screen.getByLabelText(\"Close notification\");\n  await user.click(closeButton);\n  \n  await waitFor(() => {\n    expect(onClose).toHaveBeenCalledTimes(1);\n  });\n});\n\ntest(\"static methods work correctly\", async () => {\n  render(<Notification />);\n  \n  Notification.info(\"Static Info\");\n  expect(screen.getByText(\"Static Info\")).toBeInTheDocument();\n  \n  const id = Notification.success(\"Static Success\");\n  expect(screen.getByText(\"Static Success\")).toBeInTheDocument();\n  \n  Notification.close(id);\n  await waitFor(() => {\n    expect(screen.queryByText(\"Static Success\")).not.toBeInTheDocument();\n  });\n});\n\ntest(\"has proper accessibility attributes\", async () => {\n  const user = userEvent.setup();\n  render(<TestWrapper />);\n  \n  await user.click(screen.getByText(\"Show Info\"));\n  \n  const notification = screen.getByRole(\"alert\");\n  expect(notification).toHaveAttribute(\"aria-live\", \"polite\");\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface PaginationProps extends React.HTMLAttributes<HTMLElement> {\n    currentPage: number;\n    totalPages: number;\n    onPageChange: (page: number) => void;\n    showFirstLast?: boolean;\n    showPrevNext?: boolean;\n    siblingCount?: number;\n    size?: \"sm\" | \"md\" | \"lg\";\n    variant?: \"default\" | \"outlined\" | \"minimal\";\n    disabled?: boolean;\n}\n\nconst classesBySize: Record<NonNullable<PaginationProps[\"size\"]>, string> = {\n    sm: \"pagination pagination-sm\",\n    md: \"pagination pagination-md\",\n    lg: \"pagination pagination-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<PaginationProps[\"variant\"]>, string> = {\n    default: \"pagination-default\",\n    outlined: \"pagination-outlined\",\n    minimal: \"pagination-minimal\",\n};\n\nexport const Pagination = React.forwardRef<HTMLElement, PaginationProps>(\n    ({\n        currentPage,\n        totalPages,\n        onPageChange,\n        showFirstLast = true,\n        showPrevNext = true,\n        siblingCount = 1,\n        size = \"md\",\n        variant = \"default\",\n        disabled = false,\n        className,\n        ...rest\n    }, ref) => {\n        const classes = `${classesBySize[size]} ${classesByVariant[variant]} ${className || \"\"}`.trim();\n\n        const getPageNumbers = () => {\n            const totalNumbers = siblingCount * 2 + 3; // Current + siblings + first/last\n            const totalBlocks = totalNumbers + 2; // Including ellipsis\n\n            if (totalPages > totalBlocks) {\n                const startPage = Math.max(2, currentPage - siblingCount);\n                const endPage = Math.min(totalPages - 1, currentPage + siblingCount);\n\n                const pages = [];\n                pages.push(1);\n\n                if (startPage > 2) {\n                    pages.push(\"...\");\n                }\n\n                for (let i = startPage; i <= endPage; i++) {\n                    pages.push(i);\n                }\n\n                if (endPage < totalPages - 1) {\n                    pages.push(\"...\");\n                }\n\n                pages.push(totalPages);\n                return pages;\n            }\n\n            return Array.from({ length: totalPages }, (_, i) => i + 1);\n        };\n\n        const handlePageChange = (page: number | string) => {\n            if (typeof page === \"number\" && !disabled) {\n                onPageChange(page);\n            }\n        };\n\n        const pageNumbers = getPageNumbers();\n        const isFirstPage = currentPage === 1;\n        const isLastPage = currentPage === totalPages;\n\n        return (\n            <nav {...rest} ref={ref} className={classes} aria-label=\"Pagination navigation\">\n                <ul className=\"pagination-list\">\n                    {showFirstLast && (\n                        <li className=\"pagination-item\">\n                            <button\n                                type=\"button\"\n                                className={`pagination-button pagination-first ${isFirstPage ? \"pagination-disabled\" : \"\"}`}\n                                onClick={() => handlePageChange(1)}\n                                disabled={disabled || isFirstPage}\n                                aria-label=\"Go to first page\"\n                            >\n                                «\n                            </button>\n                        </li>\n                    )}\n\n                    {showPrevNext && (\n                        <li className=\"pagination-item\">\n                            <button\n                                type=\"button\"\n                                className={`pagination-button pagination-prev ${isFirstPage ? \"pagination-disabled\" : \"\"}`}\n                                onClick={() => handlePageChange(currentPage - 1)}\n                                disabled={disabled || isFirstPage}\n                                aria-label=\"Go to previous page\"\n                            >\n                                ‹\n                            </button>\n                        </li>\n                    )}\n\n                    {pageNumbers.map((page, index) => (\n                        <li key={index} className=\"pagination-item\">\n                            {page === \"...\" ? (\n                                <span className=\"pagination-ellipsis\" aria-hidden=\"true\">\n                                    ...\n                                </span>\n                            ) : (\n                                <button\n                                    type=\"button\"\n                                    className={`pagination-button pagination-page ${page === currentPage ? \"pagination-active\" : \"\"\n                                        }`}\n                                    onClick={() => handlePageChange(page)}\n                                    disabled={disabled}\n                                    aria-label={`Go to page ${page}`}\n                                    aria-current={page === currentPage ? \"page\" : undefined}\n                                >\n                                    {page}\n                                </button>\n                            )}\n                        </li>\n                    ))}\n\n                    {showPrevNext && (\n                        <li className=\"pagination-item\">\n                            <button\n                                type=\"button\"\n                                className={`pagination-button pagination-next ${isLastPage ? \"pagination-disabled\" : \"\"}`}\n                                onClick={() => handlePageChange(currentPage + 1)}\n                                disabled={disabled || isLastPage}\n                                aria-label=\"Go to next page\"\n                            >\n                                ›\n                            </button>\n                        </li>\n                    )}\n\n                    {showFirstLast && (\n                        <li className=\"pagination-item\">\n                            <button\n                                type=\"button\"\n                                className={`pagination-button pagination-last ${isLastPage ? \"pagination-disabled\" : \"\"}`}\n                                onClick={() => handlePageChange(totalPages)}\n                                disabled={disabled || isLastPage}\n                                aria-label=\"Go to last page\"\n                            >\n                                »\n                            </button>\n                        </li>\n                    )}\n                </ul>\n            </nav>\n        );\n    }\n);\nPagination.displayName = \"Pagination\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Pagination } from \"../Pagination\";\n\ntest(\"renders pagination buttons\", () => {\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={2} totalPages={5} onPageChange={onPageChange} />);\n\n    expect(screen.getByLabelText(\"Go to first page\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to previous page\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to next page\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to last page\")).toBeInTheDocument();\n});\n\ntest(\"shows all page numbers for small page count\", () => {\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={2} totalPages={5} onPageChange={onPageChange} />);\n\n    expect(screen.getByLabelText(\"Go to page 1\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to page 2\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to page 3\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to page 4\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to page 5\")).toBeInTheDocument();\n});\n\ntest(\"shows ellipsis for large page count\", () => {\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={5} totalPages={20} onPageChange={onPageChange} />);\n\n    expect(screen.getAllByText(\"...\")).toHaveLength(1);\n});\n\ntest(\"marks current page as active\", () => {\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={3} totalPages={5} onPageChange={onPageChange} />);\n\n    const currentPageButton = screen.getByLabelText(\"Go to page 3\");\n    expect(currentPageButton).toHaveClass(\"pagination-active\");\n    expect(currentPageButton).toHaveAttribute(\"aria-current\", \"page\");\n});\n\ntest(\"calls onPageChange when page button is clicked\", async () => {\n    const user = userEvent.setup();\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={2} totalPages={5} onPageChange={onPageChange} />);\n\n    await user.click(screen.getByLabelText(\"Go to page 4\"));\n    expect(onPageChange).toHaveBeenCalledWith(4);\n});\n\ntest(\"calls onPageChange for navigation buttons\", async () => {\n    const user = userEvent.setup();\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={3} totalPages={5} onPageChange={onPageChange} />);\n\n    await user.click(screen.getByLabelText(\"Go to previous page\"));\n    expect(onPageChange).toHaveBeenCalledWith(2);\n\n    await user.click(screen.getByLabelText(\"Go to next page\"));\n    expect(onPageChange).toHaveBeenCalledWith(4);\n\n    await user.click(screen.getByLabelText(\"Go to first page\"));\n    expect(onPageChange).toHaveBeenCalledWith(1);\n\n    await user.click(screen.getByLabelText(\"Go to last page\"));\n    expect(onPageChange).toHaveBeenCalledWith(5);\n});\n\ntest(\"disables navigation buttons at boundaries\", () => {\n    const onPageChange = vi.fn();\n\n    // First page\n    render(<Pagination currentPage={1} totalPages={5} onPageChange={onPageChange} />);\n    expect(screen.getByLabelText(\"Go to first page\")).toBeDisabled();\n    expect(screen.getByLabelText(\"Go to previous page\")).toBeDisabled();\n});\n\ntest(\"hides first/last buttons when showFirstLast is false\", () => {\n    const onPageChange = vi.fn();\n    render(\n        <Pagination\n            currentPage={2}\n            totalPages={5}\n            onPageChange={onPageChange}\n            showFirstLast={false}\n        />\n    );\n\n    expect(screen.queryByLabelText(\"Go to first page\")).not.toBeInTheDocument();\n    expect(screen.queryByLabelText(\"Go to last page\")).not.toBeInTheDocument();\n});\n\ntest(\"hides prev/next buttons when showPrevNext is false\", () => {\n    const onPageChange = vi.fn();\n    render(\n        <Pagination\n            currentPage={2}\n            totalPages={5}\n            onPageChange={onPageChange}\n            showPrevNext={false}\n        />\n    );\n\n    expect(screen.queryByLabelText(\"Go to previous page\")).not.toBeInTheDocument();\n    expect(screen.queryByLabelText(\"Go to next page\")).not.toBeInTheDocument();\n});\n\ntest(\"applies size and variant classes\", () => {\n    const onPageChange = vi.fn();\n    const { container } = render(\n        <Pagination\n            currentPage={2}\n            totalPages={5}\n            onPageChange={onPageChange}\n            size=\"lg\"\n            variant=\"outlined\"\n        />\n    );\n\n    expect(container.firstChild).toHaveClass(\"pagination-lg\", \"pagination-outlined\");\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n    const user = userEvent.setup();\n    const onPageChange = vi.fn();\n    render(\n        <Pagination\n            currentPage={2}\n            totalPages={5}\n            onPageChange={onPageChange}\n            disabled\n        />\n    );\n\n    const pageButton = screen.getByLabelText(\"Go to page 3\");\n    await user.click(pageButton);\n    expect(onPageChange).not.toHaveBeenCalled();\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface PaginationProps extends React.HTMLAttributes<HTMLElement> {\n    currentPage: number;\n    totalPages: number;\n    onPageChange: (page: number) => void;\n    showFirstLast?: boolean;\n    showPrevNext?: boolean;\n    siblingCount?: number;\n    size?: \"sm\" | \"md\" | \"lg\";\n    variant?: \"default\" | \"outlined\" | \"minimal\";\n    disabled?: boolean;\n}\n\nconst classesBySize: Record<NonNullable<PaginationProps[\"size\"]>, string> = {\n    sm: \"pagination pagination-sm\",\n    md: \"pagination pagination-md\",\n    lg: \"pagination pagination-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<PaginationProps[\"variant\"]>, string> = {\n    default: \"pagination-default\",\n    outlined: \"pagination-outlined\",\n    minimal: \"pagination-minimal\",\n};\n\nexport const Pagination = React.forwardRef<HTMLElement, PaginationProps>(\n    ({\n        currentPage,\n        totalPages,\n        onPageChange,\n        showFirstLast = true,\n        showPrevNext = true,\n        siblingCount = 1,\n        size = \"md\",\n        variant = \"default\",\n        disabled = false,\n        className,\n        ...rest\n    }, ref) => {\n        const classes = `${classesBySize[size]} ${classesByVariant[variant]} ${className || \"\"}`.trim();\n\n        const getPageNumbers = () => {\n            const totalNumbers = siblingCount * 2 + 3; // Current + siblings + first/last\n            const totalBlocks = totalNumbers + 2; // Including ellipsis\n\n            if (totalPages > totalBlocks) {\n                const startPage = Math.max(2, currentPage - siblingCount);\n                const endPage = Math.min(totalPages - 1, currentPage + siblingCount);\n\n                const pages = [];\n                pages.push(1);\n\n                if (startPage > 2) {\n                    pages.push(\"...\");\n                }\n\n                for (let i = startPage; i <= endPage; i++) {\n                    pages.push(i);\n                }\n\n                if (endPage < totalPages - 1) {\n                    pages.push(\"...\");\n                }\n\n                pages.push(totalPages);\n                return pages;\n            }\n\n            return Array.from({ length: totalPages }, (_, i) => i + 1);\n        };\n\n        const handlePageChange = (page: number | string) => {\n            if (typeof page === \"number\" && !disabled) {\n                onPageChange(page);\n            }\n        };\n\n        const pageNumbers = getPageNumbers();\n        const isFirstPage = currentPage === 1;\n        const isLastPage = currentPage === totalPages;\n\n        return (\n            <nav {...rest} ref={ref} className={classes} aria-label=\"Pagination navigation\">\n                <ul className=\"pagination-list\">\n                    {showFirstLast && (\n                        <li className=\"pagination-item\">\n                            <button\n                                type=\"button\"\n                                className={`pagination-button pagination-first ${isFirstPage ? \"pagination-disabled\" : \"\"}`}\n                                onClick={() => handlePageChange(1)}\n                                disabled={disabled || isFirstPage}\n                                aria-label=\"Go to first page\"\n                            >\n                                «\n                            </button>\n                        </li>\n                    )}\n\n                    {showPrevNext && (\n                        <li className=\"pagination-item\">\n                            <button\n                                type=\"button\"\n                                className={`pagination-button pagination-prev ${isFirstPage ? \"pagination-disabled\" : \"\"}`}\n                                onClick={() => handlePageChange(currentPage - 1)}\n                                disabled={disabled || isFirstPage}\n                                aria-label=\"Go to previous page\"\n                            >\n                                ‹\n                            </button>\n                        </li>\n                    )}\n\n                    {pageNumbers.map((page, index) => (\n                        <li key={index} className=\"pagination-item\">\n                            {page === \"...\" ? (\n                                <span className=\"pagination-ellipsis\" aria-hidden=\"true\">\n                                    ...\n                                </span>\n                            ) : (\n                                <button\n                                    type=\"button\"\n                                    className={`pagination-button pagination-page ${page === currentPage ? \"pagination-active\" : \"\"\n                                        }`}\n                                    onClick={() => handlePageChange(page)}\n                                    disabled={disabled}\n                                    aria-label={`Go to page ${page}`}\n                                    aria-current={page === currentPage ? \"page\" : undefined}\n                                >\n                                    {page}\n                                </button>\n                            )}\n                        </li>\n                    ))}\n\n                    {showPrevNext && (\n                        <li className=\"pagination-item\">\n                            <button\n                                type=\"button\"\n                                className={`pagination-button pagination-next ${isLastPage ? \"pagination-disabled\" : \"\"}`}\n                                onClick={() => handlePageChange(currentPage + 1)}\n                                disabled={disabled || isLastPage}\n                                aria-label=\"Go to next page\"\n                            >\n                                ›\n                            </button>\n                        </li>\n                    )}\n\n                    {showFirstLast && (\n                        <li className=\"pagination-item\">\n                            <button\n                                type=\"button\"\n                                className={`pagination-button pagination-last ${isLastPage ? \"pagination-disabled\" : \"\"}`}\n                                onClick={() => handlePageChange(totalPages)}\n                                disabled={disabled || isLastPage}\n                                aria-label=\"Go to last page\"\n                            >\n                                »\n                            </button>\n                        </li>\n                    )}\n                </ul>\n            </nav>\n        );\n    }\n);\nPagination.displayName = \"Pagination\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Pagination } from \"../Pagination\";\n\ntest(\"renders pagination buttons\", () => {\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={2} totalPages={5} onPageChange={onPageChange} />);\n\n    expect(screen.getByLabelText(\"Go to first page\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to previous page\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to next page\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to last page\")).toBeInTheDocument();\n});\n\ntest(\"shows all page numbers for small page count\", () => {\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={2} totalPages={5} onPageChange={onPageChange} />);\n\n    expect(screen.getByLabelText(\"Go to page 1\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to page 2\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to page 3\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to page 4\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to page 5\")).toBeInTheDocument();\n});\n\ntest(\"shows ellipsis for large page count\", () => {\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={5} totalPages={20} onPageChange={onPageChange} />);\n\n    expect(screen.getAllByText(\"...\")).toHaveLength(1);\n});\n\ntest(\"marks current page as active\", () => {\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={3} totalPages={5} onPageChange={onPageChange} />);\n\n    const currentPageButton = screen.getByLabelText(\"Go to page 3\");\n    expect(currentPageButton).toHaveClass(\"pagination-active\");\n    expect(currentPageButton).toHaveAttribute(\"aria-current\", \"page\");\n});\n\ntest(\"calls onPageChange when page button is clicked\", async () => {\n    const user = userEvent.setup();\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={2} totalPages={5} onPageChange={onPageChange} />);\n\n    await user.click(screen.getByLabelText(\"Go to page 4\"));\n    expect(onPageChange).toHaveBeenCalledWith(4);\n});\n\ntest(\"calls onPageChange for navigation buttons\", async () => {\n    const user = userEvent.setup();\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={3} totalPages={5} onPageChange={onPageChange} />);\n\n    await user.click(screen.getByLabelText(\"Go to previous page\"));\n    expect(onPageChange).toHaveBeenCalledWith(2);\n\n    await user.click(screen.getByLabelText(\"Go to next page\"));\n    expect(onPageChange).toHaveBeenCalledWith(4);\n\n    await user.click(screen.getByLabelText(\"Go to first page\"));\n    expect(onPageChange).toHaveBeenCalledWith(1);\n\n    await user.click(screen.getByLabelText(\"Go to last page\"));\n    expect(onPageChange).toHaveBeenCalledWith(5);\n});\n\ntest(\"disables navigation buttons at boundaries\", () => {\n    const onPageChange = vi.fn();\n\n    // First page\n    render(<Pagination currentPage={1} totalPages={5} onPageChange={onPageChange} />);\n    expect(screen.getByLabelText(\"Go to first page\")).toBeDisabled();\n    expect(screen.getByLabelText(\"Go to previous page\")).toBeDisabled();\n});\n\ntest(\"hides first/last buttons when showFirstLast is false\", () => {\n    const onPageChange = vi.fn();\n    render(\n        <Pagination\n            currentPage={2}\n            totalPages={5}\n            onPageChange={onPageChange}\n            showFirstLast={false}\n        />\n    );\n\n    expect(screen.queryByLabelText(\"Go to first page\")).not.toBeInTheDocument();\n    expect(screen.queryByLabelText(\"Go to last page\")).not.toBeInTheDocument();\n});\n\ntest(\"hides prev/next buttons when showPrevNext is false\", () => {\n    const onPageChange = vi.fn();\n    render(\n        <Pagination\n            currentPage={2}\n            totalPages={5}\n            onPageChange={onPageChange}\n            showPrevNext={false}\n        />\n    );\n\n    expect(screen.queryByLabelText(\"Go to previous page\")).not.toBeInTheDocument();\n    expect(screen.queryByLabelText(\"Go to next page\")).not.toBeInTheDocument();\n});\n\ntest(\"applies size and variant classes\", () => {\n    const onPageChange = vi.fn();\n    const { container } = render(\n        <Pagination\n            currentPage={2}\n            totalPages={5}\n            onPageChange={onPageChange}\n            size=\"lg\"\n            variant=\"outlined\"\n        />\n    );\n\n    expect(container.firstChild).toHaveClass(\"pagination-lg\", \"pagination-outlined\");\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n    const user = userEvent.setup();\n    const onPageChange = vi.fn();\n    render(\n        <Pagination\n            currentPage={2}\n            totalPages={5}\n            onPageChange={onPageChange}\n            disabled\n        />\n    );\n\n    const pageButton = screen.getByLabelText(\"Go to page 3\");\n    await user.click(pageButton);\n    expect(onPageChange).not.toHaveBeenCalled();\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface PaginationProps extends React.HTMLAttributes<HTMLElement> {\n    currentPage: number;\n    totalPages: number;\n    onPageChange: (page: number) => void;\n    showFirstLast?: boolean;\n    showPrevNext?: boolean;\n    siblingCount?: number;\n    size?: \"sm\" | \"md\" | \"lg\";\n    variant?: \"default\" | \"outlined\" | \"minimal\";\n    disabled?: boolean;\n}\n\nconst classesBySize: Record<NonNullable<PaginationProps[\"size\"]>, string> = {\n    sm: \"pagination pagination-sm\",\n    md: \"pagination pagination-md\",\n    lg: \"pagination pagination-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<PaginationProps[\"variant\"]>, string> = {\n    default: \"pagination-default\",\n    outlined: \"pagination-outlined\",\n    minimal: \"pagination-minimal\",\n};\n\nexport const Pagination = React.forwardRef<HTMLElement, PaginationProps>(\n    ({\n        currentPage,\n        totalPages,\n        onPageChange,\n        showFirstLast = true,\n        showPrevNext = true,\n        siblingCount = 1,\n        size = \"md\",\n        variant = \"default\",\n        disabled = false,\n        className,\n        ...rest\n    }, ref) => {\n        const classes = `${classesBySize[size]} ${classesByVariant[variant]} ${className || \"\"}`.trim();\n\n        const getPageNumbers = () => {\n            const totalNumbers = siblingCount * 2 + 3; // Current + siblings + first/last\n            const totalBlocks = totalNumbers + 2; // Including ellipsis\n\n            if (totalPages > totalBlocks) {\n                const startPage = Math.max(2, currentPage - siblingCount);\n                const endPage = Math.min(totalPages - 1, currentPage + siblingCount);\n\n                const pages = [];\n                pages.push(1);\n\n                if (startPage > 2) {\n                    pages.push(\"...\");\n                }\n\n                for (let i = startPage; i <= endPage; i++) {\n                    pages.push(i);\n                }\n\n                if (endPage < totalPages - 1) {\n                    pages.push(\"...\");\n                }\n\n                pages.push(totalPages);\n                return pages;\n            }\n\n            return Array.from({ length: totalPages }, (_, i) => i + 1);\n        };\n\n        const handlePageChange = (page: number | string) => {\n            if (typeof page === \"number\" && !disabled) {\n                onPageChange(page);\n            }\n        };\n\n        const pageNumbers = getPageNumbers();\n        const isFirstPage = currentPage === 1;\n        const isLastPage = currentPage === totalPages;\n\n        return (\n            <nav {...rest} ref={ref} className={classes} aria-label=\"Pagination navigation\">\n                <ul className=\"pagination-list\">\n                    {showFirstLast && (\n                        <li className=\"pagination-item\">\n                            <button\n                                type=\"button\"\n                                className={`pagination-button pagination-first ${isFirstPage ? \"pagination-disabled\" : \"\"}`}\n                                onClick={() => handlePageChange(1)}\n                                disabled={disabled || isFirstPage}\n                                aria-label=\"Go to first page\"\n                            >\n                                «\n                            </button>\n                        </li>\n                    )}\n\n                    {showPrevNext && (\n                        <li className=\"pagination-item\">\n                            <button\n                                type=\"button\"\n                                className={`pagination-button pagination-prev ${isFirstPage ? \"pagination-disabled\" : \"\"}`}\n                                onClick={() => handlePageChange(currentPage - 1)}\n                                disabled={disabled || isFirstPage}\n                                aria-label=\"Go to previous page\"\n                            >\n                                ‹\n                            </button>\n                        </li>\n                    )}\n\n                    {pageNumbers.map((page, index) => (\n                        <li key={index} className=\"pagination-item\">\n                            {page === \"...\" ? (\n                                <span className=\"pagination-ellipsis\" aria-hidden=\"true\">\n                                    ...\n                                </span>\n                            ) : (\n                                <button\n                                    type=\"button\"\n                                    className={`pagination-button pagination-page ${page === currentPage ? \"pagination-active\" : \"\"\n                                        }`}\n                                    onClick={() => handlePageChange(page)}\n                                    disabled={disabled}\n                                    aria-label={`Go to page ${page}`}\n                                    aria-current={page === currentPage ? \"page\" : undefined}\n                                >\n                                    {page}\n                                </button>\n                            )}\n                        </li>\n                    ))}\n\n                    {showPrevNext && (\n                        <li className=\"pagination-item\">\n                            <button\n                                type=\"button\"\n                                className={`pagination-button pagination-next ${isLastPage ? \"pagination-disabled\" : \"\"}`}\n                                onClick={() => handlePageChange(currentPage + 1)}\n                                disabled={disabled || isLastPage}\n                                aria-label=\"Go to next page\"\n                            >\n                                ›\n                            </button>\n                        </li>\n                    )}\n\n                    {showFirstLast && (\n                        <li className=\"pagination-item\">\n                            <button\n                                type=\"button\"\n                                className={`pagination-button pagination-last ${isLastPage ? \"pagination-disabled\" : \"\"}`}\n                                onClick={() => handlePageChange(totalPages)}\n                                disabled={disabled || isLastPage}\n                                aria-label=\"Go to last page\"\n                            >\n                                »\n                            </button>\n                        </li>\n                    )}\n                </ul>\n            </nav>\n        );\n    }\n);\nPagination.displayName = \"Pagination\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Pagination } from \"../Pagination\";\n\ntest(\"renders pagination buttons\", () => {\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={2} totalPages={5} onPageChange={onPageChange} />);\n\n    expect(screen.getByLabelText(\"Go to first page\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to previous page\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to next page\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to last page\")).toBeInTheDocument();\n});\n\ntest(\"shows all page numbers for small page count\", () => {\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={2} totalPages={5} onPageChange={onPageChange} />);\n\n    expect(screen.getByLabelText(\"Go to page 1\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to page 2\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to page 3\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to page 4\")).toBeInTheDocument();\n    expect(screen.getByLabelText(\"Go to page 5\")).toBeInTheDocument();\n});\n\ntest(\"shows ellipsis for large page count\", () => {\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={5} totalPages={20} onPageChange={onPageChange} />);\n\n    expect(screen.getAllByText(\"...\")).toHaveLength(1);\n});\n\ntest(\"marks current page as active\", () => {\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={3} totalPages={5} onPageChange={onPageChange} />);\n\n    const currentPageButton = screen.getByLabelText(\"Go to page 3\");\n    expect(currentPageButton).toHaveClass(\"pagination-active\");\n    expect(currentPageButton).toHaveAttribute(\"aria-current\", \"page\");\n});\n\ntest(\"calls onPageChange when page button is clicked\", async () => {\n    const user = userEvent.setup();\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={2} totalPages={5} onPageChange={onPageChange} />);\n\n    await user.click(screen.getByLabelText(\"Go to page 4\"));\n    expect(onPageChange).toHaveBeenCalledWith(4);\n});\n\ntest(\"calls onPageChange for navigation buttons\", async () => {\n    const user = userEvent.setup();\n    const onPageChange = vi.fn();\n    render(<Pagination currentPage={3} totalPages={5} onPageChange={onPageChange} />);\n\n    await user.click(screen.getByLabelText(\"Go to previous page\"));\n    expect(onPageChange).toHaveBeenCalledWith(2);\n\n    await user.click(screen.getByLabelText(\"Go to next page\"));\n    expect(onPageChange).toHaveBeenCalledWith(4);\n\n    await user.click(screen.getByLabelText(\"Go to first page\"));\n    expect(onPageChange).toHaveBeenCalledWith(1);\n\n    await user.click(screen.getByLabelText(\"Go to last page\"));\n    expect(onPageChange).toHaveBeenCalledWith(5);\n});\n\ntest(\"disables navigation buttons at boundaries\", () => {\n    const onPageChange = vi.fn();\n\n    // First page\n    render(<Pagination currentPage={1} totalPages={5} onPageChange={onPageChange} />);\n    expect(screen.getByLabelText(\"Go to first page\")).toBeDisabled();\n    expect(screen.getByLabelText(\"Go to previous page\")).toBeDisabled();\n});\n\ntest(\"hides first/last buttons when showFirstLast is false\", () => {\n    const onPageChange = vi.fn();\n    render(\n        <Pagination\n            currentPage={2}\n            totalPages={5}\n            onPageChange={onPageChange}\n            showFirstLast={false}\n        />\n    );\n\n    expect(screen.queryByLabelText(\"Go to first page\")).not.toBeInTheDocument();\n    expect(screen.queryByLabelText(\"Go to last page\")).not.toBeInTheDocument();\n});\n\ntest(\"hides prev/next buttons when showPrevNext is false\", () => {\n    const onPageChange = vi.fn();\n    render(\n        <Pagination\n            currentPage={2}\n            totalPages={5}\n            onPageChange={onPageChange}\n            showPrevNext={false}\n        />\n    );\n\n    expect(screen.queryByLabelText(\"Go to previous page\")).not.toBeInTheDocument();\n    expect(screen.queryByLabelText(\"Go to next page\")).not.toBeInTheDocument();\n});\n\ntest(\"applies size and variant classes\", () => {\n    const onPageChange = vi.fn();\n    const { container } = render(\n        <Pagination\n            currentPage={2}\n            totalPages={5}\n            onPageChange={onPageChange}\n            size=\"lg\"\n            variant=\"outlined\"\n        />\n    );\n\n    expect(container.firstChild).toHaveClass(\"pagination-lg\", \"pagination-outlined\");\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n    const user = userEvent.setup();\n    const onPageChange = vi.fn();\n    render(\n        <Pagination\n            currentPage={2}\n            totalPages={5}\n            onPageChange={onPageChange}\n            disabled\n        />\n    );\n\n    const pageButton = screen.getByLabelText(\"Go to page 3\");\n    await user.click(pageButton);\n    expect(onPageChange).not.toHaveBeenCalled();\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface PopoverProps {\n  content: React.ReactNode;\n  title?: string;\n  placement?: \"top\" | \"bottom\" | \"left\" | \"right\" | \"topLeft\" | \"topRight\" | \"bottomLeft\" | \"bottomRight\";\n  trigger?: \"hover\" | \"click\" | \"focus\" | \"manual\";\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  disabled?: boolean;\n  arrow?: boolean;\n  offset?: number;\n  children: React.ReactElement;\n  closeOnClickOutside?: boolean;\n}\n\nexport const Popover: React.FC<PopoverProps> = ({\n  content,\n  title,\n  placement = \"top\",\n  trigger = \"hover\",\n  open: controlledOpen,\n  onOpenChange,\n  disabled = false,\n  arrow = true,\n  offset = 8,\n  children,\n  closeOnClickOutside = true,\n}) => {\n  const [internalOpen, setInternalOpen] = React.useState(false);\n  const [triggerRect, setTriggerRect] = React.useState<DOMRect | null>(null);\n  const popoverRef = React.useRef<HTMLDivElement>(null);\n  const triggerRef = React.useRef<HTMLElement>(null);\n  const timeoutRef = React.useRef<NodeJS.Timeout>();\n  const popoverId = React.useId();\n\n  const isControlled = controlledOpen !== undefined;\n  const isOpen = isControlled ? controlledOpen : internalOpen;\n\n  const setOpen = React.useCallback((newOpen: boolean) => {\n    if (disabled) return;\n    \n    if (onOpenChange) {\n      onOpenChange(newOpen);\n    }\n    \n    if (!isControlled) {\n      setInternalOpen(newOpen);\n    }\n  }, [disabled, isControlled, onOpenChange]);\n\n  const updatePosition = React.useCallback(() => {\n    if (triggerRef.current) {\n      setTriggerRect(triggerRef.current.getBoundingClientRect());\n    }\n  }, []);\n\n  const handleMouseEnter = () => {\n    if (trigger === \"hover\") {\n      clearTimeout(timeoutRef.current);\n      updatePosition();\n      setOpen(true);\n    }\n  };\n\n  const handleMouseLeave = () => {\n    if (trigger === \"hover\") {\n      timeoutRef.current = setTimeout(() => setOpen(false), 100);\n    }\n  };\n\n  const handleClick = () => {\n    if (trigger === \"click\") {\n      updatePosition();\n      setOpen(!isOpen);\n    }\n  };\n\n  const handleFocus = () => {\n    if (trigger === \"focus\") {\n      updatePosition();\n      setOpen(true);\n    }\n  };\n\n  const handleBlur = () => {\n    if (trigger === \"focus\") {\n      setOpen(false);\n    }\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Escape\" && isOpen) {\n      setOpen(false);\n      triggerRef.current?.focus();\n    }\n  };\n\n  // Handle click outside\n  React.useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (\n        closeOnClickOutside &&\n        isOpen &&\n        popoverRef.current &&\n        triggerRef.current &&\n        !popoverRef.current.contains(event.target as Node) &&\n        !triggerRef.current.contains(event.target as Node)\n      ) {\n        setOpen(false);\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener(\"mousedown\", handleClickOutside);\n    }\n\n    return () => {\n      document.removeEventListener(\"mousedown\", handleClickOutside);\n    };\n  }, [isOpen, closeOnClickOutside, setOpen]);\n\n  // Update position on scroll/resize\n  React.useEffect(() => {\n    if (isOpen) {\n      const handleUpdate = () => updatePosition();\n      window.addEventListener(\"scroll\", handleUpdate, true);\n      window.addEventListener(\"resize\", handleUpdate);\n      \n      return () => {\n        window.removeEventListener(\"scroll\", handleUpdate, true);\n        window.removeEventListener(\"resize\", handleUpdate);\n      };\n    }\n  }, [isOpen, updatePosition]);\n\n  const getPopoverStyles = (): React.CSSProperties => {\n    if (!triggerRect) return { opacity: 0, pointerEvents: \"none\" };\n\n    const styles: React.CSSProperties = {\n      position: \"fixed\",\n      zIndex: 1000,\n    };\n\n    switch (placement) {\n      case \"top\":\n        styles.left = triggerRect.left + triggerRect.width / 2;\n        styles.top = triggerRect.top - offset;\n        styles.transform = \"translate(-50%, -100%)\";\n        break;\n      case \"bottom\":\n        styles.left = triggerRect.left + triggerRect.width / 2;\n        styles.top = triggerRect.bottom + offset;\n        styles.transform = \"translate(-50%, 0)\";\n        break;\n      case \"left\":\n        styles.left = triggerRect.left - offset;\n        styles.top = triggerRect.top + triggerRect.height / 2;\n        styles.transform = \"translate(-100%, -50%)\";\n        break;\n      case \"right\":\n        styles.left = triggerRect.right + offset;\n        styles.top = triggerRect.top + triggerRect.height / 2;\n        styles.transform = \"translate(0, -50%)\";\n        break;\n      default:\n        break;\n    }\n\n    return styles;\n  };\n\n  const clonedChild = React.cloneElement(children, {\n    ref: triggerRef,\n    onMouseEnter: handleMouseEnter,\n    onMouseLeave: handleMouseLeave,\n    onClick: handleClick,\n    onFocus: handleFocus,\n    onBlur: handleBlur,\n    onKeyDown: handleKeyDown,\n    \"aria-describedby\": isOpen ? popoverId : undefined,\n    \"aria-expanded\": trigger === \"click\" ? isOpen : undefined,\n  });\n\n  return (\n    <>\n      {clonedChild}\n      {isOpen && (\n        <div\n          ref={popoverRef}\n          id={popoverId}\n          className={`popover popover-${placement} ${arrow ? \"popover-arrow\" : \"\"}`}\n          style={getPopoverStyles()}\n          role=\"tooltip\"\n          onMouseEnter={() => trigger === \"hover\" && clearTimeout(timeoutRef.current)}\n          onMouseLeave={() => trigger === \"hover\" && handleMouseLeave()}\n        >\n          {title && <div className=\"popover-title\">{title}</div>}\n          <div className=\"popover-content\">{content}</div>\n          {arrow && <div className=\"popover-arrow-element\" />}\n        </div>\n      )}\n    </>\n  );\n};\n\nPopover.displayName = \"Popover\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Popover } from \"../Popover\";\n\ntest(\"shows popover on hover when trigger is hover\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"hover\">\n      <button>Hover me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  await user.hover(button);\n  \n  await new Promise(resolve => setTimeout(resolve, 50));\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n  expect(screen.getByText(\"Popover content\")).toBeInTheDocument();\n});\n\ntest(\"hides popover on mouse leave when trigger is hover\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"hover\">\n      <button>Hover me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  await user.hover(button);\n  await user.unhover(button);\n  \n  await new Promise(resolve => setTimeout(resolve, 150));\n  expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"shows popover on click when trigger is click\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"click\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  await user.click(button);\n  \n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n  expect(button).toHaveAttribute(\"aria-expanded\", \"true\");\n});\n\ntest(\"toggles popover on repeated clicks\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"click\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  \n  await user.click(button);\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n  \n  await user.click(button);\n  expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"shows popover on focus when trigger is focus\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"focus\">\n      <button>Focus me</button>\n    </Popover>\n  );\n\n  await user.tab();\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n});\n\ntest(\"shows title when provided\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Content\" title=\"Popover Title\" trigger=\"click\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  await user.click(screen.getByRole(\"button\"));\n  expect(screen.getByText(\"Popover Title\")).toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onOpenChange = vi.fn();\n  render(\n    <Popover content=\"Content\" open={true} onOpenChange={onOpenChange}>\n      <button>Button</button>\n    </Popover>\n  );\n\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n});\n\ntest(\"calls onOpenChange in controlled mode\", async () => {\n  const user = userEvent.setup();\n  const onOpenChange = vi.fn();\n  render(\n    <Popover \n      content=\"Content\" \n      trigger=\"click\" \n      open={false} \n      onOpenChange={onOpenChange}\n    >\n      <button>Button</button>\n    </Popover>\n  );\n\n  await user.click(screen.getByRole(\"button\"));\n  expect(onOpenChange).toHaveBeenCalledWith(true);\n});\n\ntest(\"closes on escape key\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Content\" trigger=\"click\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  await user.click(button);\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n\n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"does not show when disabled\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Content\" trigger=\"click\" disabled>\n      <button>Click me</button>\n    </Popover>\n  );\n\n  await user.click(screen.getByRole(\"button\"));\n  expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"applies placement classes\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Content\" trigger=\"click\" placement=\"bottom\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  await user.click(screen.getByRole(\"button\"));\n  const popover = screen.getByRole(\"tooltip\");\n  expect(popover).toHaveClass(\"popover-bottom\");\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface PopoverProps {\n  content: React.ReactNode;\n  title?: string;\n  placement?: \"top\" | \"bottom\" | \"left\" | \"right\" | \"topLeft\" | \"topRight\" | \"bottomLeft\" | \"bottomRight\";\n  trigger?: \"hover\" | \"click\" | \"focus\" | \"manual\";\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  disabled?: boolean;\n  arrow?: boolean;\n  offset?: number;\n  children: React.ReactElement;\n  closeOnClickOutside?: boolean;\n}\n\nexport const Popover: React.FC<PopoverProps> = ({\n  content,\n  title,\n  placement = \"top\",\n  trigger = \"hover\",\n  open: controlledOpen,\n  onOpenChange,\n  disabled = false,\n  arrow = true,\n  offset = 8,\n  children,\n  closeOnClickOutside = true,\n}) => {\n  const [internalOpen, setInternalOpen] = React.useState(false);\n  const [triggerRect, setTriggerRect] = React.useState<DOMRect | null>(null);\n  const popoverRef = React.useRef<HTMLDivElement>(null);\n  const triggerRef = React.useRef<HTMLElement>(null);\n  const timeoutRef = React.useRef<NodeJS.Timeout>();\n  const popoverId = React.useId();\n\n  const isControlled = controlledOpen !== undefined;\n  const isOpen = isControlled ? controlledOpen : internalOpen;\n\n  const setOpen = React.useCallback((newOpen: boolean) => {\n    if (disabled) return;\n    \n    if (onOpenChange) {\n      onOpenChange(newOpen);\n    }\n    \n    if (!isControlled) {\n      setInternalOpen(newOpen);\n    }\n  }, [disabled, isControlled, onOpenChange]);\n\n  const updatePosition = React.useCallback(() => {\n    if (triggerRef.current) {\n      setTriggerRect(triggerRef.current.getBoundingClientRect());\n    }\n  }, []);\n\n  const handleMouseEnter = () => {\n    if (trigger === \"hover\") {\n      clearTimeout(timeoutRef.current);\n      updatePosition();\n      setOpen(true);\n    }\n  };\n\n  const handleMouseLeave = () => {\n    if (trigger === \"hover\") {\n      timeoutRef.current = setTimeout(() => setOpen(false), 100);\n    }\n  };\n\n  const handleClick = () => {\n    if (trigger === \"click\") {\n      updatePosition();\n      setOpen(!isOpen);\n    }\n  };\n\n  const handleFocus = () => {\n    if (trigger === \"focus\") {\n      updatePosition();\n      setOpen(true);\n    }\n  };\n\n  const handleBlur = () => {\n    if (trigger === \"focus\") {\n      setOpen(false);\n    }\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Escape\" && isOpen) {\n      setOpen(false);\n      triggerRef.current?.focus();\n    }\n  };\n\n  // Handle click outside\n  React.useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (\n        closeOnClickOutside &&\n        isOpen &&\n        popoverRef.current &&\n        triggerRef.current &&\n        !popoverRef.current.contains(event.target as Node) &&\n        !triggerRef.current.contains(event.target as Node)\n      ) {\n        setOpen(false);\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener(\"mousedown\", handleClickOutside);\n    }\n\n    return () => {\n      document.removeEventListener(\"mousedown\", handleClickOutside);\n    };\n  }, [isOpen, closeOnClickOutside, setOpen]);\n\n  // Update position on scroll/resize\n  React.useEffect(() => {\n    if (isOpen) {\n      const handleUpdate = () => updatePosition();\n      window.addEventListener(\"scroll\", handleUpdate, true);\n      window.addEventListener(\"resize\", handleUpdate);\n      \n      return () => {\n        window.removeEventListener(\"scroll\", handleUpdate, true);\n        window.removeEventListener(\"resize\", handleUpdate);\n      };\n    }\n  }, [isOpen, updatePosition]);\n\n  const getPopoverStyles = (): React.CSSProperties => {\n    if (!triggerRect) return { opacity: 0, pointerEvents: \"none\" };\n\n    const styles: React.CSSProperties = {\n      position: \"fixed\",\n      zIndex: 1000,\n    };\n\n    switch (placement) {\n      case \"top\":\n        styles.left = triggerRect.left + triggerRect.width / 2;\n        styles.top = triggerRect.top - offset;\n        styles.transform = \"translate(-50%, -100%)\";\n        break;\n      case \"bottom\":\n        styles.left = triggerRect.left + triggerRect.width / 2;\n        styles.top = triggerRect.bottom + offset;\n        styles.transform = \"translate(-50%, 0)\";\n        break;\n      case \"left\":\n        styles.left = triggerRect.left - offset;\n        styles.top = triggerRect.top + triggerRect.height / 2;\n        styles.transform = \"translate(-100%, -50%)\";\n        break;\n      case \"right\":\n        styles.left = triggerRect.right + offset;\n        styles.top = triggerRect.top + triggerRect.height / 2;\n        styles.transform = \"translate(0, -50%)\";\n        break;\n      default:\n        break;\n    }\n\n    return styles;\n  };\n\n  const clonedChild = React.cloneElement(children, {\n    ref: triggerRef,\n    onMouseEnter: handleMouseEnter,\n    onMouseLeave: handleMouseLeave,\n    onClick: handleClick,\n    onFocus: handleFocus,\n    onBlur: handleBlur,\n    onKeyDown: handleKeyDown,\n    \"aria-describedby\": isOpen ? popoverId : undefined,\n    \"aria-expanded\": trigger === \"click\" ? isOpen : undefined,\n  });\n\n  return (\n    <>\n      {clonedChild}\n      {isOpen && (\n        <div\n          ref={popoverRef}\n          id={popoverId}\n          className={`popover popover-${placement} ${arrow ? \"popover-arrow\" : \"\"}`}\n          style={getPopoverStyles()}\n          role=\"tooltip\"\n          onMouseEnter={() => trigger === \"hover\" && clearTimeout(timeoutRef.current)}\n          onMouseLeave={() => trigger === \"hover\" && handleMouseLeave()}\n        >\n          {title && <div className=\"popover-title\">{title}</div>}\n          <div className=\"popover-content\">{content}</div>\n          {arrow && <div className=\"popover-arrow-element\" />}\n        </div>\n      )}\n    </>\n  );\n};\n\nPopover.displayName = \"Popover\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Popover } from \"../Popover\";\n\ntest(\"shows popover on hover when trigger is hover\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"hover\">\n      <button>Hover me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  await user.hover(button);\n  \n  await new Promise(resolve => setTimeout(resolve, 50));\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n  expect(screen.getByText(\"Popover content\")).toBeInTheDocument();\n});\n\ntest(\"hides popover on mouse leave when trigger is hover\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"hover\">\n      <button>Hover me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  await user.hover(button);\n  await user.unhover(button);\n  \n  await new Promise(resolve => setTimeout(resolve, 150));\n  expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"shows popover on click when trigger is click\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"click\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  await user.click(button);\n  \n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n  expect(button).toHaveAttribute(\"aria-expanded\", \"true\");\n});\n\ntest(\"toggles popover on repeated clicks\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"click\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  \n  await user.click(button);\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n  \n  await user.click(button);\n  expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"shows popover on focus when trigger is focus\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"focus\">\n      <button>Focus me</button>\n    </Popover>\n  );\n\n  await user.tab();\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n});\n\ntest(\"shows title when provided\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Content\" title=\"Popover Title\" trigger=\"click\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  await user.click(screen.getByRole(\"button\"));\n  expect(screen.getByText(\"Popover Title\")).toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onOpenChange = vi.fn();\n  render(\n    <Popover content=\"Content\" open={true} onOpenChange={onOpenChange}>\n      <button>Button</button>\n    </Popover>\n  );\n\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n});\n\ntest(\"calls onOpenChange in controlled mode\", async () => {\n  const user = userEvent.setup();\n  const onOpenChange = vi.fn();\n  render(\n    <Popover \n      content=\"Content\" \n      trigger=\"click\" \n      open={false} \n      onOpenChange={onOpenChange}\n    >\n      <button>Button</button>\n    </Popover>\n  );\n\n  await user.click(screen.getByRole(\"button\"));\n  expect(onOpenChange).toHaveBeenCalledWith(true);\n});\n\ntest(\"closes on escape key\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Content\" trigger=\"click\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  await user.click(button);\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n\n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"does not show when disabled\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Content\" trigger=\"click\" disabled>\n      <button>Click me</button>\n    </Popover>\n  );\n\n  await user.click(screen.getByRole(\"button\"));\n  expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"applies placement classes\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Content\" trigger=\"click\" placement=\"bottom\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  await user.click(screen.getByRole(\"button\"));\n  const popover = screen.getByRole(\"tooltip\");\n  expect(popover).toHaveClass(\"popover-bottom\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface PopoverProps {\n  content: React.ReactNode;\n  title?: string;\n  placement?: \"top\" | \"bottom\" | \"left\" | \"right\" | \"topLeft\" | \"topRight\" | \"bottomLeft\" | \"bottomRight\";\n  trigger?: \"hover\" | \"click\" | \"focus\" | \"manual\";\n  open?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  disabled?: boolean;\n  arrow?: boolean;\n  offset?: number;\n  children: React.ReactElement;\n  closeOnClickOutside?: boolean;\n}\n\nexport const Popover: React.FC<PopoverProps> = ({\n  content,\n  title,\n  placement = \"top\",\n  trigger = \"hover\",\n  open: controlledOpen,\n  onOpenChange,\n  disabled = false,\n  arrow = true,\n  offset = 8,\n  children,\n  closeOnClickOutside = true,\n}) => {\n  const [internalOpen, setInternalOpen] = React.useState(false);\n  const [triggerRect, setTriggerRect] = React.useState<DOMRect | null>(null);\n  const popoverRef = React.useRef<HTMLDivElement>(null);\n  const triggerRef = React.useRef<HTMLElement>(null);\n  const timeoutRef = React.useRef<NodeJS.Timeout>();\n  const popoverId = React.useId();\n\n  const isControlled = controlledOpen !== undefined;\n  const isOpen = isControlled ? controlledOpen : internalOpen;\n\n  const setOpen = React.useCallback((newOpen: boolean) => {\n    if (disabled) return;\n    \n    if (onOpenChange) {\n      onOpenChange(newOpen);\n    }\n    \n    if (!isControlled) {\n      setInternalOpen(newOpen);\n    }\n  }, [disabled, isControlled, onOpenChange]);\n\n  const updatePosition = React.useCallback(() => {\n    if (triggerRef.current) {\n      setTriggerRect(triggerRef.current.getBoundingClientRect());\n    }\n  }, []);\n\n  const handleMouseEnter = () => {\n    if (trigger === \"hover\") {\n      clearTimeout(timeoutRef.current);\n      updatePosition();\n      setOpen(true);\n    }\n  };\n\n  const handleMouseLeave = () => {\n    if (trigger === \"hover\") {\n      timeoutRef.current = setTimeout(() => setOpen(false), 100);\n    }\n  };\n\n  const handleClick = () => {\n    if (trigger === \"click\") {\n      updatePosition();\n      setOpen(!isOpen);\n    }\n  };\n\n  const handleFocus = () => {\n    if (trigger === \"focus\") {\n      updatePosition();\n      setOpen(true);\n    }\n  };\n\n  const handleBlur = () => {\n    if (trigger === \"focus\") {\n      setOpen(false);\n    }\n  };\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Escape\" && isOpen) {\n      setOpen(false);\n      triggerRef.current?.focus();\n    }\n  };\n\n  // Handle click outside\n  React.useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (\n        closeOnClickOutside &&\n        isOpen &&\n        popoverRef.current &&\n        triggerRef.current &&\n        !popoverRef.current.contains(event.target as Node) &&\n        !triggerRef.current.contains(event.target as Node)\n      ) {\n        setOpen(false);\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener(\"mousedown\", handleClickOutside);\n    }\n\n    return () => {\n      document.removeEventListener(\"mousedown\", handleClickOutside);\n    };\n  }, [isOpen, closeOnClickOutside, setOpen]);\n\n  // Update position on scroll/resize\n  React.useEffect(() => {\n    if (isOpen) {\n      const handleUpdate = () => updatePosition();\n      window.addEventListener(\"scroll\", handleUpdate, true);\n      window.addEventListener(\"resize\", handleUpdate);\n      \n      return () => {\n        window.removeEventListener(\"scroll\", handleUpdate, true);\n        window.removeEventListener(\"resize\", handleUpdate);\n      };\n    }\n  }, [isOpen, updatePosition]);\n\n  const getPopoverStyles = (): React.CSSProperties => {\n    if (!triggerRect) return { opacity: 0, pointerEvents: \"none\" };\n\n    const styles: React.CSSProperties = {\n      position: \"fixed\",\n      zIndex: 1000,\n    };\n\n    switch (placement) {\n      case \"top\":\n        styles.left = triggerRect.left + triggerRect.width / 2;\n        styles.top = triggerRect.top - offset;\n        styles.transform = \"translate(-50%, -100%)\";\n        break;\n      case \"bottom\":\n        styles.left = triggerRect.left + triggerRect.width / 2;\n        styles.top = triggerRect.bottom + offset;\n        styles.transform = \"translate(-50%, 0)\";\n        break;\n      case \"left\":\n        styles.left = triggerRect.left - offset;\n        styles.top = triggerRect.top + triggerRect.height / 2;\n        styles.transform = \"translate(-100%, -50%)\";\n        break;\n      case \"right\":\n        styles.left = triggerRect.right + offset;\n        styles.top = triggerRect.top + triggerRect.height / 2;\n        styles.transform = \"translate(0, -50%)\";\n        break;\n      default:\n        break;\n    }\n\n    return styles;\n  };\n\n  const clonedChild = React.cloneElement(children, {\n    ref: triggerRef,\n    onMouseEnter: handleMouseEnter,\n    onMouseLeave: handleMouseLeave,\n    onClick: handleClick,\n    onFocus: handleFocus,\n    onBlur: handleBlur,\n    onKeyDown: handleKeyDown,\n    \"aria-describedby\": isOpen ? popoverId : undefined,\n    \"aria-expanded\": trigger === \"click\" ? isOpen : undefined,\n  });\n\n  return (\n    <>\n      {clonedChild}\n      {isOpen && (\n        <div\n          ref={popoverRef}\n          id={popoverId}\n          className={`popover popover-${placement} ${arrow ? \"popover-arrow\" : \"\"}`}\n          style={getPopoverStyles()}\n          role=\"tooltip\"\n          onMouseEnter={() => trigger === \"hover\" && clearTimeout(timeoutRef.current)}\n          onMouseLeave={() => trigger === \"hover\" && handleMouseLeave()}\n        >\n          {title && <div className=\"popover-title\">{title}</div>}\n          <div className=\"popover-content\">{content}</div>\n          {arrow && <div className=\"popover-arrow-element\" />}\n        </div>\n      )}\n    </>\n  );\n};\n\nPopover.displayName = \"Popover\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Popover } from \"../Popover\";\n\ntest(\"shows popover on hover when trigger is hover\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"hover\">\n      <button>Hover me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  await user.hover(button);\n  \n  await new Promise(resolve => setTimeout(resolve, 50));\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n  expect(screen.getByText(\"Popover content\")).toBeInTheDocument();\n});\n\ntest(\"hides popover on mouse leave when trigger is hover\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"hover\">\n      <button>Hover me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  await user.hover(button);\n  await user.unhover(button);\n  \n  await new Promise(resolve => setTimeout(resolve, 150));\n  expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"shows popover on click when trigger is click\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"click\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  await user.click(button);\n  \n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n  expect(button).toHaveAttribute(\"aria-expanded\", \"true\");\n});\n\ntest(\"toggles popover on repeated clicks\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"click\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  \n  await user.click(button);\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n  \n  await user.click(button);\n  expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"shows popover on focus when trigger is focus\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Popover content\" trigger=\"focus\">\n      <button>Focus me</button>\n    </Popover>\n  );\n\n  await user.tab();\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n});\n\ntest(\"shows title when provided\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Content\" title=\"Popover Title\" trigger=\"click\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  await user.click(screen.getByRole(\"button\"));\n  expect(screen.getByText(\"Popover Title\")).toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onOpenChange = vi.fn();\n  render(\n    <Popover content=\"Content\" open={true} onOpenChange={onOpenChange}>\n      <button>Button</button>\n    </Popover>\n  );\n\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n});\n\ntest(\"calls onOpenChange in controlled mode\", async () => {\n  const user = userEvent.setup();\n  const onOpenChange = vi.fn();\n  render(\n    <Popover \n      content=\"Content\" \n      trigger=\"click\" \n      open={false} \n      onOpenChange={onOpenChange}\n    >\n      <button>Button</button>\n    </Popover>\n  );\n\n  await user.click(screen.getByRole(\"button\"));\n  expect(onOpenChange).toHaveBeenCalledWith(true);\n});\n\ntest(\"closes on escape key\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Content\" trigger=\"click\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  const button = screen.getByRole(\"button\");\n  await user.click(button);\n  expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n\n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"does not show when disabled\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Content\" trigger=\"click\" disabled>\n      <button>Click me</button>\n    </Popover>\n  );\n\n  await user.click(screen.getByRole(\"button\"));\n  expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"applies placement classes\", async () => {\n  const user = userEvent.setup();\n  render(\n    <Popover content=\"Content\" trigger=\"click\" placement=\"bottom\">\n      <button>Click me</button>\n    </Popover>\n  );\n\n  await user.click(screen.getByRole(\"button\"));\n  const popover = screen.getByRole(\"tooltip\");\n  expect(popover).toHaveClass(\"popover-bottom\");\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface ProgressBarProps extends React.HTMLAttributes<HTMLDivElement> {\n    value: number;\n    max?: number;\n    size?: \"sm\" | \"md\" | \"lg\";\n    variant?: \"default\" | \"success\" | \"warning\" | \"error\";\n    showLabel?: boolean;\n    label?: string;\n}\n\nconst classesBySize: Record<NonNullable<ProgressBarProps[\"size\"]>, string> = {\n    sm: \"progress progress-sm\",\n    md: \"progress progress-md\",\n    lg: \"progress progress-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<ProgressBarProps[\"variant\"]>, string> = {\n    default: \"progress-default\",\n    success: \"progress-success\",\n    warning: \"progress-warning\",\n    error: \"progress-error\",\n};\n\nexport const ProgressBar = React.forwardRef<HTMLDivElement, ProgressBarProps>(\n    ({\n        value,\n        max = 100,\n        size = \"md\",\n        variant = \"default\",\n        showLabel = false,\n        label,\n        className,\n        ...rest\n    }, ref) => {\n        const percentage = Math.min(Math.max((value / max) * 100, 0), 100);\n        const classes = `${classesBySize[size]} ${classesByVariant[variant]} ${className || \"\"}`.trim();\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                role=\"progressbar\"\n                aria-valuenow={value}\n                aria-valuemin={0}\n                aria-valuemax={max}\n                aria-label={label}\n            >\n                <div\n                    className=\"progress-bar\"\n                    style={{ width: `${percentage}%` }}\n                />\n                {showLabel && (\n                    <span className=\"progress-label\">\n                        {label || `${Math.round(percentage)}%`}\n                    </span>\n                )}\n            </div>\n        );\n    }\n);\nProgressBar.displayName = \"ProgressBar\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { ProgressBar } from \"../ProgressBar\";\n\ntest(\"renders with correct progress value\", () => {\n    render(<ProgressBar value={50} />);\n    const progressbar = screen.getByRole(\"progressbar\");\n    expect(progressbar).toHaveAttribute(\"aria-valuenow\", \"50\");\n    expect(progressbar).toHaveAttribute(\"aria-valuemax\", \"100\");\n});\n\ntest(\"calculates percentage correctly\", () => {\n    render(<ProgressBar value={25} max={100} />);\n    const bar = screen.getByRole(\"progressbar\").querySelector(\".progress-bar\");\n    expect(bar).toHaveStyle({ width: \"25%\" });\n});\n\ntest(\"handles custom max value\", () => {\n    render(<ProgressBar value={5} max={10} />);\n    const progressbar = screen.getByRole(\"progressbar\");\n    expect(progressbar).toHaveAttribute(\"aria-valuemax\", \"10\");\n    const bar = progressbar.querySelector(\".progress-bar\");\n    expect(bar).toHaveStyle({ width: \"50%\" });\n});\n\ntest(\"shows label when enabled\", () => {\n    render(<ProgressBar value={75} showLabel />);\n    expect(screen.getByText(\"75%\")).toBeInTheDocument();\n});\n\ntest(\"shows custom label\", () => {\n    render(<ProgressBar value={30} showLabel label=\"Loading files...\" />);\n    expect(screen.getByText(\"Loading files...\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n    render(<ProgressBar value={50} variant=\"success\" />);\n    expect(screen.getByRole(\"progressbar\")).toHaveClass(\"progress-success\");\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface ProgressBarProps extends React.HTMLAttributes<HTMLDivElement> {\n    value: number;\n    max?: number;\n    size?: \"sm\" | \"md\" | \"lg\";\n    variant?: \"default\" | \"success\" | \"warning\" | \"error\";\n    showLabel?: boolean;\n    label?: string;\n}\n\nconst classesBySize: Record<NonNullable<ProgressBarProps[\"size\"]>, string> = {\n    sm: \"progress progress-sm\",\n    md: \"progress progress-md\",\n    lg: \"progress progress-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<ProgressBarProps[\"variant\"]>, string> = {\n    default: \"progress-default\",\n    success: \"progress-success\",\n    warning: \"progress-warning\",\n    error: \"progress-error\",\n};\n\nexport const ProgressBar = React.forwardRef<HTMLDivElement, ProgressBarProps>(\n    ({\n        value,\n        max = 100,\n        size = \"md\",\n        variant = \"default\",\n        showLabel = false,\n        label,\n        className,\n        ...rest\n    }, ref) => {\n        const percentage = Math.min(Math.max((value / max) * 100, 0), 100);\n        const classes = `${classesBySize[size]} ${classesByVariant[variant]} ${className || \"\"}`.trim();\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                role=\"progressbar\"\n                aria-valuenow={value}\n                aria-valuemin={0}\n                aria-valuemax={max}\n                aria-label={label}\n            >\n                <div\n                    className=\"progress-bar\"\n                    style={{ width: `${percentage}%` }}\n                />\n                {showLabel && (\n                    <span className=\"progress-label\">\n                        {label || `${Math.round(percentage)}%`}\n                    </span>\n                )}\n            </div>\n        );\n    }\n);\nProgressBar.displayName = \"ProgressBar\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { ProgressBar } from \"../ProgressBar\";\n\ntest(\"renders with correct progress value\", () => {\n    render(<ProgressBar value={50} />);\n    const progressbar = screen.getByRole(\"progressbar\");\n    expect(progressbar).toHaveAttribute(\"aria-valuenow\", \"50\");\n    expect(progressbar).toHaveAttribute(\"aria-valuemax\", \"100\");\n});\n\ntest(\"calculates percentage correctly\", () => {\n    render(<ProgressBar value={25} max={100} />);\n    const bar = screen.getByRole(\"progressbar\").querySelector(\".progress-bar\");\n    expect(bar).toHaveStyle({ width: \"25%\" });\n});\n\ntest(\"handles custom max value\", () => {\n    render(<ProgressBar value={5} max={10} />);\n    const progressbar = screen.getByRole(\"progressbar\");\n    expect(progressbar).toHaveAttribute(\"aria-valuemax\", \"10\");\n    const bar = progressbar.querySelector(\".progress-bar\");\n    expect(bar).toHaveStyle({ width: \"50%\" });\n});\n\ntest(\"shows label when enabled\", () => {\n    render(<ProgressBar value={75} showLabel />);\n    expect(screen.getByText(\"75%\")).toBeInTheDocument();\n});\n\ntest(\"shows custom label\", () => {\n    render(<ProgressBar value={30} showLabel label=\"Loading files...\" />);\n    expect(screen.getByText(\"Loading files...\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n    render(<ProgressBar value={50} variant=\"success\" />);\n    expect(screen.getByRole(\"progressbar\")).toHaveClass(\"progress-success\");\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface ProgressBarProps extends React.HTMLAttributes<HTMLDivElement> {\n    value: number;\n    max?: number;\n    size?: \"sm\" | \"md\" | \"lg\";\n    variant?: \"default\" | \"success\" | \"warning\" | \"error\";\n    showLabel?: boolean;\n    label?: string;\n}\n\nconst classesBySize: Record<NonNullable<ProgressBarProps[\"size\"]>, string> = {\n    sm: \"progress progress-sm\",\n    md: \"progress progress-md\",\n    lg: \"progress progress-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<ProgressBarProps[\"variant\"]>, string> = {\n    default: \"progress-default\",\n    success: \"progress-success\",\n    warning: \"progress-warning\",\n    error: \"progress-error\",\n};\n\nexport const ProgressBar = React.forwardRef<HTMLDivElement, ProgressBarProps>(\n    ({\n        value,\n        max = 100,\n        size = \"md\",\n        variant = \"default\",\n        showLabel = false,\n        label,\n        className,\n        ...rest\n    }, ref) => {\n        const percentage = Math.min(Math.max((value / max) * 100, 0), 100);\n        const classes = `${classesBySize[size]} ${classesByVariant[variant]} ${className || \"\"}`.trim();\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                role=\"progressbar\"\n                aria-valuenow={value}\n                aria-valuemin={0}\n                aria-valuemax={max}\n                aria-label={label}\n            >\n                <div\n                    className=\"progress-bar\"\n                    style={{ width: `${percentage}%` }}\n                />\n                {showLabel && (\n                    <span className=\"progress-label\">\n                        {label || `${Math.round(percentage)}%`}\n                    </span>\n                )}\n            </div>\n        );\n    }\n);\nProgressBar.displayName = \"ProgressBar\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { ProgressBar } from \"../ProgressBar\";\n\ntest(\"renders with correct progress value\", () => {\n    render(<ProgressBar value={50} />);\n    const progressbar = screen.getByRole(\"progressbar\");\n    expect(progressbar).toHaveAttribute(\"aria-valuenow\", \"50\");\n    expect(progressbar).toHaveAttribute(\"aria-valuemax\", \"100\");\n});\n\ntest(\"calculates percentage correctly\", () => {\n    render(<ProgressBar value={25} max={100} />);\n    const bar = screen.getByRole(\"progressbar\").querySelector(\".progress-bar\");\n    expect(bar).toHaveStyle({ width: \"25%\" });\n});\n\ntest(\"handles custom max value\", () => {\n    render(<ProgressBar value={5} max={10} />);\n    const progressbar = screen.getByRole(\"progressbar\");\n    expect(progressbar).toHaveAttribute(\"aria-valuemax\", \"10\");\n    const bar = progressbar.querySelector(\".progress-bar\");\n    expect(bar).toHaveStyle({ width: \"50%\" });\n});\n\ntest(\"shows label when enabled\", () => {\n    render(<ProgressBar value={75} showLabel />);\n    expect(screen.getByText(\"75%\")).toBeInTheDocument();\n});\n\ntest(\"shows custom label\", () => {\n    render(<ProgressBar value={30} showLabel label=\"Loading files...\" />);\n    expect(screen.getByText(\"Loading files...\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n    render(<ProgressBar value={50} variant=\"success\" />);\n    expect(screen.getByRole(\"progressbar\")).toHaveClass(\"progress-success\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface RatingProps extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n    value: number;\n    max?: number;\n    readOnly?: boolean;\n    onChange?: (value: number) => void;\n    size?: \"sm\" | \"md\" | \"lg\";\n    icon?: React.ReactNode;\n    emptyIcon?: React.ReactNode;\n}\n\nconst classesBySize: Record<NonNullable<RatingProps[\"size\"]>, string> = {\n    sm: \"rating rating-sm\",\n    md: \"rating rating-md\",\n    lg: \"rating rating-lg\",\n};\n\nexport const Rating = React.forwardRef<HTMLDivElement, RatingProps>(\n    ({\n        value,\n        max = 5,\n        readOnly = false,\n        onChange,\n        size = \"md\",\n        icon = \"★\",\n        emptyIcon = \"☆\",\n        className,\n        ...rest\n    }, ref) => {\n        const [hoverValue, setHoverValue] = React.useState<number | null>(null);\n        const classes = `${classesBySize[size]} ${readOnly ? \"rating-readonly\" : \"\"} ${className || \"\"}`.trim();\n\n        const handleClick = (newValue: number) => {\n            if (!readOnly && onChange) {\n                onChange(newValue);\n            }\n        };\n\n        const handleKeyDown = (event: React.KeyboardEvent, index: number) => {\n            if (readOnly) return;\n\n            switch (event.key) {\n                case \"ArrowRight\":\n                case \"ArrowUp\":\n                    event.preventDefault();\n                    if (onChange && index < max) {\n                        onChange(index + 1);\n                    }\n                    break;\n                case \"ArrowLeft\":\n                case \"ArrowDown\":\n                    event.preventDefault();\n                    if (onChange && index > 1) {\n                        onChange(index - 1);\n                    }\n                    break;\n                case \"Home\":\n                    event.preventDefault();\n                    if (onChange) {\n                        onChange(1);\n                    }\n                    break;\n                case \"End\":\n                    event.preventDefault();\n                    if (onChange) {\n                        onChange(max);\n                    }\n                    break;\n            }\n        };\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                role=\"radiogroup\"\n                aria-label=\"Rating\"\n            >\n                {Array.from({ length: max }, (_, index) => {\n                    const starValue = index + 1;\n                    const isActive = starValue <= (hoverValue ?? value);\n\n                    return (\n                        <button\n                            key={index}\n                            type=\"button\"\n                            className={`rating-star ${isActive ? \"rating-star-active\" : \"\"}`}\n                            onClick={() => handleClick(starValue)}\n                            onMouseEnter={() => !readOnly && setHoverValue(starValue)}\n                            onMouseLeave={() => !readOnly && setHoverValue(null)}\n                            onKeyDown={(e) => handleKeyDown(e, starValue)}\n                            disabled={readOnly}\n                            role=\"radio\"\n                            aria-checked={starValue === value}\n                            aria-label={`${starValue} star${starValue !== 1 ? \"s\" : \"\"}`}\n                        >\n                            {isActive ? icon : emptyIcon}\n                        </button>\n                    );\n                })}\n            </div>\n        );\n    }\n);\nRating.displayName = \"Rating\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Rating } from \"../Rating\";\n\ntest(\"renders correct number of stars\", () => {\n    render(<Rating value={3} max={5} />);\n    expect(screen.getAllByRole(\"radio\")).toHaveLength(5);\n});\n\ntest(\"shows correct active stars\", () => {\n    render(<Rating value={3} />);\n    const stars = screen.getAllByRole(\"radio\");\n\n    expect(stars[0]).toHaveTextContent(\"★\");\n    expect(stars[1]).toHaveTextContent(\"★\");\n    expect(stars[2]).toHaveTextContent(\"★\");\n    expect(stars[3]).toHaveTextContent(\"☆\");\n    expect(stars[4]).toHaveTextContent(\"☆\");\n});\n\ntest(\"calls onChange when star is clicked\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Rating value={2} onChange={onChange} />);\n\n    await user.click(screen.getByLabelText(\"4 stars\"));\n    expect(onChange).toHaveBeenCalledWith(4);\n});\n\ntest(\"is readonly when specified\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Rating value={3} onChange={onChange} readOnly />);\n\n    await user.click(screen.getByLabelText(\"5 stars\"));\n    expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"handles keyboard navigation\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Rating value={3} onChange={onChange} />);\n\n    const star = screen.getByLabelText(\"3 stars\");\n    star.focus();\n    await user.keyboard(\"{ArrowRight}\");\n    expect(onChange).toHaveBeenCalledWith(4);\n});\n\ntest(\"applies size classes\", () => {\n    render(<Rating value={3} size=\"lg\" />);\n    expect(screen.getByRole(\"radiogroup\")).toHaveClass(\"rating\", \"rating-lg\");\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface RatingProps extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n    value: number;\n    max?: number;\n    readOnly?: boolean;\n    onChange?: (value: number) => void;\n    size?: \"sm\" | \"md\" | \"lg\";\n    icon?: React.ReactNode;\n    emptyIcon?: React.ReactNode;\n}\n\nconst classesBySize: Record<NonNullable<RatingProps[\"size\"]>, string> = {\n    sm: \"rating rating-sm\",\n    md: \"rating rating-md\",\n    lg: \"rating rating-lg\",\n};\n\nexport const Rating = React.forwardRef<HTMLDivElement, RatingProps>(\n    ({\n        value,\n        max = 5,\n        readOnly = false,\n        onChange,\n        size = \"md\",\n        icon = \"★\",\n        emptyIcon = \"☆\",\n        className,\n        ...rest\n    }, ref) => {\n        const [hoverValue, setHoverValue] = React.useState<number | null>(null);\n        const classes = `${classesBySize[size]} ${readOnly ? \"rating-readonly\" : \"\"} ${className || \"\"}`.trim();\n\n        const handleClick = (newValue: number) => {\n            if (!readOnly && onChange) {\n                onChange(newValue);\n            }\n        };\n\n        const handleKeyDown = (event: React.KeyboardEvent, index: number) => {\n            if (readOnly) return;\n\n            switch (event.key) {\n                case \"ArrowRight\":\n                case \"ArrowUp\":\n                    event.preventDefault();\n                    if (onChange && index < max) {\n                        onChange(index + 1);\n                    }\n                    break;\n                case \"ArrowLeft\":\n                case \"ArrowDown\":\n                    event.preventDefault();\n                    if (onChange && index > 1) {\n                        onChange(index - 1);\n                    }\n                    break;\n                case \"Home\":\n                    event.preventDefault();\n                    if (onChange) {\n                        onChange(1);\n                    }\n                    break;\n                case \"End\":\n                    event.preventDefault();\n                    if (onChange) {\n                        onChange(max);\n                    }\n                    break;\n            }\n        };\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                role=\"radiogroup\"\n                aria-label=\"Rating\"\n            >\n                {Array.from({ length: max }, (_, index) => {\n                    const starValue = index + 1;\n                    const isActive = starValue <= (hoverValue ?? value);\n\n                    return (\n                        <button\n                            key={index}\n                            type=\"button\"\n                            className={`rating-star ${isActive ? \"rating-star-active\" : \"\"}`}\n                            onClick={() => handleClick(starValue)}\n                            onMouseEnter={() => !readOnly && setHoverValue(starValue)}\n                            onMouseLeave={() => !readOnly && setHoverValue(null)}\n                            onKeyDown={(e) => handleKeyDown(e, starValue)}\n                            disabled={readOnly}\n                            role=\"radio\"\n                            aria-checked={starValue === value}\n                            aria-label={`${starValue} star${starValue !== 1 ? \"s\" : \"\"}`}\n                        >\n                            {isActive ? icon : emptyIcon}\n                        </button>\n                    );\n                })}\n            </div>\n        );\n    }\n);\nRating.displayName = \"Rating\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Rating } from \"../Rating\";\n\ntest(\"renders correct number of stars\", () => {\n    render(<Rating value={3} max={5} />);\n    expect(screen.getAllByRole(\"radio\")).toHaveLength(5);\n});\n\ntest(\"shows correct active stars\", () => {\n    render(<Rating value={3} />);\n    const stars = screen.getAllByRole(\"radio\");\n\n    expect(stars[0]).toHaveTextContent(\"★\");\n    expect(stars[1]).toHaveTextContent(\"★\");\n    expect(stars[2]).toHaveTextContent(\"★\");\n    expect(stars[3]).toHaveTextContent(\"☆\");\n    expect(stars[4]).toHaveTextContent(\"☆\");\n});\n\ntest(\"calls onChange when star is clicked\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Rating value={2} onChange={onChange} />);\n\n    await user.click(screen.getByLabelText(\"4 stars\"));\n    expect(onChange).toHaveBeenCalledWith(4);\n});\n\ntest(\"is readonly when specified\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Rating value={3} onChange={onChange} readOnly />);\n\n    await user.click(screen.getByLabelText(\"5 stars\"));\n    expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"handles keyboard navigation\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Rating value={3} onChange={onChange} />);\n\n    const star = screen.getByLabelText(\"3 stars\");\n    star.focus();\n    await user.keyboard(\"{ArrowRight}\");\n    expect(onChange).toHaveBeenCalledWith(4);\n});\n\ntest(\"applies size classes\", () => {\n    render(<Rating value={3} size=\"lg\" />);\n    expect(screen.getByRole(\"radiogroup\")).toHaveClass(\"rating\", \"rating-lg\");\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface RatingProps extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n    value: number;\n    max?: number;\n    readOnly?: boolean;\n    onChange?: (value: number) => void;\n    size?: \"sm\" | \"md\" | \"lg\";\n    icon?: React.ReactNode;\n    emptyIcon?: React.ReactNode;\n}\n\nconst classesBySize: Record<NonNullable<RatingProps[\"size\"]>, string> = {\n    sm: \"rating rating-sm\",\n    md: \"rating rating-md\",\n    lg: \"rating rating-lg\",\n};\n\nexport const Rating = React.forwardRef<HTMLDivElement, RatingProps>(\n    ({\n        value,\n        max = 5,\n        readOnly = false,\n        onChange,\n        size = \"md\",\n        icon = \"★\",\n        emptyIcon = \"☆\",\n        className,\n        ...rest\n    }, ref) => {\n        const [hoverValue, setHoverValue] = React.useState<number | null>(null);\n        const classes = `${classesBySize[size]} ${readOnly ? \"rating-readonly\" : \"\"} ${className || \"\"}`.trim();\n\n        const handleClick = (newValue: number) => {\n            if (!readOnly && onChange) {\n                onChange(newValue);\n            }\n        };\n\n        const handleKeyDown = (event: React.KeyboardEvent, index: number) => {\n            if (readOnly) return;\n\n            switch (event.key) {\n                case \"ArrowRight\":\n                case \"ArrowUp\":\n                    event.preventDefault();\n                    if (onChange && index < max) {\n                        onChange(index + 1);\n                    }\n                    break;\n                case \"ArrowLeft\":\n                case \"ArrowDown\":\n                    event.preventDefault();\n                    if (onChange && index > 1) {\n                        onChange(index - 1);\n                    }\n                    break;\n                case \"Home\":\n                    event.preventDefault();\n                    if (onChange) {\n                        onChange(1);\n                    }\n                    break;\n                case \"End\":\n                    event.preventDefault();\n                    if (onChange) {\n                        onChange(max);\n                    }\n                    break;\n            }\n        };\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                role=\"radiogroup\"\n                aria-label=\"Rating\"\n            >\n                {Array.from({ length: max }, (_, index) => {\n                    const starValue = index + 1;\n                    const isActive = starValue <= (hoverValue ?? value);\n\n                    return (\n                        <button\n                            key={index}\n                            type=\"button\"\n                            className={`rating-star ${isActive ? \"rating-star-active\" : \"\"}`}\n                            onClick={() => handleClick(starValue)}\n                            onMouseEnter={() => !readOnly && setHoverValue(starValue)}\n                            onMouseLeave={() => !readOnly && setHoverValue(null)}\n                            onKeyDown={(e) => handleKeyDown(e, starValue)}\n                            disabled={readOnly}\n                            role=\"radio\"\n                            aria-checked={starValue === value}\n                            aria-label={`${starValue} star${starValue !== 1 ? \"s\" : \"\"}`}\n                        >\n                            {isActive ? icon : emptyIcon}\n                        </button>\n                    );\n                })}\n            </div>\n        );\n    }\n);\nRating.displayName = \"Rating\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Rating } from \"../Rating\";\n\ntest(\"renders correct number of stars\", () => {\n    render(<Rating value={3} max={5} />);\n    expect(screen.getAllByRole(\"radio\")).toHaveLength(5);\n});\n\ntest(\"shows correct active stars\", () => {\n    render(<Rating value={3} />);\n    const stars = screen.getAllByRole(\"radio\");\n\n    expect(stars[0]).toHaveTextContent(\"★\");\n    expect(stars[1]).toHaveTextContent(\"★\");\n    expect(stars[2]).toHaveTextContent(\"★\");\n    expect(stars[3]).toHaveTextContent(\"☆\");\n    expect(stars[4]).toHaveTextContent(\"☆\");\n});\n\ntest(\"calls onChange when star is clicked\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Rating value={2} onChange={onChange} />);\n\n    await user.click(screen.getByLabelText(\"4 stars\"));\n    expect(onChange).toHaveBeenCalledWith(4);\n});\n\ntest(\"is readonly when specified\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Rating value={3} onChange={onChange} readOnly />);\n\n    await user.click(screen.getByLabelText(\"5 stars\"));\n    expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"handles keyboard navigation\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Rating value={3} onChange={onChange} />);\n\n    const star = screen.getByLabelText(\"3 stars\");\n    star.focus();\n    await user.keyboard(\"{ArrowRight}\");\n    expect(onChange).toHaveBeenCalledWith(4);\n});\n\ntest(\"applies size classes\", () => {\n    render(<Rating value={3} size=\"lg\" />);\n    expect(screen.getByRole(\"radiogroup\")).toHaveClass(\"rating\", \"rating-lg\");\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface SearchSuggestion {\n  id: string;\n  label: string;\n  value: string;\n  category?: string;\n  description?: string;\n  icon?: React.ReactNode;\n}\n\nexport interface SearchBoxProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, \"onChange\" | \"onSelect\"> {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (value: string) => void;\n  onSearch?: (value: string) => void;\n  onSelect?: (suggestion: SearchSuggestion) => void;\n  onClear?: () => void;\n  suggestions?: SearchSuggestion[];\n  loading?: boolean;\n  showSuggestions?: boolean;\n  maxSuggestions?: number;\n  placeholder?: string;\n  clearable?: boolean;\n  searchOnEnter?: boolean;\n  searchOnSelect?: boolean;\n  debounceMs?: number;\n  caseSensitive?: boolean;\n  highlightMatch?: boolean;\n  showCategories?: boolean;\n  emptyText?: string;\n  size?: \"sm\" | \"md\" | \"lg\";\n  variant?: \"default\" | \"filled\" | \"outlined\";\n  prefix?: React.ReactNode;\n  suffix?: React.ReactNode;\n}\n\nconst classesBySize: Record<NonNullable<SearchBoxProps[\"size\"]>, string> = {\n  sm: \"search-box-sm\",\n  md: \"search-box-md\",\n  lg: \"search-box-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<SearchBoxProps[\"variant\"]>, string> = {\n  default: \"search-box-default\",\n  filled: \"search-box-filled\",\n  outlined: \"search-box-outlined\",\n};\n\nexport const SearchBox = React.forwardRef<HTMLInputElement, SearchBoxProps>(\n  ({\n    value: controlledValue,\n    defaultValue = \"\",\n    onChange,\n    onSearch,\n    onSelect,\n    onClear,\n    suggestions = [],\n    loading = false,\n    showSuggestions = true,\n    maxSuggestions = 10,\n    placeholder = \"Search...\",\n    clearable = true,\n    searchOnEnter = true,\n    searchOnSelect = true,\n    debounceMs = 300,\n    caseSensitive = false,\n    highlightMatch = true,\n    showCategories = true,\n    emptyText = \"No suggestions found\",\n    size = \"md\",\n    variant = \"default\",\n    prefix,\n    suffix,\n    className,\n    onKeyDown,\n    onFocus,\n    onBlur,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState(defaultValue);\n    const [isOpen, setIsOpen] = React.useState(false);\n    const [highlightedIndex, setHighlightedIndex] = React.useState(-1);\n    const [filteredSuggestions, setFilteredSuggestions] = React.useState<SearchSuggestion[]>([]);\n    \n    const inputRef = React.useRef<HTMLInputElement>(null);\n    const listRef = React.useRef<HTMLUListElement>(null);\n    const debounceRef = React.useRef<NodeJS.Timeout>();\n    const combinedRef = React.useMemo(() => ref || inputRef, [ref]);\n    const searchBoxId = React.useId();\n\n    const isControlled = controlledValue !== undefined;\n    const currentValue = isControlled ? controlledValue : internalValue;\n\n    const classes = `search-box ${classesBySize[size]} ${classesByVariant[variant]} ${\n      isOpen ? \"search-box-open\" : \"\"\n    } ${loading ? \"search-box-loading\" : \"\"} ${className || \"\"}`.trim();\n\n    // Filter suggestions based on current value\n    React.useEffect(() => {\n      if (!currentValue.trim()) {\n        setFilteredSuggestions([]);\n        return;\n      }\n\n      const searchValue = caseSensitive ? currentValue : currentValue.toLowerCase();\n      const filtered = suggestions\n        .filter(suggestion => {\n          const suggestionValue = caseSensitive ? suggestion.value : suggestion.value.toLowerCase();\n          const suggestionLabel = caseSensitive ? suggestion.label : suggestion.label.toLowerCase();\n          return suggestionValue.includes(searchValue) || suggestionLabel.includes(searchValue);\n        })\n        .slice(0, maxSuggestions);\n\n      setFilteredSuggestions(filtered);\n    }, [currentValue, suggestions, caseSensitive, maxSuggestions]);\n\n    // Debounced onChange\n    React.useEffect(() => {\n      if (debounceMs > 0 && onChange) {\n        clearTimeout(debounceRef.current);\n        debounceRef.current = setTimeout(() => {\n          onChange(currentValue);\n        }, debounceMs);\n      }\n\n      return () => {\n        clearTimeout(debounceRef.current);\n      };\n    }, [currentValue, onChange, debounceMs]);\n\n    const updateValue = (newValue: string) => {\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n      \n      if (debounceMs === 0 && onChange) {\n        onChange(newValue);\n      }\n    };\n\n    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n      const newValue = e.target.value;\n      updateValue(newValue);\n      setHighlightedIndex(-1);\n      \n      if (showSuggestions && newValue.trim()) {\n        setIsOpen(true);\n      } else {\n        setIsOpen(false);\n      }\n    };\n\n    const handleSearch = (value: string = currentValue) => {\n      if (onSearch) {\n        onSearch(value);\n      }\n      setIsOpen(false);\n    };\n\n    const handleSelect = (suggestion: SearchSuggestion) => {\n      updateValue(suggestion.value);\n      \n      if (onSelect) {\n        onSelect(suggestion);\n      }\n      \n      if (searchOnSelect) {\n        handleSearch(suggestion.value);\n      }\n      \n      setIsOpen(false);\n      setHighlightedIndex(-1);\n      \n      if (combinedRef && \"current\" in combinedRef && combinedRef.current) {\n        combinedRef.current.focus();\n      }\n    };\n\n    const handleClear = () => {\n      updateValue(\"\");\n      setIsOpen(false);\n      setHighlightedIndex(-1);\n      \n      if (onClear) {\n        onClear();\n      }\n      \n      if (combinedRef && \"current\" in combinedRef && combinedRef.current) {\n        combinedRef.current.focus();\n      }\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n      if (onKeyDown) {\n        onKeyDown(e);\n      }\n\n      if (!isOpen) {\n        if (e.key === \"ArrowDown\" && filteredSuggestions.length > 0) {\n          e.preventDefault();\n          setIsOpen(true);\n          setHighlightedIndex(0);\n        }\n        if (e.key === \"Enter\" && searchOnEnter) {\n          e.preventDefault();\n          handleSearch();\n        }\n        return;\n      }\n\n      switch (e.key) {\n        case \"ArrowDown\":\n          e.preventDefault();\n          setHighlightedIndex(prev => \n            prev < filteredSuggestions.length - 1 ? prev + 1 : 0\n          );\n          break;\n        case \"ArrowUp\":\n          e.preventDefault();\n          setHighlightedIndex(prev => \n            prev > 0 ? prev - 1 : filteredSuggestions.length - 1\n          );\n          break;\n        case \"Enter\":\n          e.preventDefault();\n          if (highlightedIndex >= 0 && filteredSuggestions[highlightedIndex]) {\n            handleSelect(filteredSuggestions[highlightedIndex]);\n          } else if (searchOnEnter) {\n            handleSearch();\n          }\n          break;\n        case \"Escape\":\n          setIsOpen(false);\n          setHighlightedIndex(-1);\n          break;\n        case \"Tab\":\n          setIsOpen(false);\n          setHighlightedIndex(-1);\n          break;\n      }\n    };\n\n    const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {\n      if (onFocus) {\n        onFocus(e);\n      }\n      \n      if (showSuggestions && currentValue.trim() && filteredSuggestions.length > 0) {\n        setIsOpen(true);\n      }\n    };\n\n    const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n      if (onBlur) {\n        onBlur(e);\n      }\n      \n      // Delay closing to allow for suggestion clicks\n      setTimeout(() => {\n        setIsOpen(false);\n        setHighlightedIndex(-1);\n      }, 150);\n    };\n\n    const highlightText = (text: string, query: string): React.ReactNode => {\n      if (!highlightMatch || !query.trim()) {\n        return text;\n      }\n\n      const searchValue = caseSensitive ? query : query.toLowerCase();\n      const textValue = caseSensitive ? text : text.toLowerCase();\n      const index = textValue.indexOf(searchValue);\n\n      if (index === -1) {\n        return text;\n      }\n\n      return (\n        <>\n          {text.slice(0, index)}\n          <mark className=\"search-box-highlight\">\n            {text.slice(index, index + query.length)}\n          </mark>\n          {text.slice(index + query.length)}\n        </>\n      );\n    };\n\n    const groupedSuggestions = React.useMemo(() => {\n      if (!showCategories) {\n        return { \"\": filteredSuggestions };\n      }\n\n      return filteredSuggestions.reduce((groups, suggestion) => {\n        const category = suggestion.category || \"\";\n        if (!groups[category]) {\n          groups[category] = [];\n        }\n        groups[category].push(suggestion);\n        return groups;\n      }, {} as Record<string, SearchSuggestion[]>);\n    }, [filteredSuggestions, showCategories]);\n\n    // Scroll highlighted item into view\n    React.useEffect(() => {\n      if (highlightedIndex >= 0 && listRef.current) {\n        const highlightedElement = listRef.current.children[highlightedIndex] as HTMLElement;\n        if (highlightedElement) {\n          highlightedElement.scrollIntoView({\n            block: \"nearest\",\n            behavior: \"smooth\"\n          });\n        }\n      }\n    }, [highlightedIndex]);\n\n    return (\n      <div className={classes}>\n        <div className=\"search-box-input-wrapper\">\n          {prefix && <div className=\"search-box-prefix\">{prefix}</div>}\n          \n          <input\n            {...rest}\n            ref={combinedRef}\n            type=\"text\"\n            value={currentValue}\n            onChange={handleInputChange}\n            onKeyDown={handleKeyDown}\n            onFocus={handleFocus}\n            onBlur={handleBlur}\n            placeholder={placeholder}\n            className=\"search-box-input\"\n            autoComplete=\"off\"\n            role=\"combobox\"\n            aria-expanded={isOpen}\n            aria-haspopup=\"listbox\"\n            aria-autocomplete=\"list\"\n            aria-controls={isOpen ? `${searchBoxId}-suggestions` : undefined}\n            aria-activedescendant={\n              highlightedIndex >= 0 ? `${searchBoxId}-option-${highlightedIndex}` : undefined\n            }\n          />\n          \n          <div className=\"search-box-suffix\">\n            {loading && (\n              <div className=\"search-box-loading-icon\" aria-label=\"Loading\">\n                ⏳\n              </div>\n            )}\n            \n            {clearable && currentValue && !loading && (\n              <button\n                type=\"button\"\n                className=\"search-box-clear\"\n                onClick={handleClear}\n                aria-label=\"Clear search\"\n                tabIndex={-1}\n              >\n                ×\n              </button>\n            )}\n            \n            {suffix && <div className=\"search-box-custom-suffix\">{suffix}</div>}\n            \n            <button\n              type=\"button\"\n              className=\"search-box-search-button\"\n              onClick={() => handleSearch()}\n              aria-label=\"Search\"\n              tabIndex={-1}\n            >\n              🔍\n            </button>\n          </div>\n        </div>\n\n        {isOpen && showSuggestions && (\n          <div className=\"search-box-dropdown\">\n            {filteredSuggestions.length === 0 ? (\n              <div className=\"search-box-empty\" role=\"option\">\n                {emptyText}\n              </div>\n            ) : (\n              <ul\n                ref={listRef}\n                className=\"search-box-suggestions\"\n                role=\"listbox\"\n                id={`${searchBoxId}-suggestions`}\n              >\n                {Object.entries(groupedSuggestions).map(([category, suggestions]) => (\n                  <React.Fragment key={category}>\n                    {category && showCategories && (\n                      <li className=\"search-box-category\" role=\"presentation\">\n                        {category}\n                      </li>\n                    )}\n                    {suggestions.map((suggestion, index) => {\n                      const globalIndex = filteredSuggestions.indexOf(suggestion);\n                      const isHighlighted = globalIndex === highlightedIndex;\n                      \n                      return (\n                        <li\n                          key={suggestion.id}\n                          className={`search-box-suggestion ${\n                            isHighlighted ? \"search-box-suggestion-highlighted\" : \"\"\n                          }`}\n                          onClick={() => handleSelect(suggestion)}\n                          role=\"option\"\n                          aria-selected={isHighlighted}\n                          id={`${searchBoxId}-option-${globalIndex}`}\n                        >\n                          {suggestion.icon && (\n                            <div className=\"search-box-suggestion-icon\">\n                              {suggestion.icon}\n                            </div>\n                          )}\n                          \n                          <div className=\"search-box-suggestion-content\">\n                            <div className=\"search-box-suggestion-label\">\n                              {highlightText(suggestion.label, currentValue)}\n                            </div>\n                            {suggestion.description && (\n                              <div className=\"search-box-suggestion-description\">\n                                {suggestion.description}\n                              </div>\n                            )}\n                          </div>\n                        </li>\n                      );\n                    })}\n                  </React.Fragment>\n                ))}\n              </ul>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  }\n);\nSearchBox.displayName = \"SearchBox\";",
    "output": "import { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { SearchBox } from \"../SearchBox\";\n\nconst mockSuggestions = [\n  { id: \"1\", label: \"Apple\", value: \"apple\", category: \"Fruits\" },\n  { id: \"2\", label: \"Banana\", value: \"banana\", category: \"Fruits\" },\n  { id: \"3\", label: \"Carrot\", value: \"carrot\", category: \"Vegetables\" },\n  { id: \"4\", label: \"Apple Pie\", value: \"apple-pie\", category: \"Desserts\" },\n];\n\ntest(\"renders search input\", () => {\n  render(<SearchBox />);\n  \n  expect(screen.getByRole(\"combobox\")).toBeInTheDocument();\n  expect(screen.getByPlaceholderText(\"Search...\")).toBeInTheDocument();\n});\n\ntest(\"handles user input\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<SearchBox onChange={onChange} debounceMs={0} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"a\");\n  \n  expect(screen.queryByText(\"Fruits\")).not.toBeInTheDocument();\n  expect(screen.queryByText(\"Desserts\")).not.toBeInTheDocument();\n});\n\ntest(\"highlights matching text\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} highlightMatch />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  const highlighted = document.querySelector(\".search-box-highlight\");\n  expect(highlighted).toBeInTheDocument();\n  expect(highlighted).toHaveTextContent(\"app\");\n});\n\ntest(\"respects maxSuggestions limit\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} maxSuggestions={2} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"a\");\n  \n  const suggestions = screen.getAllByRole(\"option\");\n  expect(suggestions).toHaveLength(2);\n});\n\ntest(\"shows empty text when no suggestions\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={[]} emptyText=\"No results found\" />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"xyz\");\n  \n  expect(screen.getByText(\"No results found\")).toBeInTheDocument();\n});\n\ntest(\"handles debounced onChange\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<SearchBox onChange={onChange} debounceMs={100} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"test\");\n  \n  // Should not be called immediately\n  expect(onChange).not.toHaveBeenCalled();\n  \n  // Should be called after debounce\n  await waitFor(() => {\n    expect(onChange).toHaveBeenCalledWith(\"test\");\n  }, { timeout: 200 });\n});\n\ntest(\"closes suggestions on escape\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  expect(screen.getByText(\"Apple\")).toBeInTheDocument();\n  \n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByText(\"Apple\")).not.toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  render(<SearchBox value=\"controlled\" onChange={onChange} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  expect(input).toHaveValue(\"controlled\");\n});\n\ntest(\"shows prefix and suffix\", () => {\n  render(\n    <SearchBox \n      prefix={<span>Prefix</span>} \n      suffix={<span>Suffix</span>} \n    />\n  );\n  \n  expect(screen.getByText(\"Prefix\")).toBeInTheDocument();\n  expect(screen.getByText(\"Suffix\")).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<SearchBox size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"search-box-lg\");\n});\n\ntest(\"applies variant classes\", () => {\n  const { container } = render(<SearchBox variant=\"outlined\" />);\n  expect(container.firstChild).toHaveClass(\"search-box-outlined\");\n});\n\ntest(\"shows suggestion icons and descriptions\", async () => {\n  const user = userEvent.setup();\n  const suggestionsWithExtras = [\n    {\n      id: \"1\",\n      label: \"Apple\",\n      value: \"apple\",\n      icon: <span>🍎</span>,\n      description: \"A red fruit\"\n    }\n  ];\n  \n  render(<SearchBox suggestions={suggestionsWithExtras} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  expect(screen.getByText(\"🍎\")).toBeInTheDocument();\n  expect(screen.getByText(\"A red fruit\")).toBeInTheDocument();\n});\n\ntest(\"handles search button click\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<SearchBox onSearch={onSearch} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"test query\");\n  \n  const searchButton = screen.getByLabelText(\"Search\");\n  await user.click(searchButton);\n  \n  expect(onSearch).toHaveBeenCalledWith(\"test query\");\n});\n\ntest(\"handles focus and blur events\", async () => {\n  const user = userEvent.setup();\n  const onFocus = vi.fn();\n  const onBlur = vi.fn();\n  render(<SearchBox onFocus={onFocus} onBlur={onBlur} suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  input.focus();\n  expect(onFocus).toHaveBeenCalled();\n  \n  input.blur();\n  expect(onBlur).toHaveBeenCalled();\n});\n\ntest(\"searches on selection when enabled\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<SearchBox suggestions={mockSuggestions} onSearch={onSearch} searchOnSelect />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  await user.click(screen.getByText(\"Apple\"));\n  \n  expect(onSearch).toHaveBeenCalledWith(\"apple\");\n});\n\ntest(\"does not search on selection when disabled\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<SearchBox suggestions={mockSuggestions} onSearch={onSearch} searchOnSelect={false} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  await user.click(screen.getByText(\"Apple\"));\n  \n  expect(onSearch).not.toHaveBeenCalled();\n});\n\ntest(\"has proper accessibility attributes\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  \n  expect(input).toHaveAttribute(\"aria-autocomplete\", \"list\");\n  expect(input).toHaveAttribute(\"aria-expanded\", \"false\");\n  \n  await user.type(input, \"app\");\n  \n  expect(input).toHaveAttribute(\"aria-expanded\", \"true\");\n  expect(input).toHaveAttribute(\"aria-controls\");\n  \n  await user.keyboard(\"{ArrowDown}\");\n  expect(input).toHaveAttribute(\"aria-activedescendant\");\n});.type(input, \"test\");\n  \n  expect(onChange).toHaveBeenCalledWith(\"test\");\n  expect(input).toHaveValue(\"test\");\n});\n\ntest(\"shows suggestions when typing\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  expect(screen.getByText(\"Apple\")).toBeInTheDocument();\n  expect(screen.getByText(\"Apple Pie\")).toBeInTheDocument();\n  expect(screen.queryByText(\"Banana\")).not.toBeInTheDocument();\n});\n\ntest(\"filters suggestions case insensitively by default\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"APPLE\");\n  \n  expect(screen.getByText(\"Apple\")).toBeInTheDocument();\n  expect(screen.getByText(\"Apple Pie\")).toBeInTheDocument();\n});\n\ntest(\"respects case sensitive filtering\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} caseSensitive />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"APPLE\");\n  \n  expect(screen.queryByText(\"Apple\")).not.toBeInTheDocument();\n});\n\ntest(\"handles suggestion selection\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<SearchBox suggestions={mockSuggestions} onSelect={onSelect} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  await user.click(screen.getByText(\"Apple\"));\n  \n  expect(onSelect).toHaveBeenCalledWith(mockSuggestions[0]);\n  expect(input).toHaveValue(\"apple\");\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<SearchBox suggestions={mockSuggestions} onSelect={onSelect} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  await user.keyboard(\"{ArrowDown}\");\n  await user.keyboard(\"{ArrowDown}\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onSelect).toHaveBeenCalledWith(mockSuggestions[3]); // Apple Pie\n});\n\ntest(\"handles search on enter\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<SearchBox onSearch={onSearch} searchOnEnter />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"test query\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onSearch).toHaveBeenCalledWith(\"test query\");\n});\n\ntest(\"shows clear button when clearable\", async () => {\n  const user = userEvent.setup();\n  const onClear = vi.fn();\n  render(<SearchBox clearable onClear={onClear} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"test\");\n  \n  const clearButton = screen.getByLabelText(\"Clear search\");\n  expect(clearButton).toBeInTheDocument();\n  \n  await user.click(clearButton);\n  expect(onClear).toHaveBeenCalled();\n  expect(input).toHaveValue(\"\");\n});\n\ntest(\"shows loading state\", () => {\n  render(<SearchBox loading />);\n  \n  expect(screen.getByLabelText(\"Loading\")).toBeInTheDocument();\n});\n\ntest(\"shows categories when enabled\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} showCategories />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"a\");\n  \n  expect(screen.getByText(\"Fruits\")).toBeInTheDocument();\n  expect(screen.getByText(\"Desserts\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface SearchSuggestion {\n  id: string;\n  label: string;\n  value: string;\n  category?: string;\n  description?: string;\n  icon?: React.ReactNode;\n}\n\nexport interface SearchBoxProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, \"onChange\" | \"onSelect\"> {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (value: string) => void;\n  onSearch?: (value: string) => void;\n  onSelect?: (suggestion: SearchSuggestion) => void;\n  onClear?: () => void;\n  suggestions?: SearchSuggestion[];\n  loading?: boolean;\n  showSuggestions?: boolean;\n  maxSuggestions?: number;\n  placeholder?: string;\n  clearable?: boolean;\n  searchOnEnter?: boolean;\n  searchOnSelect?: boolean;\n  debounceMs?: number;\n  caseSensitive?: boolean;\n  highlightMatch?: boolean;\n  showCategories?: boolean;\n  emptyText?: string;\n  size?: \"sm\" | \"md\" | \"lg\";\n  variant?: \"default\" | \"filled\" | \"outlined\";\n  prefix?: React.ReactNode;\n  suffix?: React.ReactNode;\n}\n\nconst classesBySize: Record<NonNullable<SearchBoxProps[\"size\"]>, string> = {\n  sm: \"search-box-sm\",\n  md: \"search-box-md\",\n  lg: \"search-box-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<SearchBoxProps[\"variant\"]>, string> = {\n  default: \"search-box-default\",\n  filled: \"search-box-filled\",\n  outlined: \"search-box-outlined\",\n};\n\nexport const SearchBox = React.forwardRef<HTMLInputElement, SearchBoxProps>(\n  ({\n    value: controlledValue,\n    defaultValue = \"\",\n    onChange,\n    onSearch,\n    onSelect,\n    onClear,\n    suggestions = [],\n    loading = false,\n    showSuggestions = true,\n    maxSuggestions = 10,\n    placeholder = \"Search...\",\n    clearable = true,\n    searchOnEnter = true,\n    searchOnSelect = true,\n    debounceMs = 300,\n    caseSensitive = false,\n    highlightMatch = true,\n    showCategories = true,\n    emptyText = \"No suggestions found\",\n    size = \"md\",\n    variant = \"default\",\n    prefix,\n    suffix,\n    className,\n    onKeyDown,\n    onFocus,\n    onBlur,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState(defaultValue);\n    const [isOpen, setIsOpen] = React.useState(false);\n    const [highlightedIndex, setHighlightedIndex] = React.useState(-1);\n    const [filteredSuggestions, setFilteredSuggestions] = React.useState<SearchSuggestion[]>([]);\n    \n    const inputRef = React.useRef<HTMLInputElement>(null);\n    const listRef = React.useRef<HTMLUListElement>(null);\n    const debounceRef = React.useRef<NodeJS.Timeout>();\n    const combinedRef = React.useMemo(() => ref || inputRef, [ref]);\n    const searchBoxId = React.useId();\n\n    const isControlled = controlledValue !== undefined;\n    const currentValue = isControlled ? controlledValue : internalValue;\n\n    const classes = `search-box ${classesBySize[size]} ${classesByVariant[variant]} ${\n      isOpen ? \"search-box-open\" : \"\"\n    } ${loading ? \"search-box-loading\" : \"\"} ${className || \"\"}`.trim();\n\n    // Filter suggestions based on current value\n    React.useEffect(() => {\n      if (!currentValue.trim()) {\n        setFilteredSuggestions([]);\n        return;\n      }\n\n      const searchValue = caseSensitive ? currentValue : currentValue.toLowerCase();\n      const filtered = suggestions\n        .filter(suggestion => {\n          const suggestionValue = caseSensitive ? suggestion.value : suggestion.value.toLowerCase();\n          const suggestionLabel = caseSensitive ? suggestion.label : suggestion.label.toLowerCase();\n          return suggestionValue.includes(searchValue) || suggestionLabel.includes(searchValue);\n        })\n        .slice(0, maxSuggestions);\n\n      setFilteredSuggestions(filtered);\n    }, [currentValue, suggestions, caseSensitive, maxSuggestions]);\n\n    // Debounced onChange\n    React.useEffect(() => {\n      if (debounceMs > 0 && onChange) {\n        clearTimeout(debounceRef.current);\n        debounceRef.current = setTimeout(() => {\n          onChange(currentValue);\n        }, debounceMs);\n      }\n\n      return () => {\n        clearTimeout(debounceRef.current);\n      };\n    }, [currentValue, onChange, debounceMs]);\n\n    const updateValue = (newValue: string) => {\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n      \n      if (debounceMs === 0 && onChange) {\n        onChange(newValue);\n      }\n    };\n\n    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n      const newValue = e.target.value;\n      updateValue(newValue);\n      setHighlightedIndex(-1);\n      \n      if (showSuggestions && newValue.trim()) {\n        setIsOpen(true);\n      } else {\n        setIsOpen(false);\n      }\n    };\n\n    const handleSearch = (value: string = currentValue) => {\n      if (onSearch) {\n        onSearch(value);\n      }\n      setIsOpen(false);\n    };\n\n    const handleSelect = (suggestion: SearchSuggestion) => {\n      updateValue(suggestion.value);\n      \n      if (onSelect) {\n        onSelect(suggestion);\n      }\n      \n      if (searchOnSelect) {\n        handleSearch(suggestion.value);\n      }\n      \n      setIsOpen(false);\n      setHighlightedIndex(-1);\n      \n      if (combinedRef && \"current\" in combinedRef && combinedRef.current) {\n        combinedRef.current.focus();\n      }\n    };\n\n    const handleClear = () => {\n      updateValue(\"\");\n      setIsOpen(false);\n      setHighlightedIndex(-1);\n      \n      if (onClear) {\n        onClear();\n      }\n      \n      if (combinedRef && \"current\" in combinedRef && combinedRef.current) {\n        combinedRef.current.focus();\n      }\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n      if (onKeyDown) {\n        onKeyDown(e);\n      }\n\n      if (!isOpen) {\n        if (e.key === \"ArrowDown\" && filteredSuggestions.length > 0) {\n          e.preventDefault();\n          setIsOpen(true);\n          setHighlightedIndex(0);\n        }\n        if (e.key === \"Enter\" && searchOnEnter) {\n          e.preventDefault();\n          handleSearch();\n        }\n        return;\n      }\n\n      switch (e.key) {\n        case \"ArrowDown\":\n          e.preventDefault();\n          setHighlightedIndex(prev => \n            prev < filteredSuggestions.length - 1 ? prev + 1 : 0\n          );\n          break;\n        case \"ArrowUp\":\n          e.preventDefault();\n          setHighlightedIndex(prev => \n            prev > 0 ? prev - 1 : filteredSuggestions.length - 1\n          );\n          break;\n        case \"Enter\":\n          e.preventDefault();\n          if (highlightedIndex >= 0 && filteredSuggestions[highlightedIndex]) {\n            handleSelect(filteredSuggestions[highlightedIndex]);\n          } else if (searchOnEnter) {\n            handleSearch();\n          }\n          break;\n        case \"Escape\":\n          setIsOpen(false);\n          setHighlightedIndex(-1);\n          break;\n        case \"Tab\":\n          setIsOpen(false);\n          setHighlightedIndex(-1);\n          break;\n      }\n    };\n\n    const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {\n      if (onFocus) {\n        onFocus(e);\n      }\n      \n      if (showSuggestions && currentValue.trim() && filteredSuggestions.length > 0) {\n        setIsOpen(true);\n      }\n    };\n\n    const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n      if (onBlur) {\n        onBlur(e);\n      }\n      \n      // Delay closing to allow for suggestion clicks\n      setTimeout(() => {\n        setIsOpen(false);\n        setHighlightedIndex(-1);\n      }, 150);\n    };\n\n    const highlightText = (text: string, query: string): React.ReactNode => {\n      if (!highlightMatch || !query.trim()) {\n        return text;\n      }\n\n      const searchValue = caseSensitive ? query : query.toLowerCase();\n      const textValue = caseSensitive ? text : text.toLowerCase();\n      const index = textValue.indexOf(searchValue);\n\n      if (index === -1) {\n        return text;\n      }\n\n      return (\n        <>\n          {text.slice(0, index)}\n          <mark className=\"search-box-highlight\">\n            {text.slice(index, index + query.length)}\n          </mark>\n          {text.slice(index + query.length)}\n        </>\n      );\n    };\n\n    const groupedSuggestions = React.useMemo(() => {\n      if (!showCategories) {\n        return { \"\": filteredSuggestions };\n      }\n\n      return filteredSuggestions.reduce((groups, suggestion) => {\n        const category = suggestion.category || \"\";\n        if (!groups[category]) {\n          groups[category] = [];\n        }\n        groups[category].push(suggestion);\n        return groups;\n      }, {} as Record<string, SearchSuggestion[]>);\n    }, [filteredSuggestions, showCategories]);\n\n    // Scroll highlighted item into view\n    React.useEffect(() => {\n      if (highlightedIndex >= 0 && listRef.current) {\n        const highlightedElement = listRef.current.children[highlightedIndex] as HTMLElement;\n        if (highlightedElement) {\n          highlightedElement.scrollIntoView({\n            block: \"nearest\",\n            behavior: \"smooth\"\n          });\n        }\n      }\n    }, [highlightedIndex]);\n\n    return (\n      <div className={classes}>\n        <div className=\"search-box-input-wrapper\">\n          {prefix && <div className=\"search-box-prefix\">{prefix}</div>}\n          \n          <input\n            {...rest}\n            ref={combinedRef}\n            type=\"text\"\n            value={currentValue}\n            onChange={handleInputChange}\n            onKeyDown={handleKeyDown}\n            onFocus={handleFocus}\n            onBlur={handleBlur}\n            placeholder={placeholder}\n            className=\"search-box-input\"\n            autoComplete=\"off\"\n            role=\"combobox\"\n            aria-expanded={isOpen}\n            aria-haspopup=\"listbox\"\n            aria-autocomplete=\"list\"\n            aria-controls={isOpen ? `${searchBoxId}-suggestions` : undefined}\n            aria-activedescendant={\n              highlightedIndex >= 0 ? `${searchBoxId}-option-${highlightedIndex}` : undefined\n            }\n          />\n          \n          <div className=\"search-box-suffix\">\n            {loading && (\n              <div className=\"search-box-loading-icon\" aria-label=\"Loading\">\n                ⏳\n              </div>\n            )}\n            \n            {clearable && currentValue && !loading && (\n              <button\n                type=\"button\"\n                className=\"search-box-clear\"\n                onClick={handleClear}\n                aria-label=\"Clear search\"\n                tabIndex={-1}\n              >\n                ×\n              </button>\n            )}\n            \n            {suffix && <div className=\"search-box-custom-suffix\">{suffix}</div>}\n            \n            <button\n              type=\"button\"\n              className=\"search-box-search-button\"\n              onClick={() => handleSearch()}\n              aria-label=\"Search\"\n              tabIndex={-1}\n            >\n              🔍\n            </button>\n          </div>\n        </div>\n\n        {isOpen && showSuggestions && (\n          <div className=\"search-box-dropdown\">\n            {filteredSuggestions.length === 0 ? (\n              <div className=\"search-box-empty\" role=\"option\">\n                {emptyText}\n              </div>\n            ) : (\n              <ul\n                ref={listRef}\n                className=\"search-box-suggestions\"\n                role=\"listbox\"\n                id={`${searchBoxId}-suggestions`}\n              >\n                {Object.entries(groupedSuggestions).map(([category, suggestions]) => (\n                  <React.Fragment key={category}>\n                    {category && showCategories && (\n                      <li className=\"search-box-category\" role=\"presentation\">\n                        {category}\n                      </li>\n                    )}\n                    {suggestions.map((suggestion, index) => {\n                      const globalIndex = filteredSuggestions.indexOf(suggestion);\n                      const isHighlighted = globalIndex === highlightedIndex;\n                      \n                      return (\n                        <li\n                          key={suggestion.id}\n                          className={`search-box-suggestion ${\n                            isHighlighted ? \"search-box-suggestion-highlighted\" : \"\"\n                          }`}\n                          onClick={() => handleSelect(suggestion)}\n                          role=\"option\"\n                          aria-selected={isHighlighted}\n                          id={`${searchBoxId}-option-${globalIndex}`}\n                        >\n                          {suggestion.icon && (\n                            <div className=\"search-box-suggestion-icon\">\n                              {suggestion.icon}\n                            </div>\n                          )}\n                          \n                          <div className=\"search-box-suggestion-content\">\n                            <div className=\"search-box-suggestion-label\">\n                              {highlightText(suggestion.label, currentValue)}\n                            </div>\n                            {suggestion.description && (\n                              <div className=\"search-box-suggestion-description\">\n                                {suggestion.description}\n                              </div>\n                            )}\n                          </div>\n                        </li>\n                      );\n                    })}\n                  </React.Fragment>\n                ))}\n              </ul>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  }\n);\nSearchBox.displayName = \"SearchBox\";",
    "output": "import { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { SearchBox } from \"../SearchBox\";\n\nconst mockSuggestions = [\n  { id: \"1\", label: \"Apple\", value: \"apple\", category: \"Fruits\" },\n  { id: \"2\", label: \"Banana\", value: \"banana\", category: \"Fruits\" },\n  { id: \"3\", label: \"Carrot\", value: \"carrot\", category: \"Vegetables\" },\n  { id: \"4\", label: \"Apple Pie\", value: \"apple-pie\", category: \"Desserts\" },\n];\n\ntest(\"renders search input\", () => {\n  render(<SearchBox />);\n  \n  expect(screen.getByRole(\"combobox\")).toBeInTheDocument();\n  expect(screen.getByPlaceholderText(\"Search...\")).toBeInTheDocument();\n});\n\ntest(\"handles user input\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<SearchBox onChange={onChange} debounceMs={0} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"a\");\n  \n  expect(screen.queryByText(\"Fruits\")).not.toBeInTheDocument();\n  expect(screen.queryByText(\"Desserts\")).not.toBeInTheDocument();\n});\n\ntest(\"highlights matching text\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} highlightMatch />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  const highlighted = document.querySelector(\".search-box-highlight\");\n  expect(highlighted).toBeInTheDocument();\n  expect(highlighted).toHaveTextContent(\"app\");\n});\n\ntest(\"respects maxSuggestions limit\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} maxSuggestions={2} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"a\");\n  \n  const suggestions = screen.getAllByRole(\"option\");\n  expect(suggestions).toHaveLength(2);\n});\n\ntest(\"shows empty text when no suggestions\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={[]} emptyText=\"No results found\" />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"xyz\");\n  \n  expect(screen.getByText(\"No results found\")).toBeInTheDocument();\n});\n\ntest(\"handles debounced onChange\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<SearchBox onChange={onChange} debounceMs={100} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"test\");\n  \n  // Should not be called immediately\n  expect(onChange).not.toHaveBeenCalled();\n  \n  // Should be called after debounce\n  await waitFor(() => {\n    expect(onChange).toHaveBeenCalledWith(\"test\");\n  }, { timeout: 200 });\n});\n\ntest(\"closes suggestions on escape\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  expect(screen.getByText(\"Apple\")).toBeInTheDocument();\n  \n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByText(\"Apple\")).not.toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  render(<SearchBox value=\"controlled\" onChange={onChange} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  expect(input).toHaveValue(\"controlled\");\n});\n\ntest(\"shows prefix and suffix\", () => {\n  render(\n    <SearchBox \n      prefix={<span>Prefix</span>} \n      suffix={<span>Suffix</span>} \n    />\n  );\n  \n  expect(screen.getByText(\"Prefix\")).toBeInTheDocument();\n  expect(screen.getByText(\"Suffix\")).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<SearchBox size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"search-box-lg\");\n});\n\ntest(\"applies variant classes\", () => {\n  const { container } = render(<SearchBox variant=\"outlined\" />);\n  expect(container.firstChild).toHaveClass(\"search-box-outlined\");\n});\n\ntest(\"shows suggestion icons and descriptions\", async () => {\n  const user = userEvent.setup();\n  const suggestionsWithExtras = [\n    {\n      id: \"1\",\n      label: \"Apple\",\n      value: \"apple\",\n      icon: <span>🍎</span>,\n      description: \"A red fruit\"\n    }\n  ];\n  \n  render(<SearchBox suggestions={suggestionsWithExtras} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  expect(screen.getByText(\"🍎\")).toBeInTheDocument();\n  expect(screen.getByText(\"A red fruit\")).toBeInTheDocument();\n});\n\ntest(\"handles search button click\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<SearchBox onSearch={onSearch} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"test query\");\n  \n  const searchButton = screen.getByLabelText(\"Search\");\n  await user.click(searchButton);\n  \n  expect(onSearch).toHaveBeenCalledWith(\"test query\");\n});\n\ntest(\"handles focus and blur events\", async () => {\n  const user = userEvent.setup();\n  const onFocus = vi.fn();\n  const onBlur = vi.fn();\n  render(<SearchBox onFocus={onFocus} onBlur={onBlur} suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  input.focus();\n  expect(onFocus).toHaveBeenCalled();\n  \n  input.blur();\n  expect(onBlur).toHaveBeenCalled();\n});\n\ntest(\"searches on selection when enabled\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<SearchBox suggestions={mockSuggestions} onSearch={onSearch} searchOnSelect />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  await user.click(screen.getByText(\"Apple\"));\n  \n  expect(onSearch).toHaveBeenCalledWith(\"apple\");\n});\n\ntest(\"does not search on selection when disabled\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<SearchBox suggestions={mockSuggestions} onSearch={onSearch} searchOnSelect={false} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  await user.click(screen.getByText(\"Apple\"));\n  \n  expect(onSearch).not.toHaveBeenCalled();\n});\n\ntest(\"has proper accessibility attributes\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  \n  expect(input).toHaveAttribute(\"aria-autocomplete\", \"list\");\n  expect(input).toHaveAttribute(\"aria-expanded\", \"false\");\n  \n  await user.type(input, \"app\");\n  \n  expect(input).toHaveAttribute(\"aria-expanded\", \"true\");\n  expect(input).toHaveAttribute(\"aria-controls\");\n  \n  await user.keyboard(\"{ArrowDown}\");\n  expect(input).toHaveAttribute(\"aria-activedescendant\");\n});.type(input, \"test\");\n  \n  expect(onChange).toHaveBeenCalledWith(\"test\");\n  expect(input).toHaveValue(\"test\");\n});\n\ntest(\"shows suggestions when typing\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  expect(screen.getByText(\"Apple\")).toBeInTheDocument();\n  expect(screen.getByText(\"Apple Pie\")).toBeInTheDocument();\n  expect(screen.queryByText(\"Banana\")).not.toBeInTheDocument();\n});\n\ntest(\"filters suggestions case insensitively by default\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"APPLE\");\n  \n  expect(screen.getByText(\"Apple\")).toBeInTheDocument();\n  expect(screen.getByText(\"Apple Pie\")).toBeInTheDocument();\n});\n\ntest(\"respects case sensitive filtering\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} caseSensitive />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"APPLE\");\n  \n  expect(screen.queryByText(\"Apple\")).not.toBeInTheDocument();\n});\n\ntest(\"handles suggestion selection\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<SearchBox suggestions={mockSuggestions} onSelect={onSelect} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  await user.click(screen.getByText(\"Apple\"));\n  \n  expect(onSelect).toHaveBeenCalledWith(mockSuggestions[0]);\n  expect(input).toHaveValue(\"apple\");\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<SearchBox suggestions={mockSuggestions} onSelect={onSelect} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  await user.keyboard(\"{ArrowDown}\");\n  await user.keyboard(\"{ArrowDown}\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onSelect).toHaveBeenCalledWith(mockSuggestions[3]); // Apple Pie\n});\n\ntest(\"handles search on enter\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<SearchBox onSearch={onSearch} searchOnEnter />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"test query\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onSearch).toHaveBeenCalledWith(\"test query\");\n});\n\ntest(\"shows clear button when clearable\", async () => {\n  const user = userEvent.setup();\n  const onClear = vi.fn();\n  render(<SearchBox clearable onClear={onClear} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"test\");\n  \n  const clearButton = screen.getByLabelText(\"Clear search\");\n  expect(clearButton).toBeInTheDocument();\n  \n  await user.click(clearButton);\n  expect(onClear).toHaveBeenCalled();\n  expect(input).toHaveValue(\"\");\n});\n\ntest(\"shows loading state\", () => {\n  render(<SearchBox loading />);\n  \n  expect(screen.getByLabelText(\"Loading\")).toBeInTheDocument();\n});\n\ntest(\"shows categories when enabled\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} showCategories />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"a\");\n  \n  expect(screen.getByText(\"Fruits\")).toBeInTheDocument();\n  expect(screen.getByText(\"Desserts\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface SearchSuggestion {\n  id: string;\n  label: string;\n  value: string;\n  category?: string;\n  description?: string;\n  icon?: React.ReactNode;\n}\n\nexport interface SearchBoxProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, \"onChange\" | \"onSelect\"> {\n  value?: string;\n  defaultValue?: string;\n  onChange?: (value: string) => void;\n  onSearch?: (value: string) => void;\n  onSelect?: (suggestion: SearchSuggestion) => void;\n  onClear?: () => void;\n  suggestions?: SearchSuggestion[];\n  loading?: boolean;\n  showSuggestions?: boolean;\n  maxSuggestions?: number;\n  placeholder?: string;\n  clearable?: boolean;\n  searchOnEnter?: boolean;\n  searchOnSelect?: boolean;\n  debounceMs?: number;\n  caseSensitive?: boolean;\n  highlightMatch?: boolean;\n  showCategories?: boolean;\n  emptyText?: string;\n  size?: \"sm\" | \"md\" | \"lg\";\n  variant?: \"default\" | \"filled\" | \"outlined\";\n  prefix?: React.ReactNode;\n  suffix?: React.ReactNode;\n}\n\nconst classesBySize: Record<NonNullable<SearchBoxProps[\"size\"]>, string> = {\n  sm: \"search-box-sm\",\n  md: \"search-box-md\",\n  lg: \"search-box-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<SearchBoxProps[\"variant\"]>, string> = {\n  default: \"search-box-default\",\n  filled: \"search-box-filled\",\n  outlined: \"search-box-outlined\",\n};\n\nexport const SearchBox = React.forwardRef<HTMLInputElement, SearchBoxProps>(\n  ({\n    value: controlledValue,\n    defaultValue = \"\",\n    onChange,\n    onSearch,\n    onSelect,\n    onClear,\n    suggestions = [],\n    loading = false,\n    showSuggestions = true,\n    maxSuggestions = 10,\n    placeholder = \"Search...\",\n    clearable = true,\n    searchOnEnter = true,\n    searchOnSelect = true,\n    debounceMs = 300,\n    caseSensitive = false,\n    highlightMatch = true,\n    showCategories = true,\n    emptyText = \"No suggestions found\",\n    size = \"md\",\n    variant = \"default\",\n    prefix,\n    suffix,\n    className,\n    onKeyDown,\n    onFocus,\n    onBlur,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState(defaultValue);\n    const [isOpen, setIsOpen] = React.useState(false);\n    const [highlightedIndex, setHighlightedIndex] = React.useState(-1);\n    const [filteredSuggestions, setFilteredSuggestions] = React.useState<SearchSuggestion[]>([]);\n    \n    const inputRef = React.useRef<HTMLInputElement>(null);\n    const listRef = React.useRef<HTMLUListElement>(null);\n    const debounceRef = React.useRef<NodeJS.Timeout>();\n    const combinedRef = React.useMemo(() => ref || inputRef, [ref]);\n    const searchBoxId = React.useId();\n\n    const isControlled = controlledValue !== undefined;\n    const currentValue = isControlled ? controlledValue : internalValue;\n\n    const classes = `search-box ${classesBySize[size]} ${classesByVariant[variant]} ${\n      isOpen ? \"search-box-open\" : \"\"\n    } ${loading ? \"search-box-loading\" : \"\"} ${className || \"\"}`.trim();\n\n    // Filter suggestions based on current value\n    React.useEffect(() => {\n      if (!currentValue.trim()) {\n        setFilteredSuggestions([]);\n        return;\n      }\n\n      const searchValue = caseSensitive ? currentValue : currentValue.toLowerCase();\n      const filtered = suggestions\n        .filter(suggestion => {\n          const suggestionValue = caseSensitive ? suggestion.value : suggestion.value.toLowerCase();\n          const suggestionLabel = caseSensitive ? suggestion.label : suggestion.label.toLowerCase();\n          return suggestionValue.includes(searchValue) || suggestionLabel.includes(searchValue);\n        })\n        .slice(0, maxSuggestions);\n\n      setFilteredSuggestions(filtered);\n    }, [currentValue, suggestions, caseSensitive, maxSuggestions]);\n\n    // Debounced onChange\n    React.useEffect(() => {\n      if (debounceMs > 0 && onChange) {\n        clearTimeout(debounceRef.current);\n        debounceRef.current = setTimeout(() => {\n          onChange(currentValue);\n        }, debounceMs);\n      }\n\n      return () => {\n        clearTimeout(debounceRef.current);\n      };\n    }, [currentValue, onChange, debounceMs]);\n\n    const updateValue = (newValue: string) => {\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n      \n      if (debounceMs === 0 && onChange) {\n        onChange(newValue);\n      }\n    };\n\n    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n      const newValue = e.target.value;\n      updateValue(newValue);\n      setHighlightedIndex(-1);\n      \n      if (showSuggestions && newValue.trim()) {\n        setIsOpen(true);\n      } else {\n        setIsOpen(false);\n      }\n    };\n\n    const handleSearch = (value: string = currentValue) => {\n      if (onSearch) {\n        onSearch(value);\n      }\n      setIsOpen(false);\n    };\n\n    const handleSelect = (suggestion: SearchSuggestion) => {\n      updateValue(suggestion.value);\n      \n      if (onSelect) {\n        onSelect(suggestion);\n      }\n      \n      if (searchOnSelect) {\n        handleSearch(suggestion.value);\n      }\n      \n      setIsOpen(false);\n      setHighlightedIndex(-1);\n      \n      if (combinedRef && \"current\" in combinedRef && combinedRef.current) {\n        combinedRef.current.focus();\n      }\n    };\n\n    const handleClear = () => {\n      updateValue(\"\");\n      setIsOpen(false);\n      setHighlightedIndex(-1);\n      \n      if (onClear) {\n        onClear();\n      }\n      \n      if (combinedRef && \"current\" in combinedRef && combinedRef.current) {\n        combinedRef.current.focus();\n      }\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n      if (onKeyDown) {\n        onKeyDown(e);\n      }\n\n      if (!isOpen) {\n        if (e.key === \"ArrowDown\" && filteredSuggestions.length > 0) {\n          e.preventDefault();\n          setIsOpen(true);\n          setHighlightedIndex(0);\n        }\n        if (e.key === \"Enter\" && searchOnEnter) {\n          e.preventDefault();\n          handleSearch();\n        }\n        return;\n      }\n\n      switch (e.key) {\n        case \"ArrowDown\":\n          e.preventDefault();\n          setHighlightedIndex(prev => \n            prev < filteredSuggestions.length - 1 ? prev + 1 : 0\n          );\n          break;\n        case \"ArrowUp\":\n          e.preventDefault();\n          setHighlightedIndex(prev => \n            prev > 0 ? prev - 1 : filteredSuggestions.length - 1\n          );\n          break;\n        case \"Enter\":\n          e.preventDefault();\n          if (highlightedIndex >= 0 && filteredSuggestions[highlightedIndex]) {\n            handleSelect(filteredSuggestions[highlightedIndex]);\n          } else if (searchOnEnter) {\n            handleSearch();\n          }\n          break;\n        case \"Escape\":\n          setIsOpen(false);\n          setHighlightedIndex(-1);\n          break;\n        case \"Tab\":\n          setIsOpen(false);\n          setHighlightedIndex(-1);\n          break;\n      }\n    };\n\n    const handleFocus = (e: React.FocusEvent<HTMLInputElement>) => {\n      if (onFocus) {\n        onFocus(e);\n      }\n      \n      if (showSuggestions && currentValue.trim() && filteredSuggestions.length > 0) {\n        setIsOpen(true);\n      }\n    };\n\n    const handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n      if (onBlur) {\n        onBlur(e);\n      }\n      \n      // Delay closing to allow for suggestion clicks\n      setTimeout(() => {\n        setIsOpen(false);\n        setHighlightedIndex(-1);\n      }, 150);\n    };\n\n    const highlightText = (text: string, query: string): React.ReactNode => {\n      if (!highlightMatch || !query.trim()) {\n        return text;\n      }\n\n      const searchValue = caseSensitive ? query : query.toLowerCase();\n      const textValue = caseSensitive ? text : text.toLowerCase();\n      const index = textValue.indexOf(searchValue);\n\n      if (index === -1) {\n        return text;\n      }\n\n      return (\n        <>\n          {text.slice(0, index)}\n          <mark className=\"search-box-highlight\">\n            {text.slice(index, index + query.length)}\n          </mark>\n          {text.slice(index + query.length)}\n        </>\n      );\n    };\n\n    const groupedSuggestions = React.useMemo(() => {\n      if (!showCategories) {\n        return { \"\": filteredSuggestions };\n      }\n\n      return filteredSuggestions.reduce((groups, suggestion) => {\n        const category = suggestion.category || \"\";\n        if (!groups[category]) {\n          groups[category] = [];\n        }\n        groups[category].push(suggestion);\n        return groups;\n      }, {} as Record<string, SearchSuggestion[]>);\n    }, [filteredSuggestions, showCategories]);\n\n    // Scroll highlighted item into view\n    React.useEffect(() => {\n      if (highlightedIndex >= 0 && listRef.current) {\n        const highlightedElement = listRef.current.children[highlightedIndex] as HTMLElement;\n        if (highlightedElement) {\n          highlightedElement.scrollIntoView({\n            block: \"nearest\",\n            behavior: \"smooth\"\n          });\n        }\n      }\n    }, [highlightedIndex]);\n\n    return (\n      <div className={classes}>\n        <div className=\"search-box-input-wrapper\">\n          {prefix && <div className=\"search-box-prefix\">{prefix}</div>}\n          \n          <input\n            {...rest}\n            ref={combinedRef}\n            type=\"text\"\n            value={currentValue}\n            onChange={handleInputChange}\n            onKeyDown={handleKeyDown}\n            onFocus={handleFocus}\n            onBlur={handleBlur}\n            placeholder={placeholder}\n            className=\"search-box-input\"\n            autoComplete=\"off\"\n            role=\"combobox\"\n            aria-expanded={isOpen}\n            aria-haspopup=\"listbox\"\n            aria-autocomplete=\"list\"\n            aria-controls={isOpen ? `${searchBoxId}-suggestions` : undefined}\n            aria-activedescendant={\n              highlightedIndex >= 0 ? `${searchBoxId}-option-${highlightedIndex}` : undefined\n            }\n          />\n          \n          <div className=\"search-box-suffix\">\n            {loading && (\n              <div className=\"search-box-loading-icon\" aria-label=\"Loading\">\n                ⏳\n              </div>\n            )}\n            \n            {clearable && currentValue && !loading && (\n              <button\n                type=\"button\"\n                className=\"search-box-clear\"\n                onClick={handleClear}\n                aria-label=\"Clear search\"\n                tabIndex={-1}\n              >\n                ×\n              </button>\n            )}\n            \n            {suffix && <div className=\"search-box-custom-suffix\">{suffix}</div>}\n            \n            <button\n              type=\"button\"\n              className=\"search-box-search-button\"\n              onClick={() => handleSearch()}\n              aria-label=\"Search\"\n              tabIndex={-1}\n            >\n              🔍\n            </button>\n          </div>\n        </div>\n\n        {isOpen && showSuggestions && (\n          <div className=\"search-box-dropdown\">\n            {filteredSuggestions.length === 0 ? (\n              <div className=\"search-box-empty\" role=\"option\">\n                {emptyText}\n              </div>\n            ) : (\n              <ul\n                ref={listRef}\n                className=\"search-box-suggestions\"\n                role=\"listbox\"\n                id={`${searchBoxId}-suggestions`}\n              >\n                {Object.entries(groupedSuggestions).map(([category, suggestions]) => (\n                  <React.Fragment key={category}>\n                    {category && showCategories && (\n                      <li className=\"search-box-category\" role=\"presentation\">\n                        {category}\n                      </li>\n                    )}\n                    {suggestions.map((suggestion, index) => {\n                      const globalIndex = filteredSuggestions.indexOf(suggestion);\n                      const isHighlighted = globalIndex === highlightedIndex;\n                      \n                      return (\n                        <li\n                          key={suggestion.id}\n                          className={`search-box-suggestion ${\n                            isHighlighted ? \"search-box-suggestion-highlighted\" : \"\"\n                          }`}\n                          onClick={() => handleSelect(suggestion)}\n                          role=\"option\"\n                          aria-selected={isHighlighted}\n                          id={`${searchBoxId}-option-${globalIndex}`}\n                        >\n                          {suggestion.icon && (\n                            <div className=\"search-box-suggestion-icon\">\n                              {suggestion.icon}\n                            </div>\n                          )}\n                          \n                          <div className=\"search-box-suggestion-content\">\n                            <div className=\"search-box-suggestion-label\">\n                              {highlightText(suggestion.label, currentValue)}\n                            </div>\n                            {suggestion.description && (\n                              <div className=\"search-box-suggestion-description\">\n                                {suggestion.description}\n                              </div>\n                            )}\n                          </div>\n                        </li>\n                      );\n                    })}\n                  </React.Fragment>\n                ))}\n              </ul>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  }\n);\nSearchBox.displayName = \"SearchBox\";",
    "output": "import { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { SearchBox } from \"../SearchBox\";\n\nconst mockSuggestions = [\n  { id: \"1\", label: \"Apple\", value: \"apple\", category: \"Fruits\" },\n  { id: \"2\", label: \"Banana\", value: \"banana\", category: \"Fruits\" },\n  { id: \"3\", label: \"Carrot\", value: \"carrot\", category: \"Vegetables\" },\n  { id: \"4\", label: \"Apple Pie\", value: \"apple-pie\", category: \"Desserts\" },\n];\n\ntest(\"renders search input\", () => {\n  render(<SearchBox />);\n  \n  expect(screen.getByRole(\"combobox\")).toBeInTheDocument();\n  expect(screen.getByPlaceholderText(\"Search...\")).toBeInTheDocument();\n});\n\ntest(\"handles user input\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<SearchBox onChange={onChange} debounceMs={0} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"a\");\n  \n  expect(screen.queryByText(\"Fruits\")).not.toBeInTheDocument();\n  expect(screen.queryByText(\"Desserts\")).not.toBeInTheDocument();\n});\n\ntest(\"highlights matching text\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} highlightMatch />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  const highlighted = document.querySelector(\".search-box-highlight\");\n  expect(highlighted).toBeInTheDocument();\n  expect(highlighted).toHaveTextContent(\"app\");\n});\n\ntest(\"respects maxSuggestions limit\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} maxSuggestions={2} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"a\");\n  \n  const suggestions = screen.getAllByRole(\"option\");\n  expect(suggestions).toHaveLength(2);\n});\n\ntest(\"shows empty text when no suggestions\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={[]} emptyText=\"No results found\" />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"xyz\");\n  \n  expect(screen.getByText(\"No results found\")).toBeInTheDocument();\n});\n\ntest(\"handles debounced onChange\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<SearchBox onChange={onChange} debounceMs={100} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"test\");\n  \n  // Should not be called immediately\n  expect(onChange).not.toHaveBeenCalled();\n  \n  // Should be called after debounce\n  await waitFor(() => {\n    expect(onChange).toHaveBeenCalledWith(\"test\");\n  }, { timeout: 200 });\n});\n\ntest(\"closes suggestions on escape\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  expect(screen.getByText(\"Apple\")).toBeInTheDocument();\n  \n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByText(\"Apple\")).not.toBeInTheDocument();\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  render(<SearchBox value=\"controlled\" onChange={onChange} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  expect(input).toHaveValue(\"controlled\");\n});\n\ntest(\"shows prefix and suffix\", () => {\n  render(\n    <SearchBox \n      prefix={<span>Prefix</span>} \n      suffix={<span>Suffix</span>} \n    />\n  );\n  \n  expect(screen.getByText(\"Prefix\")).toBeInTheDocument();\n  expect(screen.getByText(\"Suffix\")).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<SearchBox size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"search-box-lg\");\n});\n\ntest(\"applies variant classes\", () => {\n  const { container } = render(<SearchBox variant=\"outlined\" />);\n  expect(container.firstChild).toHaveClass(\"search-box-outlined\");\n});\n\ntest(\"shows suggestion icons and descriptions\", async () => {\n  const user = userEvent.setup();\n  const suggestionsWithExtras = [\n    {\n      id: \"1\",\n      label: \"Apple\",\n      value: \"apple\",\n      icon: <span>🍎</span>,\n      description: \"A red fruit\"\n    }\n  ];\n  \n  render(<SearchBox suggestions={suggestionsWithExtras} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  expect(screen.getByText(\"🍎\")).toBeInTheDocument();\n  expect(screen.getByText(\"A red fruit\")).toBeInTheDocument();\n});\n\ntest(\"handles search button click\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<SearchBox onSearch={onSearch} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"test query\");\n  \n  const searchButton = screen.getByLabelText(\"Search\");\n  await user.click(searchButton);\n  \n  expect(onSearch).toHaveBeenCalledWith(\"test query\");\n});\n\ntest(\"handles focus and blur events\", async () => {\n  const user = userEvent.setup();\n  const onFocus = vi.fn();\n  const onBlur = vi.fn();\n  render(<SearchBox onFocus={onFocus} onBlur={onBlur} suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  input.focus();\n  expect(onFocus).toHaveBeenCalled();\n  \n  input.blur();\n  expect(onBlur).toHaveBeenCalled();\n});\n\ntest(\"searches on selection when enabled\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<SearchBox suggestions={mockSuggestions} onSearch={onSearch} searchOnSelect />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  await user.click(screen.getByText(\"Apple\"));\n  \n  expect(onSearch).toHaveBeenCalledWith(\"apple\");\n});\n\ntest(\"does not search on selection when disabled\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<SearchBox suggestions={mockSuggestions} onSearch={onSearch} searchOnSelect={false} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  await user.click(screen.getByText(\"Apple\"));\n  \n  expect(onSearch).not.toHaveBeenCalled();\n});\n\ntest(\"has proper accessibility attributes\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  \n  expect(input).toHaveAttribute(\"aria-autocomplete\", \"list\");\n  expect(input).toHaveAttribute(\"aria-expanded\", \"false\");\n  \n  await user.type(input, \"app\");\n  \n  expect(input).toHaveAttribute(\"aria-expanded\", \"true\");\n  expect(input).toHaveAttribute(\"aria-controls\");\n  \n  await user.keyboard(\"{ArrowDown}\");\n  expect(input).toHaveAttribute(\"aria-activedescendant\");\n});.type(input, \"test\");\n  \n  expect(onChange).toHaveBeenCalledWith(\"test\");\n  expect(input).toHaveValue(\"test\");\n});\n\ntest(\"shows suggestions when typing\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  expect(screen.getByText(\"Apple\")).toBeInTheDocument();\n  expect(screen.getByText(\"Apple Pie\")).toBeInTheDocument();\n  expect(screen.queryByText(\"Banana\")).not.toBeInTheDocument();\n});\n\ntest(\"filters suggestions case insensitively by default\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"APPLE\");\n  \n  expect(screen.getByText(\"Apple\")).toBeInTheDocument();\n  expect(screen.getByText(\"Apple Pie\")).toBeInTheDocument();\n});\n\ntest(\"respects case sensitive filtering\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} caseSensitive />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"APPLE\");\n  \n  expect(screen.queryByText(\"Apple\")).not.toBeInTheDocument();\n});\n\ntest(\"handles suggestion selection\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<SearchBox suggestions={mockSuggestions} onSelect={onSelect} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  await user.click(screen.getByText(\"Apple\"));\n  \n  expect(onSelect).toHaveBeenCalledWith(mockSuggestions[0]);\n  expect(input).toHaveValue(\"apple\");\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<SearchBox suggestions={mockSuggestions} onSelect={onSelect} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"app\");\n  \n  await user.keyboard(\"{ArrowDown}\");\n  await user.keyboard(\"{ArrowDown}\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onSelect).toHaveBeenCalledWith(mockSuggestions[3]); // Apple Pie\n});\n\ntest(\"handles search on enter\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<SearchBox onSearch={onSearch} searchOnEnter />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"test query\");\n  await user.keyboard(\"{Enter}\");\n  \n  expect(onSearch).toHaveBeenCalledWith(\"test query\");\n});\n\ntest(\"shows clear button when clearable\", async () => {\n  const user = userEvent.setup();\n  const onClear = vi.fn();\n  render(<SearchBox clearable onClear={onClear} />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"test\");\n  \n  const clearButton = screen.getByLabelText(\"Clear search\");\n  expect(clearButton).toBeInTheDocument();\n  \n  await user.click(clearButton);\n  expect(onClear).toHaveBeenCalled();\n  expect(input).toHaveValue(\"\");\n});\n\ntest(\"shows loading state\", () => {\n  render(<SearchBox loading />);\n  \n  expect(screen.getByLabelText(\"Loading\")).toBeInTheDocument();\n});\n\ntest(\"shows categories when enabled\", async () => {\n  const user = userEvent.setup();\n  render(<SearchBox suggestions={mockSuggestions} showCategories />);\n  \n  const input = screen.getByRole(\"combobox\");\n  await user.type(input, \"a\");\n  \n  expect(screen.getByText(\"Fruits\")).toBeInTheDocument();\n  expect(screen.getByText(\"Desserts\")).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface SelectOption {\n    value: string | number;\n    label: string;\n    disabled?: boolean;\n}\n\nexport interface SelectProps extends Omit<React.SelectHTMLAttributes<HTMLSelectElement>, \"size\"> {\n    options: SelectOption[];\n    label?: string;\n    error?: string;\n    helperText?: string;\n    variant?: \"default\" | \"filled\" | \"outlined\";\n    size?: \"sm\" | \"md\" | \"lg\";\n    placeholder?: string;\n    clearable?: boolean;\n    onClear?: () => void;\n}\n\nconst classesByVariant: Record<NonNullable<SelectProps[\"variant\"]>, string> = {\n    default: \"select select-default\",\n    filled: \"select select-filled\",\n    outlined: \"select select-outlined\",\n};\n\nconst classesBySize: Record<NonNullable<SelectProps[\"size\"]>, string> = {\n    sm: \"select-sm\",\n    md: \"select-md\",\n    lg: \"select-lg\",\n};\n\nexport const Select = React.forwardRef<HTMLSelectElement, SelectProps>(\n    ({\n        options,\n        label,\n        error,\n        helperText,\n        variant = \"default\",\n        size = \"md\",\n        placeholder,\n        clearable = false,\n        onClear,\n        className,\n        id,\n        value,\n        ...rest\n    }, ref) => {\n        const selectId = id || React.useId();\n        const errorId = error ? `${selectId}-error` : undefined;\n        const helperTextId = helperText ? `${selectId}-helper` : undefined;\n\n        const classes = `${classesByVariant[variant]} ${classesBySize[size]} ${error ? \"select-error\" : \"\"\n            } ${className || \"\"}`.trim();\n\n        const handleClear = (e: React.MouseEvent) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (onClear) {\n                onClear();\n            }\n        };\n\n        const hasValue = value !== undefined && value !== \"\";\n        const showClearButton = clearable && hasValue && !rest.disabled;\n\n        return (\n            <div className=\"select-wrapper\">\n                {label && (\n                    <label htmlFor={selectId} className=\"select-label\">\n                        {label}\n                    </label>\n                )}\n\n                <div className=\"select-container\">\n                    <select\n                        {...rest}\n                        ref={ref}\n                        id={selectId}\n                        className={classes}\n                        value={value}\n                        aria-invalid={error ? true : undefined}\n                        aria-describedby={[errorId, helperTextId].filter(Boolean).join(\" \") || undefined}\n                    >\n                        {placeholder && (\n                            <option value=\"\" disabled hidden>\n                                {placeholder}\n                            </option>\n                        )}\n                        {options.map((option) => (\n                            <option\n                                key={option.value}\n                                value={option.value}\n                                disabled={option.disabled}\n                            >\n                                {option.label}\n                            </option>\n                        ))}\n                    </select>\n\n                    <div className=\"select-icons\">\n                        {showClearButton && (\n                            <button\n                                type=\"button\"\n                                className=\"select-clear\"\n                                onClick={handleClear}\n                                aria-label=\"Clear selection\"\n                                tabIndex={-1}\n                            >\n                                ×\n                            </button>\n                        )}\n                        <div className=\"select-chevron\" aria-hidden=\"true\">\n                            ▼\n                        </div>\n                    </div>\n                </div>\n\n                {error && (\n                    <div id={errorId} className=\"select-error-text\" role=\"alert\">\n                        {error}\n                    </div>\n                )}\n                {helperText && !error && (\n                    <div id={helperTextId} className=\"select-helper-text\">\n                        {helperText}\n                    </div>\n                )}\n            </div>\n        );\n    }\n);\nSelect.displayName = \"Select\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Select } from \"../Select\";\n\nconst mockOptions = [\n    { value: \"option1\", label: \"Option 1\" },\n    { value: \"option2\", label: \"Option 2\" },\n    { value: \"option3\", label: \"Option 3\", disabled: true },\n];\n\ntest(\"renders select with options\", () => {\n    render(<Select options={mockOptions} />);\n    const select = screen.getByRole(\"combobox\");\n    expect(select).toBeInTheDocument();\n    expect(screen.getByText(\"Option 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"Option 2\")).toBeInTheDocument();\n    expect(screen.getByText(\"Option 3\")).toBeInTheDocument();\n});\n\ntest(\"renders with label\", () => {\n    render(<Select options={mockOptions} label=\"Choose option\" />);\n    expect(screen.getByLabelText(\"Choose option\")).toBeInTheDocument();\n});\n\ntest(\"handles selection change\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Select options={mockOptions} onChange={onChange} />);\n\n    const select = screen.getByRole(\"combobox\");\n    await user.selectOptions(select, \"option2\");\n\n    expect(onChange).toHaveBeenCalled();\n    expect(select).toHaveValue(\"option2\");\n});\n\ntest(\"shows placeholder when provided\", () => {\n    render(<Select options={mockOptions} placeholder=\"Select an option...\" />);\n    expect(screen.getByText(\"Select an option...\")).toBeInTheDocument();\n});\n\ntest(\"shows error state\", () => {\n    render(<Select options={mockOptions} error=\"Selection is required\" />);\n    const select = screen.getByRole(\"combobox\");\n\n    expect(select).toHaveClass(\"select-error\");\n    expect(select).toHaveAttribute(\"aria-invalid\", \"true\");\n    expect(screen.getByRole(\"alert\")).toHaveTextContent(\"Selection is required\");\n});\n\ntest(\"shows helper text\", () => {\n    render(<Select options={mockOptions} helperText=\"Choose your preferred option\" />);\n    expect(screen.getByText(\"Choose your preferred option\")).toBeInTheDocument();\n});\n\ntest(\"applies variant and size classes\", () => {\n    render(<Select options={mockOptions} variant=\"outlined\" size=\"lg\" />);\n    const select = screen.getByRole(\"combobox\");\n    expect(select).toHaveClass(\"select\", \"select-outlined\", \"select-lg\");\n});\n\ntest(\"shows clear button when clearable and has value\", () => {\n    render(<Select options={mockOptions} value=\"option1\" clearable />);\n    expect(screen.getByLabelText(\"Clear selection\")).toBeInTheDocument();\n});\n\ntest(\"calls onClear when clear button clicked\", async () => {\n    const user = userEvent.setup();\n    const onClear = vi.fn();\n    render(\n        <Select\n            options={mockOptions}\n            value=\"option1\"\n            clearable\n            onClear={onClear}\n        />\n    );\n\n    await user.click(screen.getByLabelText(\"Clear selection\"));\n    expect(onClear).toHaveBeenCalledTimes(1);\n});\n\ntest(\"hides clear button when no value\", () => {\n    render(<Select options={mockOptions} clearable />);\n    expect(screen.queryByLabelText(\"Clear selection\")).not.toBeInTheDocument();\n});\n\ntest(\"disables options when specified\", () => {\n    render(<Select options={mockOptions} />);\n    const disabledOption = screen.getByRole(\"option\", { name: \"Option 3\" });\n    expect(disabledOption).toBeDisabled();\n});\n\ntest(\"associates helper text with select\", () => {\n    render(<Select options={mockOptions} helperText=\"Helper text\" />);\n    const select = screen.getByRole(\"combobox\");\n    const helperText = screen.getByText(\"Helper text\");\n\n    expect(select).toHaveAttribute(\"aria-describedby\", helperText.id);\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface SelectOption {\n    value: string | number;\n    label: string;\n    disabled?: boolean;\n}\n\nexport interface SelectProps extends Omit<React.SelectHTMLAttributes<HTMLSelectElement>, \"size\"> {\n    options: SelectOption[];\n    label?: string;\n    error?: string;\n    helperText?: string;\n    variant?: \"default\" | \"filled\" | \"outlined\";\n    size?: \"sm\" | \"md\" | \"lg\";\n    placeholder?: string;\n    clearable?: boolean;\n    onClear?: () => void;\n}\n\nconst classesByVariant: Record<NonNullable<SelectProps[\"variant\"]>, string> = {\n    default: \"select select-default\",\n    filled: \"select select-filled\",\n    outlined: \"select select-outlined\",\n};\n\nconst classesBySize: Record<NonNullable<SelectProps[\"size\"]>, string> = {\n    sm: \"select-sm\",\n    md: \"select-md\",\n    lg: \"select-lg\",\n};\n\nexport const Select = React.forwardRef<HTMLSelectElement, SelectProps>(\n    ({\n        options,\n        label,\n        error,\n        helperText,\n        variant = \"default\",\n        size = \"md\",\n        placeholder,\n        clearable = false,\n        onClear,\n        className,\n        id,\n        value,\n        ...rest\n    }, ref) => {\n        const selectId = id || React.useId();\n        const errorId = error ? `${selectId}-error` : undefined;\n        const helperTextId = helperText ? `${selectId}-helper` : undefined;\n\n        const classes = `${classesByVariant[variant]} ${classesBySize[size]} ${error ? \"select-error\" : \"\"\n            } ${className || \"\"}`.trim();\n\n        const handleClear = (e: React.MouseEvent) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (onClear) {\n                onClear();\n            }\n        };\n\n        const hasValue = value !== undefined && value !== \"\";\n        const showClearButton = clearable && hasValue && !rest.disabled;\n\n        return (\n            <div className=\"select-wrapper\">\n                {label && (\n                    <label htmlFor={selectId} className=\"select-label\">\n                        {label}\n                    </label>\n                )}\n\n                <div className=\"select-container\">\n                    <select\n                        {...rest}\n                        ref={ref}\n                        id={selectId}\n                        className={classes}\n                        value={value}\n                        aria-invalid={error ? true : undefined}\n                        aria-describedby={[errorId, helperTextId].filter(Boolean).join(\" \") || undefined}\n                    >\n                        {placeholder && (\n                            <option value=\"\" disabled hidden>\n                                {placeholder}\n                            </option>\n                        )}\n                        {options.map((option) => (\n                            <option\n                                key={option.value}\n                                value={option.value}\n                                disabled={option.disabled}\n                            >\n                                {option.label}\n                            </option>\n                        ))}\n                    </select>\n\n                    <div className=\"select-icons\">\n                        {showClearButton && (\n                            <button\n                                type=\"button\"\n                                className=\"select-clear\"\n                                onClick={handleClear}\n                                aria-label=\"Clear selection\"\n                                tabIndex={-1}\n                            >\n                                ×\n                            </button>\n                        )}\n                        <div className=\"select-chevron\" aria-hidden=\"true\">\n                            ▼\n                        </div>\n                    </div>\n                </div>\n\n                {error && (\n                    <div id={errorId} className=\"select-error-text\" role=\"alert\">\n                        {error}\n                    </div>\n                )}\n                {helperText && !error && (\n                    <div id={helperTextId} className=\"select-helper-text\">\n                        {helperText}\n                    </div>\n                )}\n            </div>\n        );\n    }\n);\nSelect.displayName = \"Select\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Select } from \"../Select\";\n\nconst mockOptions = [\n    { value: \"option1\", label: \"Option 1\" },\n    { value: \"option2\", label: \"Option 2\" },\n    { value: \"option3\", label: \"Option 3\", disabled: true },\n];\n\ntest(\"renders select with options\", () => {\n    render(<Select options={mockOptions} />);\n    const select = screen.getByRole(\"combobox\");\n    expect(select).toBeInTheDocument();\n    expect(screen.getByText(\"Option 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"Option 2\")).toBeInTheDocument();\n    expect(screen.getByText(\"Option 3\")).toBeInTheDocument();\n});\n\ntest(\"renders with label\", () => {\n    render(<Select options={mockOptions} label=\"Choose option\" />);\n    expect(screen.getByLabelText(\"Choose option\")).toBeInTheDocument();\n});\n\ntest(\"handles selection change\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Select options={mockOptions} onChange={onChange} />);\n\n    const select = screen.getByRole(\"combobox\");\n    await user.selectOptions(select, \"option2\");\n\n    expect(onChange).toHaveBeenCalled();\n    expect(select).toHaveValue(\"option2\");\n});\n\ntest(\"shows placeholder when provided\", () => {\n    render(<Select options={mockOptions} placeholder=\"Select an option...\" />);\n    expect(screen.getByText(\"Select an option...\")).toBeInTheDocument();\n});\n\ntest(\"shows error state\", () => {\n    render(<Select options={mockOptions} error=\"Selection is required\" />);\n    const select = screen.getByRole(\"combobox\");\n\n    expect(select).toHaveClass(\"select-error\");\n    expect(select).toHaveAttribute(\"aria-invalid\", \"true\");\n    expect(screen.getByRole(\"alert\")).toHaveTextContent(\"Selection is required\");\n});\n\ntest(\"shows helper text\", () => {\n    render(<Select options={mockOptions} helperText=\"Choose your preferred option\" />);\n    expect(screen.getByText(\"Choose your preferred option\")).toBeInTheDocument();\n});\n\ntest(\"applies variant and size classes\", () => {\n    render(<Select options={mockOptions} variant=\"outlined\" size=\"lg\" />);\n    const select = screen.getByRole(\"combobox\");\n    expect(select).toHaveClass(\"select\", \"select-outlined\", \"select-lg\");\n});\n\ntest(\"shows clear button when clearable and has value\", () => {\n    render(<Select options={mockOptions} value=\"option1\" clearable />);\n    expect(screen.getByLabelText(\"Clear selection\")).toBeInTheDocument();\n});\n\ntest(\"calls onClear when clear button clicked\", async () => {\n    const user = userEvent.setup();\n    const onClear = vi.fn();\n    render(\n        <Select\n            options={mockOptions}\n            value=\"option1\"\n            clearable\n            onClear={onClear}\n        />\n    );\n\n    await user.click(screen.getByLabelText(\"Clear selection\"));\n    expect(onClear).toHaveBeenCalledTimes(1);\n});\n\ntest(\"hides clear button when no value\", () => {\n    render(<Select options={mockOptions} clearable />);\n    expect(screen.queryByLabelText(\"Clear selection\")).not.toBeInTheDocument();\n});\n\ntest(\"disables options when specified\", () => {\n    render(<Select options={mockOptions} />);\n    const disabledOption = screen.getByRole(\"option\", { name: \"Option 3\" });\n    expect(disabledOption).toBeDisabled();\n});\n\ntest(\"associates helper text with select\", () => {\n    render(<Select options={mockOptions} helperText=\"Helper text\" />);\n    const select = screen.getByRole(\"combobox\");\n    const helperText = screen.getByText(\"Helper text\");\n\n    expect(select).toHaveAttribute(\"aria-describedby\", helperText.id);\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface SelectOption {\n    value: string | number;\n    label: string;\n    disabled?: boolean;\n}\n\nexport interface SelectProps extends Omit<React.SelectHTMLAttributes<HTMLSelectElement>, \"size\"> {\n    options: SelectOption[];\n    label?: string;\n    error?: string;\n    helperText?: string;\n    variant?: \"default\" | \"filled\" | \"outlined\";\n    size?: \"sm\" | \"md\" | \"lg\";\n    placeholder?: string;\n    clearable?: boolean;\n    onClear?: () => void;\n}\n\nconst classesByVariant: Record<NonNullable<SelectProps[\"variant\"]>, string> = {\n    default: \"select select-default\",\n    filled: \"select select-filled\",\n    outlined: \"select select-outlined\",\n};\n\nconst classesBySize: Record<NonNullable<SelectProps[\"size\"]>, string> = {\n    sm: \"select-sm\",\n    md: \"select-md\",\n    lg: \"select-lg\",\n};\n\nexport const Select = React.forwardRef<HTMLSelectElement, SelectProps>(\n    ({\n        options,\n        label,\n        error,\n        helperText,\n        variant = \"default\",\n        size = \"md\",\n        placeholder,\n        clearable = false,\n        onClear,\n        className,\n        id,\n        value,\n        ...rest\n    }, ref) => {\n        const selectId = id || React.useId();\n        const errorId = error ? `${selectId}-error` : undefined;\n        const helperTextId = helperText ? `${selectId}-helper` : undefined;\n\n        const classes = `${classesByVariant[variant]} ${classesBySize[size]} ${error ? \"select-error\" : \"\"\n            } ${className || \"\"}`.trim();\n\n        const handleClear = (e: React.MouseEvent) => {\n            e.preventDefault();\n            e.stopPropagation();\n            if (onClear) {\n                onClear();\n            }\n        };\n\n        const hasValue = value !== undefined && value !== \"\";\n        const showClearButton = clearable && hasValue && !rest.disabled;\n\n        return (\n            <div className=\"select-wrapper\">\n                {label && (\n                    <label htmlFor={selectId} className=\"select-label\">\n                        {label}\n                    </label>\n                )}\n\n                <div className=\"select-container\">\n                    <select\n                        {...rest}\n                        ref={ref}\n                        id={selectId}\n                        className={classes}\n                        value={value}\n                        aria-invalid={error ? true : undefined}\n                        aria-describedby={[errorId, helperTextId].filter(Boolean).join(\" \") || undefined}\n                    >\n                        {placeholder && (\n                            <option value=\"\" disabled hidden>\n                                {placeholder}\n                            </option>\n                        )}\n                        {options.map((option) => (\n                            <option\n                                key={option.value}\n                                value={option.value}\n                                disabled={option.disabled}\n                            >\n                                {option.label}\n                            </option>\n                        ))}\n                    </select>\n\n                    <div className=\"select-icons\">\n                        {showClearButton && (\n                            <button\n                                type=\"button\"\n                                className=\"select-clear\"\n                                onClick={handleClear}\n                                aria-label=\"Clear selection\"\n                                tabIndex={-1}\n                            >\n                                ×\n                            </button>\n                        )}\n                        <div className=\"select-chevron\" aria-hidden=\"true\">\n                            ▼\n                        </div>\n                    </div>\n                </div>\n\n                {error && (\n                    <div id={errorId} className=\"select-error-text\" role=\"alert\">\n                        {error}\n                    </div>\n                )}\n                {helperText && !error && (\n                    <div id={helperTextId} className=\"select-helper-text\">\n                        {helperText}\n                    </div>\n                )}\n            </div>\n        );\n    }\n);\nSelect.displayName = \"Select\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Select } from \"../Select\";\n\nconst mockOptions = [\n    { value: \"option1\", label: \"Option 1\" },\n    { value: \"option2\", label: \"Option 2\" },\n    { value: \"option3\", label: \"Option 3\", disabled: true },\n];\n\ntest(\"renders select with options\", () => {\n    render(<Select options={mockOptions} />);\n    const select = screen.getByRole(\"combobox\");\n    expect(select).toBeInTheDocument();\n    expect(screen.getByText(\"Option 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"Option 2\")).toBeInTheDocument();\n    expect(screen.getByText(\"Option 3\")).toBeInTheDocument();\n});\n\ntest(\"renders with label\", () => {\n    render(<Select options={mockOptions} label=\"Choose option\" />);\n    expect(screen.getByLabelText(\"Choose option\")).toBeInTheDocument();\n});\n\ntest(\"handles selection change\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Select options={mockOptions} onChange={onChange} />);\n\n    const select = screen.getByRole(\"combobox\");\n    await user.selectOptions(select, \"option2\");\n\n    expect(onChange).toHaveBeenCalled();\n    expect(select).toHaveValue(\"option2\");\n});\n\ntest(\"shows placeholder when provided\", () => {\n    render(<Select options={mockOptions} placeholder=\"Select an option...\" />);\n    expect(screen.getByText(\"Select an option...\")).toBeInTheDocument();\n});\n\ntest(\"shows error state\", () => {\n    render(<Select options={mockOptions} error=\"Selection is required\" />);\n    const select = screen.getByRole(\"combobox\");\n\n    expect(select).toHaveClass(\"select-error\");\n    expect(select).toHaveAttribute(\"aria-invalid\", \"true\");\n    expect(screen.getByRole(\"alert\")).toHaveTextContent(\"Selection is required\");\n});\n\ntest(\"shows helper text\", () => {\n    render(<Select options={mockOptions} helperText=\"Choose your preferred option\" />);\n    expect(screen.getByText(\"Choose your preferred option\")).toBeInTheDocument();\n});\n\ntest(\"applies variant and size classes\", () => {\n    render(<Select options={mockOptions} variant=\"outlined\" size=\"lg\" />);\n    const select = screen.getByRole(\"combobox\");\n    expect(select).toHaveClass(\"select\", \"select-outlined\", \"select-lg\");\n});\n\ntest(\"shows clear button when clearable and has value\", () => {\n    render(<Select options={mockOptions} value=\"option1\" clearable />);\n    expect(screen.getByLabelText(\"Clear selection\")).toBeInTheDocument();\n});\n\ntest(\"calls onClear when clear button clicked\", async () => {\n    const user = userEvent.setup();\n    const onClear = vi.fn();\n    render(\n        <Select\n            options={mockOptions}\n            value=\"option1\"\n            clearable\n            onClear={onClear}\n        />\n    );\n\n    await user.click(screen.getByLabelText(\"Clear selection\"));\n    expect(onClear).toHaveBeenCalledTimes(1);\n});\n\ntest(\"hides clear button when no value\", () => {\n    render(<Select options={mockOptions} clearable />);\n    expect(screen.queryByLabelText(\"Clear selection\")).not.toBeInTheDocument();\n});\n\ntest(\"disables options when specified\", () => {\n    render(<Select options={mockOptions} />);\n    const disabledOption = screen.getByRole(\"option\", { name: \"Option 3\" });\n    expect(disabledOption).toBeDisabled();\n});\n\ntest(\"associates helper text with select\", () => {\n    render(<Select options={mockOptions} helperText=\"Helper text\" />);\n    const select = screen.getByRole(\"combobox\");\n    const helperText = screen.getByText(\"Helper text\");\n\n    expect(select).toHaveAttribute(\"aria-describedby\", helperText.id);\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\ntype SkeletonVariant = \"text\" | \"circular\" | \"rectangular\";\n\nexport interface SkeletonProps extends React.HTMLAttributes<HTMLDivElement> {\n    variant?: SkeletonVariant;\n    width?: string | number;\n    height?: string | number;\n    animation?: \"pulse\" | \"wave\" | \"none\";\n}\n\nconst classesByVariant: Record<SkeletonVariant, string> = {\n    text: \"skeleton skeleton-text\",\n    circular: \"skeleton skeleton-circular\",\n    rectangular: \"skeleton skeleton-rectangular\",\n};\n\nconst classesByAnimation: Record<NonNullable<SkeletonProps[\"animation\"]>, string> = {\n    pulse: \"skeleton-pulse\",\n    wave: \"skeleton-wave\",\n    none: \"\",\n};\n\nexport const Skeleton = React.forwardRef<HTMLDivElement, SkeletonProps>(\n    ({ variant = \"text\", width, height, animation = \"pulse\", className, style, ...rest }, ref) => {\n        const classes = `${classesByVariant[variant]} ${classesByAnimation[animation]} ${className || \"\"}`.trim();\n\n        const skeletonStyle: React.CSSProperties = {\n            ...style,\n            ...(width && { width: typeof width === \"number\" ? `${width}px` : width }),\n            ...(height && { height: typeof height === \"number\" ? `${height}px` : height }),\n        };\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                style={skeletonStyle}\n                aria-hidden=\"true\"\n            />\n        );\n    }\n);\nSkeleton.displayName = \"Skeleton\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Skeleton } from \"../Skeleton\";\n\ntest(\"renders with default classes\", () => {\n    render(<Skeleton data-testid=\"skeleton\" />);\n    const skeleton = screen.getByTestId(\"skeleton\");\n    expect(skeleton).toHaveClass(\"skeleton\", \"skeleton-text\", \"skeleton-pulse\");\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Skeleton variant=\"circular\" data-testid=\"skeleton\" />);\n    expect(screen.getByTestId(\"skeleton\")).toHaveClass(\"skeleton-circular\");\n});\n\ntest(\"applies animation classes\", () => {\n    render(<Skeleton animation=\"wave\" data-testid=\"skeleton\" />);\n    expect(screen.getByTestId(\"skeleton\")).toHaveClass(\"skeleton-wave\");\n});\n\ntest(\"applies width and height styles\", () => {\n    render(<Skeleton width={200} height=\"50px\" data-testid=\"skeleton\" />);\n    const skeleton = screen.getByTestId(\"skeleton\");\n    expect(skeleton).toHaveStyle({ width: \"200px\", height: \"50px\" });\n});\n\ntest(\"is hidden from screen readers\", () => {\n    render(<Skeleton data-testid=\"skeleton\" />);\n    expect(screen.getByTestId(\"skeleton\")).toHaveAttribute(\"aria-hidden\", \"true\");\n});\n\ntest(\"handles no animation\", () => {\n    render(<Skeleton animation=\"none\" data-testid=\"skeleton\" />);\n    const skeleton = screen.getByTestId(\"skeleton\");\n    expect(skeleton).not.toHaveClass(\"skeleton-pulse\");\n    expect(skeleton).not.toHaveClass(\"skeleton-wave\");\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\ntype SkeletonVariant = \"text\" | \"circular\" | \"rectangular\";\n\nexport interface SkeletonProps extends React.HTMLAttributes<HTMLDivElement> {\n    variant?: SkeletonVariant;\n    width?: string | number;\n    height?: string | number;\n    animation?: \"pulse\" | \"wave\" | \"none\";\n}\n\nconst classesByVariant: Record<SkeletonVariant, string> = {\n    text: \"skeleton skeleton-text\",\n    circular: \"skeleton skeleton-circular\",\n    rectangular: \"skeleton skeleton-rectangular\",\n};\n\nconst classesByAnimation: Record<NonNullable<SkeletonProps[\"animation\"]>, string> = {\n    pulse: \"skeleton-pulse\",\n    wave: \"skeleton-wave\",\n    none: \"\",\n};\n\nexport const Skeleton = React.forwardRef<HTMLDivElement, SkeletonProps>(\n    ({ variant = \"text\", width, height, animation = \"pulse\", className, style, ...rest }, ref) => {\n        const classes = `${classesByVariant[variant]} ${classesByAnimation[animation]} ${className || \"\"}`.trim();\n\n        const skeletonStyle: React.CSSProperties = {\n            ...style,\n            ...(width && { width: typeof width === \"number\" ? `${width}px` : width }),\n            ...(height && { height: typeof height === \"number\" ? `${height}px` : height }),\n        };\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                style={skeletonStyle}\n                aria-hidden=\"true\"\n            />\n        );\n    }\n);\nSkeleton.displayName = \"Skeleton\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Skeleton } from \"../Skeleton\";\n\ntest(\"renders with default classes\", () => {\n    render(<Skeleton data-testid=\"skeleton\" />);\n    const skeleton = screen.getByTestId(\"skeleton\");\n    expect(skeleton).toHaveClass(\"skeleton\", \"skeleton-text\", \"skeleton-pulse\");\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Skeleton variant=\"circular\" data-testid=\"skeleton\" />);\n    expect(screen.getByTestId(\"skeleton\")).toHaveClass(\"skeleton-circular\");\n});\n\ntest(\"applies animation classes\", () => {\n    render(<Skeleton animation=\"wave\" data-testid=\"skeleton\" />);\n    expect(screen.getByTestId(\"skeleton\")).toHaveClass(\"skeleton-wave\");\n});\n\ntest(\"applies width and height styles\", () => {\n    render(<Skeleton width={200} height=\"50px\" data-testid=\"skeleton\" />);\n    const skeleton = screen.getByTestId(\"skeleton\");\n    expect(skeleton).toHaveStyle({ width: \"200px\", height: \"50px\" });\n});\n\ntest(\"is hidden from screen readers\", () => {\n    render(<Skeleton data-testid=\"skeleton\" />);\n    expect(screen.getByTestId(\"skeleton\")).toHaveAttribute(\"aria-hidden\", \"true\");\n});\n\ntest(\"handles no animation\", () => {\n    render(<Skeleton animation=\"none\" data-testid=\"skeleton\" />);\n    const skeleton = screen.getByTestId(\"skeleton\");\n    expect(skeleton).not.toHaveClass(\"skeleton-pulse\");\n    expect(skeleton).not.toHaveClass(\"skeleton-wave\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\ntype SkeletonVariant = \"text\" | \"circular\" | \"rectangular\";\n\nexport interface SkeletonProps extends React.HTMLAttributes<HTMLDivElement> {\n    variant?: SkeletonVariant;\n    width?: string | number;\n    height?: string | number;\n    animation?: \"pulse\" | \"wave\" | \"none\";\n}\n\nconst classesByVariant: Record<SkeletonVariant, string> = {\n    text: \"skeleton skeleton-text\",\n    circular: \"skeleton skeleton-circular\",\n    rectangular: \"skeleton skeleton-rectangular\",\n};\n\nconst classesByAnimation: Record<NonNullable<SkeletonProps[\"animation\"]>, string> = {\n    pulse: \"skeleton-pulse\",\n    wave: \"skeleton-wave\",\n    none: \"\",\n};\n\nexport const Skeleton = React.forwardRef<HTMLDivElement, SkeletonProps>(\n    ({ variant = \"text\", width, height, animation = \"pulse\", className, style, ...rest }, ref) => {\n        const classes = `${classesByVariant[variant]} ${classesByAnimation[animation]} ${className || \"\"}`.trim();\n\n        const skeletonStyle: React.CSSProperties = {\n            ...style,\n            ...(width && { width: typeof width === \"number\" ? `${width}px` : width }),\n            ...(height && { height: typeof height === \"number\" ? `${height}px` : height }),\n        };\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                style={skeletonStyle}\n                aria-hidden=\"true\"\n            />\n        );\n    }\n);\nSkeleton.displayName = \"Skeleton\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Skeleton } from \"../Skeleton\";\n\ntest(\"renders with default classes\", () => {\n    render(<Skeleton data-testid=\"skeleton\" />);\n    const skeleton = screen.getByTestId(\"skeleton\");\n    expect(skeleton).toHaveClass(\"skeleton\", \"skeleton-text\", \"skeleton-pulse\");\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Skeleton variant=\"circular\" data-testid=\"skeleton\" />);\n    expect(screen.getByTestId(\"skeleton\")).toHaveClass(\"skeleton-circular\");\n});\n\ntest(\"applies animation classes\", () => {\n    render(<Skeleton animation=\"wave\" data-testid=\"skeleton\" />);\n    expect(screen.getByTestId(\"skeleton\")).toHaveClass(\"skeleton-wave\");\n});\n\ntest(\"applies width and height styles\", () => {\n    render(<Skeleton width={200} height=\"50px\" data-testid=\"skeleton\" />);\n    const skeleton = screen.getByTestId(\"skeleton\");\n    expect(skeleton).toHaveStyle({ width: \"200px\", height: \"50px\" });\n});\n\ntest(\"is hidden from screen readers\", () => {\n    render(<Skeleton data-testid=\"skeleton\" />);\n    expect(screen.getByTestId(\"skeleton\")).toHaveAttribute(\"aria-hidden\", \"true\");\n});\n\ntest(\"handles no animation\", () => {\n    render(<Skeleton animation=\"none\" data-testid=\"skeleton\" />);\n    const skeleton = screen.getByTestId(\"skeleton\");\n    expect(skeleton).not.toHaveClass(\"skeleton-pulse\");\n    expect(skeleton).not.toHaveClass(\"skeleton-wave\");\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface SliderProps extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n  value?: number | number[];\n  defaultValue?: number | number[];\n  min?: number;\n  max?: number;\n  step?: number;\n  range?: boolean;\n  disabled?: boolean;\n  vertical?: boolean;\n  showMarks?: boolean;\n  marks?: Record<number, string | React.ReactNode>;\n  showTooltip?: boolean;\n  formatTooltip?: (value: number) => string;\n  onChange?: (value: number | number[]) => void;\n  onChangeCommitted?: (value: number | number[]) => void;\n  size?: \"sm\" | \"md\" | \"lg\";\n  variant?: \"default\" | \"primary\" | \"secondary\";\n}\n\nconst classesBySize: Record<NonNullable<SliderProps[\"size\"]>, string> = {\n  sm: \"slider-sm\",\n  md: \"slider-md\",\n  lg: \"slider-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<SliderProps[\"variant\"]>, string> = {\n  default: \"slider-default\",\n  primary: \"slider-primary\",\n  secondary: \"slider-secondary\",\n};\n\nexport const Slider = React.forwardRef<HTMLDivElement, SliderProps>(\n  ({\n    value: controlledValue,\n    defaultValue = 0,\n    min = 0,\n    max = 100,\n    step = 1,\n    range = false,\n    disabled = false,\n    vertical = false,\n    showMarks = false,\n    marks,\n    showTooltip = false,\n    formatTooltip = (val) => val.toString(),\n    onChange,\n    onChangeCommitted,\n    size = \"md\",\n    variant = \"default\",\n    className,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState<number | number[]>(n      range ? (Array.isArray(defaultValue) ? defaultValue : [min, defaultValue as number]) : (defaultValue as number)\n    );\n    const [isDragging, setIsDragging] = React.useState(false);\n    const [activeThumb, setActiveThumb] = React.useState<number | null>(null);\n    \n    const sliderRef = React.useRef<HTMLDivElement>(null);\n    const combinedRef = React.useMemo(() => ref || sliderRef, [ref]);\n\n    const isControlled = controlledValue !== undefined;\n    const value = isControlled ? controlledValue : internalValue;\n\n    const classes = `slider ${vertical ? \"slider-vertical\" : \"slider-horizontal\"} ${\n      classesBySize[size]\n    } ${classesByVariant[variant]} ${disabled ? \"slider-disabled\" : \"\"} ${className || \"\"}`.trim();\n\n    const normalizeValue = (val: number) => {\n      return Math.min(Math.max(val, min), max);\n    };\n\n    const getPercentage = (val: number) => {\n      return ((val - min) / (max - min)) * 100;\n    };\n\n    const getValueFromPosition = (clientX: number, clientY: number) => {\n      if (!combinedRef || !(\"current\" in combinedRef) || !combinedRef.current) return min;\n      \n      const rect = combinedRef.current.getBoundingClientRect();\n      const percentage = vertical\n        ? (rect.bottom - clientY) / rect.height\n        : (clientX - rect.left) / rect.width;\n      \n      const rawValue = min + percentage * (max - min);\n      const steppedValue = Math.round(rawValue / step) * step;\n      return normalizeValue(steppedValue);\n    };\n\n    const updateValue = (newValue: number | number[]) => {\n      if (onChange) {\n        onChange(newValue);\n      }\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n    };\n\n    const handleMouseDown = (event: React.MouseEvent, thumbIndex?: number) => {\n      if (disabled) return;\n      \n      event.preventDefault();\n      setIsDragging(true);\n      \n      if (range && Array.isArray(value)) {\n        if (thumbIndex !== undefined) {\n          setActiveThumb(thumbIndex);\n        } else {\n          // Determine which thumb is closer\n          const newValue = getValueFromPosition(event.clientX, event.clientY);\n          const distances = value.map(val => Math.abs(val - newValue));\n          const closestIndex = distances.indexOf(Math.min(...distances));\n          setActiveThumb(closestIndex);\n        }\n      } else {\n        const newValue = getValueFromPosition(event.clientX, event.clientY);\n        updateValue(newValue);\n      }\n    };\n\n    const handleMouseMove = React.useCallback((event: MouseEvent) => {\n      if (!isDragging || disabled) return;\n      \n      const newValue = getValueFromPosition(event.clientX, event.clientY);\n      \n      if (range && Array.isArray(value) && activeThumb !== null) {\n        const newRange = [...value];\n        newRange[activeThumb] = newValue;\n        // Ensure min <= max for range\n        if (newRange[0] > newRange[1]) {\n          newRange.reverse();\n          setActiveThumb(activeThumb === 0 ? 1 : 0);\n        }\n        updateValue(newRange);\n      } else if (!range) {\n        updateValue(newValue);\n      }\n    }, [isDragging, disabled, range, value, activeThumb, getValueFromPosition, updateValue]);\n\n    const handleMouseUp = React.useCallback(() => {\n      if (isDragging) {\n        setIsDragging(false);\n        setActiveThumb(null);\n        if (onChangeCommitted) {\n          onChangeCommitted(value);\n        }\n      }\n    }, [isDragging, onChangeCommitted, value]);\n\n    React.useEffect(() => {\n      if (isDragging) {\n        document.addEventListener(\"mousemove\", handleMouseMove);\n        document.addEventListener(\"mouseup\", handleMouseUp);\n        \n        return () => {\n          document.removeEventListener(\"mousemove\", handleMouseMove);\n          document.removeEventListener(\"mouseup\", handleMouseUp);\n        };\n      }\n    }, [isDragging, handleMouseMove, handleMouseUp]);\n\n    const handleKeyDown = (event: React.KeyboardEvent, thumbIndex = 0) => {\n      if (disabled) return;\n      \n      const isRange = range && Array.isArray(value);\n      const currentValue = isRange ? value[thumbIndex] : (value as number);\n      let newValue = currentValue;\n      \n      switch (event.key) {\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n          event.preventDefault();\n          newValue = Math.min(currentValue + step, max);\n          break;\n        case \"ArrowLeft\":\n        case \"ArrowDown\":\n          event.preventDefault();\n          newValue = Math.max(currentValue - step, min);\n          break;\n        case \"Home\":\n          event.preventDefault();\n          newValue = min;\n          break;\n        case \"End\":\n          event.preventDefault();\n          newValue = max;\n          break;\n        case \"PageUp\":\n          event.preventDefault();\n          newValue = Math.min(currentValue + step * 10, max);\n          break;\n        case \"PageDown\":\n          event.preventDefault();\n          newValue = Math.max(currentValue - step * 10, min);\n          break;\n        default:\n          return;\n      }\n      \n      if (isRange) {\n        const newRange = [...value];\n        newRange[thumbIndex] = newValue;\n        updateValue(newRange);\n      } else {\n        updateValue(newValue);\n      }\n    };\n\n    const renderThumb = (val: number, index = 0) => (\n      <div\n        key={index}\n        className={`slider-thumb ${activeThumb === index ? \"slider-thumb-active\" : \"\"}`}\n        style={{\n          [vertical ? \"bottom\" : \"left\"]: `${getPercentage(val)}%`,\n        }}\n        onMouseDown={(e) => handleMouseDown(e, index)}\n        onKeyDown={(e) => handleKeyDown(e, index)}\n        tabIndex={disabled ? -1 : 0}\n        role=\"slider\"\n        aria-valuemin={min}\n        aria-valuemax={max}\n        aria-valuenow={val}\n        aria-orientation={vertical ? \"vertical\" : \"horizontal\"}\n        aria-disabled={disabled}\n      >\n        {showTooltip && (\n          <div className=\"slider-tooltip\">\n            {formatTooltip(val)}\n          </div>\n        )}\n      </div>\n    );\n\n    const renderMarks = () => {\n      if (!showMarks && !marks) return null;\n      \n      const markValues = marks ? Object.keys(marks).map(Number) : [];\n      const defaultMarks = !marks && showMarks \n        ? Array.from({ length: Math.floor((max - min) / step) + 1 }, (_, i) => min + i * step)\n        : [];\n      \n      const allMarks = marks ? markValues : defaultMarks;\n      \n      return allMarks.map(markValue => (\n        <div\n          key={markValue}\n          className=\"slider-mark\"\n          style={{\n            [vertical ? \"bottom\" : \"left\"]: `${getPercentage(markValue)}%`,\n          }}\n        >\n          <div className=\"slider-mark-dot\" />\n          {marks && marks[markValue] && (\n            <div className=\"slider-mark-label\">\n              {marks[markValue]}\n            </div>\n          )}\n        </div>\n      ));\n    };\n\n    const getTrackStyle = () => {\n      if (range && Array.isArray(value)) {\n        const [start, end] = value.sort((a, b) => a - b);\n        return {\n          [vertical ? \"bottom\" : \"left\"]: `${getPercentage(start)}%`,\n          [vertical ? \"height\" : \"width\"]: `${getPercentage(end) - getPercentage(start)}%`,\n        };\n      } else {\n        return {\n          [vertical ? \"height\" : \"width\"]: `${getPercentage(value as number)}%`,\n        };\n      }\n    };\n\n    return (\n      <div\n        {...rest}\n        ref={combinedRef}\n        className={classes}\n        onMouseDown={handleMouseDown}\n      >\n        <div className=\"slider-rail\" />\n        <div className=\"slider-track\" style={getTrackStyle()} />\n        {renderMarks()}\n        {range && Array.isArray(value)\n          ? value.map((val, index) => renderThumb(val, index))\n          : renderThumb(value as number)\n        }\n      </div>\n    );\n  }\n);\nSlider.displayName = \"Slider\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Slider } from \"../Slider\";\n\ntest(\"renders slider with default value\", () => {\n  render(<Slider defaultValue={50} />);\n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-valuenow\", \"50\");\n});\n\ntest(\"renders range slider with two thumbs\", () => {\n  render(<Slider range defaultValue={[25, 75]} />);\n  const sliders = screen.getAllByRole(\"slider\");\n  expect(sliders).toHaveLength(2);\n  expect(sliders[0]).toHaveAttribute(\"aria-valuenow\", \"25\");\n  expect(sliders[1]).toHaveAttribute(\"aria-valuenow\", \"75\");\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Slider defaultValue={50} onChange={onChange} />);\n  \n  const slider = screen.getByRole(\"slider\");\n  slider.focus();\n  \n  await user.keyboard(\"{ArrowRight}\");\n  expect(onChange).toHaveBeenCalledWith(51);\n  \n  await user.keyboard(\"{ArrowLeft}\");\n  expect(onChange).toHaveBeenCalledWith(49);\n});\n\ntest(\"handles home and end keys\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Slider defaultValue={50} min={0} max={100} onChange={onChange} />);\n  \n  const slider = screen.getByRole(\"slider\");\n  slider.focus();\n  \n  await user.keyboard(\"{Home}\");\n  expect(onChange).toHaveBeenCalledWith(0);\n  \n  await user.keyboard(\"{End}\");\n  expect(onChange).toHaveBeenCalledWith(100);\n});\n\ntest(\"respects min and max values\", () => {\n  render(<Slider defaultValue={50} min={10} max={90} />);\n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-valuemin\", \"10\");\n  expect(slider).toHaveAttribute(\"aria-valuemax\", \"90\");\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  render(<Slider value={75} onChange={onChange} />);\n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-valuenow\", \"75\");\n});\n\ntest(\"shows tooltip when enabled\", () => {\n  render(<Slider defaultValue={50} showTooltip />);\n  expect(screen.getByText(\"50\")).toBeInTheDocument();\n});\n\ntest(\"formats tooltip with custom formatter\", () => {\n  const formatTooltip = (value: number) => `${value}%`;\n  render(<Slider defaultValue={50} showTooltip formatTooltip={formatTooltip} />);\n  expect(screen.getByText(\"50%\")).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<Slider size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"slider-lg\");\n});\n\ntest(\"applies variant classes\", () => {\n  const { container } = render(<Slider variant=\"primary\" />);\n  expect(container.firstChild).toHaveClass(\"slider-primary\");\n});\n\ntest(\"applies vertical orientation\", () => {\n  const { container } = render(<Slider vertical />);\n  expect(container.firstChild).toHaveClass(\"slider-vertical\");\n  \n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-orientation\", \"vertical\");\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Slider disabled onChange={onChange} />);\n  \n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-disabled\", \"true\");\n  expect(slider).toHaveAttribute(\"tabindex\", \"-1\");\n  \n  slider.focus();\n  await user.keyboard(\"{ArrowRight}\");\n  expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"shows marks when enabled\", () => {\n  const marks = { 0: \"Min\", 50: \"Mid\", 100: \"Max\" };\n  const { container } = render(<Slider marks={marks} />);\n  \n  expect(screen.getByText(\"Min\")).toBeInTheDocument();\n  expect(screen.getByText(\"Mid\")).toBeInTheDocument();\n  expect(screen.getByText(\"Max\")).toBeInTheDocument();\n  \n  const markDots = container.querySelectorAll(\".slider-mark-dot\");\n  expect(markDots).toHaveLength(3);\n});\n\ntest(\"calls onChangeCommitted when dragging ends\", async () => {\n  const user = userEvent.setup();\n  const onChangeCommitted = vi.fn();\n  render(<Slider defaultValue={50} onChangeCommitted={onChangeCommitted} />);\n  \n  const slider = screen.getByRole(\"slider\");\n  await user.pointer([\n    { target: slider, keys: \"[MouseLeft>]\" },\n    { keys: \"[/MouseLeft]\" },\n  ]);\n  \n  expect(onChangeCommitted).toHaveBeenCalled();\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface SliderProps extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n  value?: number | number[];\n  defaultValue?: number | number[];\n  min?: number;\n  max?: number;\n  step?: number;\n  range?: boolean;\n  disabled?: boolean;\n  vertical?: boolean;\n  showMarks?: boolean;\n  marks?: Record<number, string | React.ReactNode>;\n  showTooltip?: boolean;\n  formatTooltip?: (value: number) => string;\n  onChange?: (value: number | number[]) => void;\n  onChangeCommitted?: (value: number | number[]) => void;\n  size?: \"sm\" | \"md\" | \"lg\";\n  variant?: \"default\" | \"primary\" | \"secondary\";\n}\n\nconst classesBySize: Record<NonNullable<SliderProps[\"size\"]>, string> = {\n  sm: \"slider-sm\",\n  md: \"slider-md\",\n  lg: \"slider-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<SliderProps[\"variant\"]>, string> = {\n  default: \"slider-default\",\n  primary: \"slider-primary\",\n  secondary: \"slider-secondary\",\n};\n\nexport const Slider = React.forwardRef<HTMLDivElement, SliderProps>(\n  ({\n    value: controlledValue,\n    defaultValue = 0,\n    min = 0,\n    max = 100,\n    step = 1,\n    range = false,\n    disabled = false,\n    vertical = false,\n    showMarks = false,\n    marks,\n    showTooltip = false,\n    formatTooltip = (val) => val.toString(),\n    onChange,\n    onChangeCommitted,\n    size = \"md\",\n    variant = \"default\",\n    className,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState<number | number[]>(n      range ? (Array.isArray(defaultValue) ? defaultValue : [min, defaultValue as number]) : (defaultValue as number)\n    );\n    const [isDragging, setIsDragging] = React.useState(false);\n    const [activeThumb, setActiveThumb] = React.useState<number | null>(null);\n    \n    const sliderRef = React.useRef<HTMLDivElement>(null);\n    const combinedRef = React.useMemo(() => ref || sliderRef, [ref]);\n\n    const isControlled = controlledValue !== undefined;\n    const value = isControlled ? controlledValue : internalValue;\n\n    const classes = `slider ${vertical ? \"slider-vertical\" : \"slider-horizontal\"} ${\n      classesBySize[size]\n    } ${classesByVariant[variant]} ${disabled ? \"slider-disabled\" : \"\"} ${className || \"\"}`.trim();\n\n    const normalizeValue = (val: number) => {\n      return Math.min(Math.max(val, min), max);\n    };\n\n    const getPercentage = (val: number) => {\n      return ((val - min) / (max - min)) * 100;\n    };\n\n    const getValueFromPosition = (clientX: number, clientY: number) => {\n      if (!combinedRef || !(\"current\" in combinedRef) || !combinedRef.current) return min;\n      \n      const rect = combinedRef.current.getBoundingClientRect();\n      const percentage = vertical\n        ? (rect.bottom - clientY) / rect.height\n        : (clientX - rect.left) / rect.width;\n      \n      const rawValue = min + percentage * (max - min);\n      const steppedValue = Math.round(rawValue / step) * step;\n      return normalizeValue(steppedValue);\n    };\n\n    const updateValue = (newValue: number | number[]) => {\n      if (onChange) {\n        onChange(newValue);\n      }\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n    };\n\n    const handleMouseDown = (event: React.MouseEvent, thumbIndex?: number) => {\n      if (disabled) return;\n      \n      event.preventDefault();\n      setIsDragging(true);\n      \n      if (range && Array.isArray(value)) {\n        if (thumbIndex !== undefined) {\n          setActiveThumb(thumbIndex);\n        } else {\n          // Determine which thumb is closer\n          const newValue = getValueFromPosition(event.clientX, event.clientY);\n          const distances = value.map(val => Math.abs(val - newValue));\n          const closestIndex = distances.indexOf(Math.min(...distances));\n          setActiveThumb(closestIndex);\n        }\n      } else {\n        const newValue = getValueFromPosition(event.clientX, event.clientY);\n        updateValue(newValue);\n      }\n    };\n\n    const handleMouseMove = React.useCallback((event: MouseEvent) => {\n      if (!isDragging || disabled) return;\n      \n      const newValue = getValueFromPosition(event.clientX, event.clientY);\n      \n      if (range && Array.isArray(value) && activeThumb !== null) {\n        const newRange = [...value];\n        newRange[activeThumb] = newValue;\n        // Ensure min <= max for range\n        if (newRange[0] > newRange[1]) {\n          newRange.reverse();\n          setActiveThumb(activeThumb === 0 ? 1 : 0);\n        }\n        updateValue(newRange);\n      } else if (!range) {\n        updateValue(newValue);\n      }\n    }, [isDragging, disabled, range, value, activeThumb, getValueFromPosition, updateValue]);\n\n    const handleMouseUp = React.useCallback(() => {\n      if (isDragging) {\n        setIsDragging(false);\n        setActiveThumb(null);\n        if (onChangeCommitted) {\n          onChangeCommitted(value);\n        }\n      }\n    }, [isDragging, onChangeCommitted, value]);\n\n    React.useEffect(() => {\n      if (isDragging) {\n        document.addEventListener(\"mousemove\", handleMouseMove);\n        document.addEventListener(\"mouseup\", handleMouseUp);\n        \n        return () => {\n          document.removeEventListener(\"mousemove\", handleMouseMove);\n          document.removeEventListener(\"mouseup\", handleMouseUp);\n        };\n      }\n    }, [isDragging, handleMouseMove, handleMouseUp]);\n\n    const handleKeyDown = (event: React.KeyboardEvent, thumbIndex = 0) => {\n      if (disabled) return;\n      \n      const isRange = range && Array.isArray(value);\n      const currentValue = isRange ? value[thumbIndex] : (value as number);\n      let newValue = currentValue;\n      \n      switch (event.key) {\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n          event.preventDefault();\n          newValue = Math.min(currentValue + step, max);\n          break;\n        case \"ArrowLeft\":\n        case \"ArrowDown\":\n          event.preventDefault();\n          newValue = Math.max(currentValue - step, min);\n          break;\n        case \"Home\":\n          event.preventDefault();\n          newValue = min;\n          break;\n        case \"End\":\n          event.preventDefault();\n          newValue = max;\n          break;\n        case \"PageUp\":\n          event.preventDefault();\n          newValue = Math.min(currentValue + step * 10, max);\n          break;\n        case \"PageDown\":\n          event.preventDefault();\n          newValue = Math.max(currentValue - step * 10, min);\n          break;\n        default:\n          return;\n      }\n      \n      if (isRange) {\n        const newRange = [...value];\n        newRange[thumbIndex] = newValue;\n        updateValue(newRange);\n      } else {\n        updateValue(newValue);\n      }\n    };\n\n    const renderThumb = (val: number, index = 0) => (\n      <div\n        key={index}\n        className={`slider-thumb ${activeThumb === index ? \"slider-thumb-active\" : \"\"}`}\n        style={{\n          [vertical ? \"bottom\" : \"left\"]: `${getPercentage(val)}%`,\n        }}\n        onMouseDown={(e) => handleMouseDown(e, index)}\n        onKeyDown={(e) => handleKeyDown(e, index)}\n        tabIndex={disabled ? -1 : 0}\n        role=\"slider\"\n        aria-valuemin={min}\n        aria-valuemax={max}\n        aria-valuenow={val}\n        aria-orientation={vertical ? \"vertical\" : \"horizontal\"}\n        aria-disabled={disabled}\n      >\n        {showTooltip && (\n          <div className=\"slider-tooltip\">\n            {formatTooltip(val)}\n          </div>\n        )}\n      </div>\n    );\n\n    const renderMarks = () => {\n      if (!showMarks && !marks) return null;\n      \n      const markValues = marks ? Object.keys(marks).map(Number) : [];\n      const defaultMarks = !marks && showMarks \n        ? Array.from({ length: Math.floor((max - min) / step) + 1 }, (_, i) => min + i * step)\n        : [];\n      \n      const allMarks = marks ? markValues : defaultMarks;\n      \n      return allMarks.map(markValue => (\n        <div\n          key={markValue}\n          className=\"slider-mark\"\n          style={{\n            [vertical ? \"bottom\" : \"left\"]: `${getPercentage(markValue)}%`,\n          }}\n        >\n          <div className=\"slider-mark-dot\" />\n          {marks && marks[markValue] && (\n            <div className=\"slider-mark-label\">\n              {marks[markValue]}\n            </div>\n          )}\n        </div>\n      ));\n    };\n\n    const getTrackStyle = () => {\n      if (range && Array.isArray(value)) {\n        const [start, end] = value.sort((a, b) => a - b);\n        return {\n          [vertical ? \"bottom\" : \"left\"]: `${getPercentage(start)}%`,\n          [vertical ? \"height\" : \"width\"]: `${getPercentage(end) - getPercentage(start)}%`,\n        };\n      } else {\n        return {\n          [vertical ? \"height\" : \"width\"]: `${getPercentage(value as number)}%`,\n        };\n      }\n    };\n\n    return (\n      <div\n        {...rest}\n        ref={combinedRef}\n        className={classes}\n        onMouseDown={handleMouseDown}\n      >\n        <div className=\"slider-rail\" />\n        <div className=\"slider-track\" style={getTrackStyle()} />\n        {renderMarks()}\n        {range && Array.isArray(value)\n          ? value.map((val, index) => renderThumb(val, index))\n          : renderThumb(value as number)\n        }\n      </div>\n    );\n  }\n);\nSlider.displayName = \"Slider\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Slider } from \"../Slider\";\n\ntest(\"renders slider with default value\", () => {\n  render(<Slider defaultValue={50} />);\n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-valuenow\", \"50\");\n});\n\ntest(\"renders range slider with two thumbs\", () => {\n  render(<Slider range defaultValue={[25, 75]} />);\n  const sliders = screen.getAllByRole(\"slider\");\n  expect(sliders).toHaveLength(2);\n  expect(sliders[0]).toHaveAttribute(\"aria-valuenow\", \"25\");\n  expect(sliders[1]).toHaveAttribute(\"aria-valuenow\", \"75\");\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Slider defaultValue={50} onChange={onChange} />);\n  \n  const slider = screen.getByRole(\"slider\");\n  slider.focus();\n  \n  await user.keyboard(\"{ArrowRight}\");\n  expect(onChange).toHaveBeenCalledWith(51);\n  \n  await user.keyboard(\"{ArrowLeft}\");\n  expect(onChange).toHaveBeenCalledWith(49);\n});\n\ntest(\"handles home and end keys\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Slider defaultValue={50} min={0} max={100} onChange={onChange} />);\n  \n  const slider = screen.getByRole(\"slider\");\n  slider.focus();\n  \n  await user.keyboard(\"{Home}\");\n  expect(onChange).toHaveBeenCalledWith(0);\n  \n  await user.keyboard(\"{End}\");\n  expect(onChange).toHaveBeenCalledWith(100);\n});\n\ntest(\"respects min and max values\", () => {\n  render(<Slider defaultValue={50} min={10} max={90} />);\n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-valuemin\", \"10\");\n  expect(slider).toHaveAttribute(\"aria-valuemax\", \"90\");\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  render(<Slider value={75} onChange={onChange} />);\n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-valuenow\", \"75\");\n});\n\ntest(\"shows tooltip when enabled\", () => {\n  render(<Slider defaultValue={50} showTooltip />);\n  expect(screen.getByText(\"50\")).toBeInTheDocument();\n});\n\ntest(\"formats tooltip with custom formatter\", () => {\n  const formatTooltip = (value: number) => `${value}%`;\n  render(<Slider defaultValue={50} showTooltip formatTooltip={formatTooltip} />);\n  expect(screen.getByText(\"50%\")).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<Slider size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"slider-lg\");\n});\n\ntest(\"applies variant classes\", () => {\n  const { container } = render(<Slider variant=\"primary\" />);\n  expect(container.firstChild).toHaveClass(\"slider-primary\");\n});\n\ntest(\"applies vertical orientation\", () => {\n  const { container } = render(<Slider vertical />);\n  expect(container.firstChild).toHaveClass(\"slider-vertical\");\n  \n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-orientation\", \"vertical\");\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Slider disabled onChange={onChange} />);\n  \n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-disabled\", \"true\");\n  expect(slider).toHaveAttribute(\"tabindex\", \"-1\");\n  \n  slider.focus();\n  await user.keyboard(\"{ArrowRight}\");\n  expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"shows marks when enabled\", () => {\n  const marks = { 0: \"Min\", 50: \"Mid\", 100: \"Max\" };\n  const { container } = render(<Slider marks={marks} />);\n  \n  expect(screen.getByText(\"Min\")).toBeInTheDocument();\n  expect(screen.getByText(\"Mid\")).toBeInTheDocument();\n  expect(screen.getByText(\"Max\")).toBeInTheDocument();\n  \n  const markDots = container.querySelectorAll(\".slider-mark-dot\");\n  expect(markDots).toHaveLength(3);\n});\n\ntest(\"calls onChangeCommitted when dragging ends\", async () => {\n  const user = userEvent.setup();\n  const onChangeCommitted = vi.fn();\n  render(<Slider defaultValue={50} onChangeCommitted={onChangeCommitted} />);\n  \n  const slider = screen.getByRole(\"slider\");\n  await user.pointer([\n    { target: slider, keys: \"[MouseLeft>]\" },\n    { keys: \"[/MouseLeft]\" },\n  ]);\n  \n  expect(onChangeCommitted).toHaveBeenCalled();\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface SliderProps extends Omit<React.HTMLAttributes<HTMLDivElement>, \"onChange\"> {\n  value?: number | number[];\n  defaultValue?: number | number[];\n  min?: number;\n  max?: number;\n  step?: number;\n  range?: boolean;\n  disabled?: boolean;\n  vertical?: boolean;\n  showMarks?: boolean;\n  marks?: Record<number, string | React.ReactNode>;\n  showTooltip?: boolean;\n  formatTooltip?: (value: number) => string;\n  onChange?: (value: number | number[]) => void;\n  onChangeCommitted?: (value: number | number[]) => void;\n  size?: \"sm\" | \"md\" | \"lg\";\n  variant?: \"default\" | \"primary\" | \"secondary\";\n}\n\nconst classesBySize: Record<NonNullable<SliderProps[\"size\"]>, string> = {\n  sm: \"slider-sm\",\n  md: \"slider-md\",\n  lg: \"slider-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<SliderProps[\"variant\"]>, string> = {\n  default: \"slider-default\",\n  primary: \"slider-primary\",\n  secondary: \"slider-secondary\",\n};\n\nexport const Slider = React.forwardRef<HTMLDivElement, SliderProps>(\n  ({\n    value: controlledValue,\n    defaultValue = 0,\n    min = 0,\n    max = 100,\n    step = 1,\n    range = false,\n    disabled = false,\n    vertical = false,\n    showMarks = false,\n    marks,\n    showTooltip = false,\n    formatTooltip = (val) => val.toString(),\n    onChange,\n    onChangeCommitted,\n    size = \"md\",\n    variant = \"default\",\n    className,\n    ...rest\n  }, ref) => {\n    const [internalValue, setInternalValue] = React.useState<number | number[]>(n      range ? (Array.isArray(defaultValue) ? defaultValue : [min, defaultValue as number]) : (defaultValue as number)\n    );\n    const [isDragging, setIsDragging] = React.useState(false);\n    const [activeThumb, setActiveThumb] = React.useState<number | null>(null);\n    \n    const sliderRef = React.useRef<HTMLDivElement>(null);\n    const combinedRef = React.useMemo(() => ref || sliderRef, [ref]);\n\n    const isControlled = controlledValue !== undefined;\n    const value = isControlled ? controlledValue : internalValue;\n\n    const classes = `slider ${vertical ? \"slider-vertical\" : \"slider-horizontal\"} ${\n      classesBySize[size]\n    } ${classesByVariant[variant]} ${disabled ? \"slider-disabled\" : \"\"} ${className || \"\"}`.trim();\n\n    const normalizeValue = (val: number) => {\n      return Math.min(Math.max(val, min), max);\n    };\n\n    const getPercentage = (val: number) => {\n      return ((val - min) / (max - min)) * 100;\n    };\n\n    const getValueFromPosition = (clientX: number, clientY: number) => {\n      if (!combinedRef || !(\"current\" in combinedRef) || !combinedRef.current) return min;\n      \n      const rect = combinedRef.current.getBoundingClientRect();\n      const percentage = vertical\n        ? (rect.bottom - clientY) / rect.height\n        : (clientX - rect.left) / rect.width;\n      \n      const rawValue = min + percentage * (max - min);\n      const steppedValue = Math.round(rawValue / step) * step;\n      return normalizeValue(steppedValue);\n    };\n\n    const updateValue = (newValue: number | number[]) => {\n      if (onChange) {\n        onChange(newValue);\n      }\n      if (!isControlled) {\n        setInternalValue(newValue);\n      }\n    };\n\n    const handleMouseDown = (event: React.MouseEvent, thumbIndex?: number) => {\n      if (disabled) return;\n      \n      event.preventDefault();\n      setIsDragging(true);\n      \n      if (range && Array.isArray(value)) {\n        if (thumbIndex !== undefined) {\n          setActiveThumb(thumbIndex);\n        } else {\n          // Determine which thumb is closer\n          const newValue = getValueFromPosition(event.clientX, event.clientY);\n          const distances = value.map(val => Math.abs(val - newValue));\n          const closestIndex = distances.indexOf(Math.min(...distances));\n          setActiveThumb(closestIndex);\n        }\n      } else {\n        const newValue = getValueFromPosition(event.clientX, event.clientY);\n        updateValue(newValue);\n      }\n    };\n\n    const handleMouseMove = React.useCallback((event: MouseEvent) => {\n      if (!isDragging || disabled) return;\n      \n      const newValue = getValueFromPosition(event.clientX, event.clientY);\n      \n      if (range && Array.isArray(value) && activeThumb !== null) {\n        const newRange = [...value];\n        newRange[activeThumb] = newValue;\n        // Ensure min <= max for range\n        if (newRange[0] > newRange[1]) {\n          newRange.reverse();\n          setActiveThumb(activeThumb === 0 ? 1 : 0);\n        }\n        updateValue(newRange);\n      } else if (!range) {\n        updateValue(newValue);\n      }\n    }, [isDragging, disabled, range, value, activeThumb, getValueFromPosition, updateValue]);\n\n    const handleMouseUp = React.useCallback(() => {\n      if (isDragging) {\n        setIsDragging(false);\n        setActiveThumb(null);\n        if (onChangeCommitted) {\n          onChangeCommitted(value);\n        }\n      }\n    }, [isDragging, onChangeCommitted, value]);\n\n    React.useEffect(() => {\n      if (isDragging) {\n        document.addEventListener(\"mousemove\", handleMouseMove);\n        document.addEventListener(\"mouseup\", handleMouseUp);\n        \n        return () => {\n          document.removeEventListener(\"mousemove\", handleMouseMove);\n          document.removeEventListener(\"mouseup\", handleMouseUp);\n        };\n      }\n    }, [isDragging, handleMouseMove, handleMouseUp]);\n\n    const handleKeyDown = (event: React.KeyboardEvent, thumbIndex = 0) => {\n      if (disabled) return;\n      \n      const isRange = range && Array.isArray(value);\n      const currentValue = isRange ? value[thumbIndex] : (value as number);\n      let newValue = currentValue;\n      \n      switch (event.key) {\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n          event.preventDefault();\n          newValue = Math.min(currentValue + step, max);\n          break;\n        case \"ArrowLeft\":\n        case \"ArrowDown\":\n          event.preventDefault();\n          newValue = Math.max(currentValue - step, min);\n          break;\n        case \"Home\":\n          event.preventDefault();\n          newValue = min;\n          break;\n        case \"End\":\n          event.preventDefault();\n          newValue = max;\n          break;\n        case \"PageUp\":\n          event.preventDefault();\n          newValue = Math.min(currentValue + step * 10, max);\n          break;\n        case \"PageDown\":\n          event.preventDefault();\n          newValue = Math.max(currentValue - step * 10, min);\n          break;\n        default:\n          return;\n      }\n      \n      if (isRange) {\n        const newRange = [...value];\n        newRange[thumbIndex] = newValue;\n        updateValue(newRange);\n      } else {\n        updateValue(newValue);\n      }\n    };\n\n    const renderThumb = (val: number, index = 0) => (\n      <div\n        key={index}\n        className={`slider-thumb ${activeThumb === index ? \"slider-thumb-active\" : \"\"}`}\n        style={{\n          [vertical ? \"bottom\" : \"left\"]: `${getPercentage(val)}%`,\n        }}\n        onMouseDown={(e) => handleMouseDown(e, index)}\n        onKeyDown={(e) => handleKeyDown(e, index)}\n        tabIndex={disabled ? -1 : 0}\n        role=\"slider\"\n        aria-valuemin={min}\n        aria-valuemax={max}\n        aria-valuenow={val}\n        aria-orientation={vertical ? \"vertical\" : \"horizontal\"}\n        aria-disabled={disabled}\n      >\n        {showTooltip && (\n          <div className=\"slider-tooltip\">\n            {formatTooltip(val)}\n          </div>\n        )}\n      </div>\n    );\n\n    const renderMarks = () => {\n      if (!showMarks && !marks) return null;\n      \n      const markValues = marks ? Object.keys(marks).map(Number) : [];\n      const defaultMarks = !marks && showMarks \n        ? Array.from({ length: Math.floor((max - min) / step) + 1 }, (_, i) => min + i * step)\n        : [];\n      \n      const allMarks = marks ? markValues : defaultMarks;\n      \n      return allMarks.map(markValue => (\n        <div\n          key={markValue}\n          className=\"slider-mark\"\n          style={{\n            [vertical ? \"bottom\" : \"left\"]: `${getPercentage(markValue)}%`,\n          }}\n        >\n          <div className=\"slider-mark-dot\" />\n          {marks && marks[markValue] && (\n            <div className=\"slider-mark-label\">\n              {marks[markValue]}\n            </div>\n          )}\n        </div>\n      ));\n    };\n\n    const getTrackStyle = () => {\n      if (range && Array.isArray(value)) {\n        const [start, end] = value.sort((a, b) => a - b);\n        return {\n          [vertical ? \"bottom\" : \"left\"]: `${getPercentage(start)}%`,\n          [vertical ? \"height\" : \"width\"]: `${getPercentage(end) - getPercentage(start)}%`,\n        };\n      } else {\n        return {\n          [vertical ? \"height\" : \"width\"]: `${getPercentage(value as number)}%`,\n        };\n      }\n    };\n\n    return (\n      <div\n        {...rest}\n        ref={combinedRef}\n        className={classes}\n        onMouseDown={handleMouseDown}\n      >\n        <div className=\"slider-rail\" />\n        <div className=\"slider-track\" style={getTrackStyle()} />\n        {renderMarks()}\n        {range && Array.isArray(value)\n          ? value.map((val, index) => renderThumb(val, index))\n          : renderThumb(value as number)\n        }\n      </div>\n    );\n  }\n);\nSlider.displayName = \"Slider\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Slider } from \"../Slider\";\n\ntest(\"renders slider with default value\", () => {\n  render(<Slider defaultValue={50} />);\n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-valuenow\", \"50\");\n});\n\ntest(\"renders range slider with two thumbs\", () => {\n  render(<Slider range defaultValue={[25, 75]} />);\n  const sliders = screen.getAllByRole(\"slider\");\n  expect(sliders).toHaveLength(2);\n  expect(sliders[0]).toHaveAttribute(\"aria-valuenow\", \"25\");\n  expect(sliders[1]).toHaveAttribute(\"aria-valuenow\", \"75\");\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Slider defaultValue={50} onChange={onChange} />);\n  \n  const slider = screen.getByRole(\"slider\");\n  slider.focus();\n  \n  await user.keyboard(\"{ArrowRight}\");\n  expect(onChange).toHaveBeenCalledWith(51);\n  \n  await user.keyboard(\"{ArrowLeft}\");\n  expect(onChange).toHaveBeenCalledWith(49);\n});\n\ntest(\"handles home and end keys\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Slider defaultValue={50} min={0} max={100} onChange={onChange} />);\n  \n  const slider = screen.getByRole(\"slider\");\n  slider.focus();\n  \n  await user.keyboard(\"{Home}\");\n  expect(onChange).toHaveBeenCalledWith(0);\n  \n  await user.keyboard(\"{End}\");\n  expect(onChange).toHaveBeenCalledWith(100);\n});\n\ntest(\"respects min and max values\", () => {\n  render(<Slider defaultValue={50} min={10} max={90} />);\n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-valuemin\", \"10\");\n  expect(slider).toHaveAttribute(\"aria-valuemax\", \"90\");\n});\n\ntest(\"works in controlled mode\", () => {\n  const onChange = vi.fn();\n  render(<Slider value={75} onChange={onChange} />);\n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-valuenow\", \"75\");\n});\n\ntest(\"shows tooltip when enabled\", () => {\n  render(<Slider defaultValue={50} showTooltip />);\n  expect(screen.getByText(\"50\")).toBeInTheDocument();\n});\n\ntest(\"formats tooltip with custom formatter\", () => {\n  const formatTooltip = (value: number) => `${value}%`;\n  render(<Slider defaultValue={50} showTooltip formatTooltip={formatTooltip} />);\n  expect(screen.getByText(\"50%\")).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<Slider size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"slider-lg\");\n});\n\ntest(\"applies variant classes\", () => {\n  const { container } = render(<Slider variant=\"primary\" />);\n  expect(container.firstChild).toHaveClass(\"slider-primary\");\n});\n\ntest(\"applies vertical orientation\", () => {\n  const { container } = render(<Slider vertical />);\n  expect(container.firstChild).toHaveClass(\"slider-vertical\");\n  \n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-orientation\", \"vertical\");\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  render(<Slider disabled onChange={onChange} />);\n  \n  const slider = screen.getByRole(\"slider\");\n  expect(slider).toHaveAttribute(\"aria-disabled\", \"true\");\n  expect(slider).toHaveAttribute(\"tabindex\", \"-1\");\n  \n  slider.focus();\n  await user.keyboard(\"{ArrowRight}\");\n  expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"shows marks when enabled\", () => {\n  const marks = { 0: \"Min\", 50: \"Mid\", 100: \"Max\" };\n  const { container } = render(<Slider marks={marks} />);\n  \n  expect(screen.getByText(\"Min\")).toBeInTheDocument();\n  expect(screen.getByText(\"Mid\")).toBeInTheDocument();\n  expect(screen.getByText(\"Max\")).toBeInTheDocument();\n  \n  const markDots = container.querySelectorAll(\".slider-mark-dot\");\n  expect(markDots).toHaveLength(3);\n});\n\ntest(\"calls onChangeCommitted when dragging ends\", async () => {\n  const user = userEvent.setup();\n  const onChangeCommitted = vi.fn();\n  render(<Slider defaultValue={50} onChangeCommitted={onChangeCommitted} />);\n  \n  const slider = screen.getByRole(\"slider\");\n  await user.pointer([\n    { target: slider, keys: \"[MouseLeft>]\" },\n    { keys: \"[/MouseLeft]\" },\n  ]);\n  \n  expect(onChangeCommitted).toHaveBeenCalled();\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\ntype SpinnerSize = \"sm\" | \"md\" | \"lg\";\n\nexport interface SpinnerProps extends React.HTMLAttributes<HTMLDivElement> {\n    size?: SpinnerSize;\n    label?: string;\n}\n\nconst classesBySize: Record<SpinnerSize, string> = {\n    sm: \"spinner spinner-sm\",\n    md: \"spinner spinner-md\",\n    lg: \"spinner spinner-lg\",\n};\n\nexport const Spinner = React.forwardRef<HTMLDivElement, SpinnerProps>(\n    ({ size = \"md\", label = \"Loading\", className, ...rest }, ref) => {\n        const classes = `${classesBySize[size]} ${className || \"\"}`.trim();\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                role=\"status\"\n                aria-label={label}\n            >\n                <div className=\"spinner-circle\" />\n                <span className=\"sr-only\">{label}</span>\n            </div>\n        );\n    }\n);\nSpinner.displayName = \"Spinner\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Spinner } from \"../Spinner\";\n\ntest(\"renders with default label\", () => {\n    render(<Spinner />);\n    expect(screen.getByRole(\"status\", { name: /loading/i })).toBeInTheDocument();\n});\n\ntest(\"renders with custom label\", () => {\n    render(<Spinner label=\"Saving...\" />);\n    expect(screen.getByRole(\"status\", { name: /saving/i })).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n    render(<Spinner size=\"lg\" />);\n    expect(screen.getByRole(\"status\")).toHaveClass(\"spinner\", \"spinner-lg\");\n});\n\ntest(\"forwards additional props\", () => {\n    render(<Spinner data-testid=\"custom-spinner\" />);\n    expect(screen.getByTestId(\"custom-spinner\")).toBeInTheDocument();\n});\n\ntest(\"includes screen reader text\", () => {\n    render(<Spinner label=\"Processing\" />);\n    expect(screen.getByText(\"Processing\")).toHaveClass(\"sr-only\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\ntype SpinnerSize = \"sm\" | \"md\" | \"lg\";\n\nexport interface SpinnerProps extends React.HTMLAttributes<HTMLDivElement> {\n    size?: SpinnerSize;\n    label?: string;\n}\n\nconst classesBySize: Record<SpinnerSize, string> = {\n    sm: \"spinner spinner-sm\",\n    md: \"spinner spinner-md\",\n    lg: \"spinner spinner-lg\",\n};\n\nexport const Spinner = React.forwardRef<HTMLDivElement, SpinnerProps>(\n    ({ size = \"md\", label = \"Loading\", className, ...rest }, ref) => {\n        const classes = `${classesBySize[size]} ${className || \"\"}`.trim();\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                role=\"status\"\n                aria-label={label}\n            >\n                <div className=\"spinner-circle\" />\n                <span className=\"sr-only\">{label}</span>\n            </div>\n        );\n    }\n);\nSpinner.displayName = \"Spinner\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Spinner } from \"../Spinner\";\n\ntest(\"renders with default label\", () => {\n    render(<Spinner />);\n    expect(screen.getByRole(\"status\", { name: /loading/i })).toBeInTheDocument();\n});\n\ntest(\"renders with custom label\", () => {\n    render(<Spinner label=\"Saving...\" />);\n    expect(screen.getByRole(\"status\", { name: /saving/i })).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n    render(<Spinner size=\"lg\" />);\n    expect(screen.getByRole(\"status\")).toHaveClass(\"spinner\", \"spinner-lg\");\n});\n\ntest(\"forwards additional props\", () => {\n    render(<Spinner data-testid=\"custom-spinner\" />);\n    expect(screen.getByTestId(\"custom-spinner\")).toBeInTheDocument();\n});\n\ntest(\"includes screen reader text\", () => {\n    render(<Spinner label=\"Processing\" />);\n    expect(screen.getByText(\"Processing\")).toHaveClass(\"sr-only\");\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\ntype SpinnerSize = \"sm\" | \"md\" | \"lg\";\n\nexport interface SpinnerProps extends React.HTMLAttributes<HTMLDivElement> {\n    size?: SpinnerSize;\n    label?: string;\n}\n\nconst classesBySize: Record<SpinnerSize, string> = {\n    sm: \"spinner spinner-sm\",\n    md: \"spinner spinner-md\",\n    lg: \"spinner spinner-lg\",\n};\n\nexport const Spinner = React.forwardRef<HTMLDivElement, SpinnerProps>(\n    ({ size = \"md\", label = \"Loading\", className, ...rest }, ref) => {\n        const classes = `${classesBySize[size]} ${className || \"\"}`.trim();\n\n        return (\n            <div\n                {...rest}\n                ref={ref}\n                className={classes}\n                role=\"status\"\n                aria-label={label}\n            >\n                <div className=\"spinner-circle\" />\n                <span className=\"sr-only\">{label}</span>\n            </div>\n        );\n    }\n);\nSpinner.displayName = \"Spinner\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Spinner } from \"../Spinner\";\n\ntest(\"renders with default label\", () => {\n    render(<Spinner />);\n    expect(screen.getByRole(\"status\", { name: /loading/i })).toBeInTheDocument();\n});\n\ntest(\"renders with custom label\", () => {\n    render(<Spinner label=\"Saving...\" />);\n    expect(screen.getByRole(\"status\", { name: /saving/i })).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n    render(<Spinner size=\"lg\" />);\n    expect(screen.getByRole(\"status\")).toHaveClass(\"spinner\", \"spinner-lg\");\n});\n\ntest(\"forwards additional props\", () => {\n    render(<Spinner data-testid=\"custom-spinner\" />);\n    expect(screen.getByTestId(\"custom-spinner\")).toBeInTheDocument();\n});\n\ntest(\"includes screen reader text\", () => {\n    render(<Spinner label=\"Processing\" />);\n    expect(screen.getByText(\"Processing\")).toHaveClass(\"sr-only\");\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface StepperStep {\n    label: string;\n    description?: string;\n    completed?: boolean;\n    error?: boolean;\n    optional?: boolean;\n}\n\nexport interface StepperProps extends React.HTMLAttributes<HTMLDivElement> {\n    steps: StepperStep[];\n    activeStep: number;\n    orientation?: \"horizontal\" | \"vertical\";\n    variant?: \"default\" | \"dots\" | \"progress\";\n}\n\nconst classesByOrientation: Record<NonNullable<StepperProps[\"orientation\"]>, string> = {\n    horizontal: \"stepper stepper-horizontal\",\n    vertical: \"stepper stepper-vertical\",\n};\n\nconst classesByVariant: Record<NonNullable<StepperProps[\"variant\"]>, string> = {\n    default: \"stepper-default\",\n    dots: \"stepper-dots\",\n    progress: \"stepper-progress\",\n};\n\nexport const Stepper = React.forwardRef<HTMLDivElement, StepperProps>(\n    ({\n        steps,\n        activeStep,\n        orientation = \"horizontal\",\n        variant = \"default\",\n        className,\n        ...rest\n    }, ref) => {\n        const classes = `${classesByOrientation[orientation]} ${classesByVariant[variant]} ${className || \"\"}`.trim();\n\n        const getStepStatus = (index: number, step: StepperStep) => {\n            if (step.error) return \"error\";\n            if (step.completed || index < activeStep) return \"completed\";\n            if (index === activeStep) return \"active\";\n            return \"inactive\";\n        };\n\n        return (\n            <div {...rest} ref={ref} className={classes} role=\"list\">\n                {steps.map((step, index) => {\n                    const status = getStepStatus(index, step);\n                    const isLast = index === steps.length - 1;\n\n                    return (\n                        <div key={index} className=\"stepper-step\" role=\"listitem\">\n                            <div className={`step-indicator step-${status}`}>\n                                {variant === \"dots\" ? (\n                                    <div className=\"step-dot\" />\n                                ) : status === \"completed\" ? (\n                                    <span className=\"step-icon\">✓</span>\n                                ) : status === \"error\" ? (\n                                    <span className=\"step-icon\">!</span>\n                                ) : (\n                                    <span className=\"step-number\">{index + 1}</span>\n                                )}\n                            </div>\n\n                            <div className=\"step-content\">\n                                <div className=\"step-label\">\n                                    {step.label}\n                                    {step.optional && (\n                                        <span className=\"step-optional\">(Optional)</span>\n                                    )}\n                                </div>\n                                {step.description && (\n                                    <div className=\"step-description\">{step.description}</div>\n                                )}\n                            </div>\n\n                            {!isLast && orientation === \"horizontal\" && (\n                                <div className={`step-connector step-connector-${status === \"completed\" ? \"completed\" : \"inactive\"}`} />\n                            )}\n\n                            {!isLast && orientation === \"vertical\" && (\n                                <div className={`step-connector-vertical step-connector-${status === \"completed\" ? \"completed\" : \"inactive\"}`} />\n                            )}\n                        </div>\n                    );\n                })}\n            </div>\n        );\n    }\n);\nStepper.displayName = \"Stepper\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Stepper } from \"../Stepper\";\n\nconst mockSteps = [\n    { label: \"Step 1\", description: \"Description 1\" },\n    { label: \"Step 2\", description: \"Description 2\", optional: true },\n    { label: \"Step 3\", description: \"Description 3\" },\n    { label: \"Step 4\", description: \"Description 4\", error: true },\n    { label: \"Step 5\", description: \"Description 5\", completed: true },\n];\n\ntest(\"renders all step labels and descriptions\", () => {\n    render(<Stepper steps={mockSteps} activeStep={0} />);\n    expect(screen.getByText(\"Step 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"Description 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"Step 5\")).toBeInTheDocument();\n});\n\ntest(\"marks active step correctly\", () => {\n    render(<Stepper steps={mockSteps} activeStep={1} />);\n    const activeStepIndicator = screen.getByText(\"2\").parentElement;\n    expect(activeStepIndicator).toHaveClass(\"step-active\");\n});\n\ntest(\"marks completed steps correctly\", () => {\n    // A step before the active step is implicitly completed\n    render(<Stepper steps={mockSteps} activeStep={2} />);\n    const completedStepIndicator = screen.getAllByText(\"✓\").find(el => el.parentElement?.classList.contains('step-completed'));\n    expect(completedStepIndicator).toBeInTheDocument();\n    \n    // A step explicitly marked as completed\n    const explicitlyCompletedStep = screen.getByText(\"Step 5\").closest(\".stepper-step\")?.querySelector(\".step-indicator\");\n    expect(explicitlyCompletedStep).toHaveClass(\"step-completed\");\n});\n\ntest(\"marks error step correctly\", () => {\n    render(<Stepper steps={mockSteps} activeStep={0} />);\n    const errorStepIndicator = screen.getByText(\"!\").parentElement;\n    expect(errorStepIndicator).toHaveClass(\"step-error\");\n});\n\ntest(\"shows optional label\", () => {\n    render(<Stepper steps={mockSteps} activeStep={0} />);\n    expect(screen.getByText(\"(Optional)\")).toBeInTheDocument();\n});\n\ntest(\"applies orientation and variant classes\", () => {\n    const { container } = render(\n        <Stepper\n            steps={mockSteps}\n            activeStep={0}\n            orientation=\"vertical\"\n            variant=\"dots\"\n        />\n    );\n    const stepperElement = container.firstChild;\n    expect(stepperElement).toHaveClass(\"stepper-vertical\", \"stepper-dots\");\n});\n\ntest(\"renders checkmark for completed steps in default variant\", () => {\n    render(<Stepper steps={mockSteps} activeStep={2} />); // Step 1 and 2 are completed\n    expect(screen.getAllByText(\"✓\").length).toBeGreaterThanOrEqual(1);\n});\n\ntest(\"renders dot for steps in dots variant\", () => {\n    const { container } = render(<Stepper steps={mockSteps} activeStep={1} variant=\"dots\" />);\n    expect(container.querySelectorAll(\".step-dot\").length).toBe(mockSteps.length);\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface StepperStep {\n    label: string;\n    description?: string;\n    completed?: boolean;\n    error?: boolean;\n    optional?: boolean;\n}\n\nexport interface StepperProps extends React.HTMLAttributes<HTMLDivElement> {\n    steps: StepperStep[];\n    activeStep: number;\n    orientation?: \"horizontal\" | \"vertical\";\n    variant?: \"default\" | \"dots\" | \"progress\";\n}\n\nconst classesByOrientation: Record<NonNullable<StepperProps[\"orientation\"]>, string> = {\n    horizontal: \"stepper stepper-horizontal\",\n    vertical: \"stepper stepper-vertical\",\n};\n\nconst classesByVariant: Record<NonNullable<StepperProps[\"variant\"]>, string> = {\n    default: \"stepper-default\",\n    dots: \"stepper-dots\",\n    progress: \"stepper-progress\",\n};\n\nexport const Stepper = React.forwardRef<HTMLDivElement, StepperProps>(\n    ({\n        steps,\n        activeStep,\n        orientation = \"horizontal\",\n        variant = \"default\",\n        className,\n        ...rest\n    }, ref) => {\n        const classes = `${classesByOrientation[orientation]} ${classesByVariant[variant]} ${className || \"\"}`.trim();\n\n        const getStepStatus = (index: number, step: StepperStep) => {\n            if (step.error) return \"error\";\n            if (step.completed || index < activeStep) return \"completed\";\n            if (index === activeStep) return \"active\";\n            return \"inactive\";\n        };\n\n        return (\n            <div {...rest} ref={ref} className={classes} role=\"list\">\n                {steps.map((step, index) => {\n                    const status = getStepStatus(index, step);\n                    const isLast = index === steps.length - 1;\n\n                    return (\n                        <div key={index} className=\"stepper-step\" role=\"listitem\">\n                            <div className={`step-indicator step-${status}`}>\n                                {variant === \"dots\" ? (\n                                    <div className=\"step-dot\" />\n                                ) : status === \"completed\" ? (\n                                    <span className=\"step-icon\">✓</span>\n                                ) : status === \"error\" ? (\n                                    <span className=\"step-icon\">!</span>\n                                ) : (\n                                    <span className=\"step-number\">{index + 1}</span>\n                                )}\n                            </div>\n\n                            <div className=\"step-content\">\n                                <div className=\"step-label\">\n                                    {step.label}\n                                    {step.optional && (\n                                        <span className=\"step-optional\">(Optional)</span>\n                                    )}\n                                </div>\n                                {step.description && (\n                                    <div className=\"step-description\">{step.description}</div>\n                                )}\n                            </div>\n\n                            {!isLast && orientation === \"horizontal\" && (\n                                <div className={`step-connector step-connector-${status === \"completed\" ? \"completed\" : \"inactive\"}`} />\n                            )}\n\n                            {!isLast && orientation === \"vertical\" && (\n                                <div className={`step-connector-vertical step-connector-${status === \"completed\" ? \"completed\" : \"inactive\"}`} />\n                            )}\n                        </div>\n                    );\n                })}\n            </div>\n        );\n    }\n);\nStepper.displayName = \"Stepper\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Stepper } from \"../Stepper\";\n\nconst mockSteps = [\n    { label: \"Step 1\", description: \"Description 1\" },\n    { label: \"Step 2\", description: \"Description 2\", optional: true },\n    { label: \"Step 3\", description: \"Description 3\" },\n    { label: \"Step 4\", description: \"Description 4\", error: true },\n    { label: \"Step 5\", description: \"Description 5\", completed: true },\n];\n\ntest(\"renders all step labels and descriptions\", () => {\n    render(<Stepper steps={mockSteps} activeStep={0} />);\n    expect(screen.getByText(\"Step 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"Description 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"Step 5\")).toBeInTheDocument();\n});\n\ntest(\"marks active step correctly\", () => {\n    render(<Stepper steps={mockSteps} activeStep={1} />);\n    const activeStepIndicator = screen.getByText(\"2\").parentElement;\n    expect(activeStepIndicator).toHaveClass(\"step-active\");\n});\n\ntest(\"marks completed steps correctly\", () => {\n    // A step before the active step is implicitly completed\n    render(<Stepper steps={mockSteps} activeStep={2} />);\n    const completedStepIndicator = screen.getAllByText(\"✓\").find(el => el.parentElement?.classList.contains('step-completed'));\n    expect(completedStepIndicator).toBeInTheDocument();\n    \n    // A step explicitly marked as completed\n    const explicitlyCompletedStep = screen.getByText(\"Step 5\").closest(\".stepper-step\")?.querySelector(\".step-indicator\");\n    expect(explicitlyCompletedStep).toHaveClass(\"step-completed\");\n});\n\ntest(\"marks error step correctly\", () => {\n    render(<Stepper steps={mockSteps} activeStep={0} />);\n    const errorStepIndicator = screen.getByText(\"!\").parentElement;\n    expect(errorStepIndicator).toHaveClass(\"step-error\");\n});\n\ntest(\"shows optional label\", () => {\n    render(<Stepper steps={mockSteps} activeStep={0} />);\n    expect(screen.getByText(\"(Optional)\")).toBeInTheDocument();\n});\n\ntest(\"applies orientation and variant classes\", () => {\n    const { container } = render(\n        <Stepper\n            steps={mockSteps}\n            activeStep={0}\n            orientation=\"vertical\"\n            variant=\"dots\"\n        />\n    );\n    const stepperElement = container.firstChild;\n    expect(stepperElement).toHaveClass(\"stepper-vertical\", \"stepper-dots\");\n});\n\ntest(\"renders checkmark for completed steps in default variant\", () => {\n    render(<Stepper steps={mockSteps} activeStep={2} />); // Step 1 and 2 are completed\n    expect(screen.getAllByText(\"✓\").length).toBeGreaterThanOrEqual(1);\n});\n\ntest(\"renders dot for steps in dots variant\", () => {\n    const { container } = render(<Stepper steps={mockSteps} activeStep={1} variant=\"dots\" />);\n    expect(container.querySelectorAll(\".step-dot\").length).toBe(mockSteps.length);\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface StepperStep {\n    label: string;\n    description?: string;\n    completed?: boolean;\n    error?: boolean;\n    optional?: boolean;\n}\n\nexport interface StepperProps extends React.HTMLAttributes<HTMLDivElement> {\n    steps: StepperStep[];\n    activeStep: number;\n    orientation?: \"horizontal\" | \"vertical\";\n    variant?: \"default\" | \"dots\" | \"progress\";\n}\n\nconst classesByOrientation: Record<NonNullable<StepperProps[\"orientation\"]>, string> = {\n    horizontal: \"stepper stepper-horizontal\",\n    vertical: \"stepper stepper-vertical\",\n};\n\nconst classesByVariant: Record<NonNullable<StepperProps[\"variant\"]>, string> = {\n    default: \"stepper-default\",\n    dots: \"stepper-dots\",\n    progress: \"stepper-progress\",\n};\n\nexport const Stepper = React.forwardRef<HTMLDivElement, StepperProps>(\n    ({\n        steps,\n        activeStep,\n        orientation = \"horizontal\",\n        variant = \"default\",\n        className,\n        ...rest\n    }, ref) => {\n        const classes = `${classesByOrientation[orientation]} ${classesByVariant[variant]} ${className || \"\"}`.trim();\n\n        const getStepStatus = (index: number, step: StepperStep) => {\n            if (step.error) return \"error\";\n            if (step.completed || index < activeStep) return \"completed\";\n            if (index === activeStep) return \"active\";\n            return \"inactive\";\n        };\n\n        return (\n            <div {...rest} ref={ref} className={classes} role=\"list\">\n                {steps.map((step, index) => {\n                    const status = getStepStatus(index, step);\n                    const isLast = index === steps.length - 1;\n\n                    return (\n                        <div key={index} className=\"stepper-step\" role=\"listitem\">\n                            <div className={`step-indicator step-${status}`}>\n                                {variant === \"dots\" ? (\n                                    <div className=\"step-dot\" />\n                                ) : status === \"completed\" ? (\n                                    <span className=\"step-icon\">✓</span>\n                                ) : status === \"error\" ? (\n                                    <span className=\"step-icon\">!</span>\n                                ) : (\n                                    <span className=\"step-number\">{index + 1}</span>\n                                )}\n                            </div>\n\n                            <div className=\"step-content\">\n                                <div className=\"step-label\">\n                                    {step.label}\n                                    {step.optional && (\n                                        <span className=\"step-optional\">(Optional)</span>\n                                    )}\n                                </div>\n                                {step.description && (\n                                    <div className=\"step-description\">{step.description}</div>\n                                )}\n                            </div>\n\n                            {!isLast && orientation === \"horizontal\" && (\n                                <div className={`step-connector step-connector-${status === \"completed\" ? \"completed\" : \"inactive\"}`} />\n                            )}\n\n                            {!isLast && orientation === \"vertical\" && (\n                                <div className={`step-connector-vertical step-connector-${status === \"completed\" ? \"completed\" : \"inactive\"}`} />\n                            )}\n                        </div>\n                    );\n                })}\n            </div>\n        );\n    }\n);\nStepper.displayName = \"Stepper\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Stepper } from \"../Stepper\";\n\nconst mockSteps = [\n    { label: \"Step 1\", description: \"Description 1\" },\n    { label: \"Step 2\", description: \"Description 2\", optional: true },\n    { label: \"Step 3\", description: \"Description 3\" },\n    { label: \"Step 4\", description: \"Description 4\", error: true },\n    { label: \"Step 5\", description: \"Description 5\", completed: true },\n];\n\ntest(\"renders all step labels and descriptions\", () => {\n    render(<Stepper steps={mockSteps} activeStep={0} />);\n    expect(screen.getByText(\"Step 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"Description 1\")).toBeInTheDocument();\n    expect(screen.getByText(\"Step 5\")).toBeInTheDocument();\n});\n\ntest(\"marks active step correctly\", () => {\n    render(<Stepper steps={mockSteps} activeStep={1} />);\n    const activeStepIndicator = screen.getByText(\"2\").parentElement;\n    expect(activeStepIndicator).toHaveClass(\"step-active\");\n});\n\ntest(\"marks completed steps correctly\", () => {\n    // A step before the active step is implicitly completed\n    render(<Stepper steps={mockSteps} activeStep={2} />);\n    const completedStepIndicator = screen.getAllByText(\"✓\").find(el => el.parentElement?.classList.contains('step-completed'));\n    expect(completedStepIndicator).toBeInTheDocument();\n    \n    // A step explicitly marked as completed\n    const explicitlyCompletedStep = screen.getByText(\"Step 5\").closest(\".stepper-step\")?.querySelector(\".step-indicator\");\n    expect(explicitlyCompletedStep).toHaveClass(\"step-completed\");\n});\n\ntest(\"marks error step correctly\", () => {\n    render(<Stepper steps={mockSteps} activeStep={0} />);\n    const errorStepIndicator = screen.getByText(\"!\").parentElement;\n    expect(errorStepIndicator).toHaveClass(\"step-error\");\n});\n\ntest(\"shows optional label\", () => {\n    render(<Stepper steps={mockSteps} activeStep={0} />);\n    expect(screen.getByText(\"(Optional)\")).toBeInTheDocument();\n});\n\ntest(\"applies orientation and variant classes\", () => {\n    const { container } = render(\n        <Stepper\n            steps={mockSteps}\n            activeStep={0}\n            orientation=\"vertical\"\n            variant=\"dots\"\n        />\n    );\n    const stepperElement = container.firstChild;\n    expect(stepperElement).toHaveClass(\"stepper-vertical\", \"stepper-dots\");\n});\n\ntest(\"renders checkmark for completed steps in default variant\", () => {\n    render(<Stepper steps={mockSteps} activeStep={2} />); // Step 1 and 2 are completed\n    expect(screen.getAllByText(\"✓\").length).toBeGreaterThanOrEqual(1);\n});\n\ntest(\"renders dot for steps in dots variant\", () => {\n    const { container } = render(<Stepper steps={mockSteps} activeStep={1} variant=\"dots\" />);\n    expect(container.querySelectorAll(\".step-dot\").length).toBe(mockSteps.length);\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface TableColumn<T = any> {\n  key: string;\n  title: string;\n  dataIndex?: keyof T;\n  render?: (value: any, record: T, index: number) => React.ReactNode;\n  width?: string | number;\n  sortable?: boolean;\n  align?: \"left\" | \"center\" | \"right\";\n  fixed?: \"left\" | \"right\";\n}\n\nexport interface TableProps<T = any> extends React.HTMLAttributes<HTMLDivElement> {\n  columns: TableColumn<T>[];\n  data: T[];\n  loading?: boolean;\n  emptyText?: string;\n  variant?: \"default\" | \"striped\" | \"bordered\";\n  size?: \"sm\" | \"md\" | \"lg\";\n  sticky?: boolean;\n  sortBy?: string;\n  sortOrder?: \"asc\" | \"desc\";\n  onSort?: (key: string, order: \"asc\" | \"desc\") => void;\n  rowSelection?: {\n    selectedRowKeys?: string[];\n    onChange?: (selectedKeys: string[], selectedRows: T[]) => void;\n    getCheckboxProps?: (record: T) => { disabled?: boolean };\n  };\n  pagination?: {\n    current: number;\n    pageSize: number;\n    total: number;\n    onChange: (page: number, pageSize: number) => void;\n  };\n  expandable?: {\n    expandedRowKeys?: string[];\n    onExpand?: (expanded: boolean, record: T) => void;\n    expandedRowRender?: (record: T) => React.ReactNode;\n  };\n  rowKey?: string | ((record: T) => string);\n}\n\nconst classesByVariant: Record<NonNullable<TableProps[\"variant\"]>, string> = {\n  default: \"table-default\",\n  striped: \"table-striped\",\n  bordered: \"table-bordered\",\n};\n\nconst classesBySize: Record<NonNullable<TableProps[\"size\"]>, string> = {\n  sm: \"table-sm\",\n  md: \"table-md\",\n  lg: \"table-lg\",\n};\n\nexport const Table = <T extends Record<string, any>>({\n  columns,\n  data,\n  loading = false,\n  emptyText = \"No data\",\n  variant = \"default\",\n  size = \"md\",\n  sticky = false,\n  sortBy,\n  sortOrder,\n  onSort,\n  rowSelection,\n  pagination,\n  expandable,\n  rowKey = \"id\",\n  className,\n  ...rest\n}: TableProps<T>) => {\n  const [internalSortBy, setInternalSortBy] = React.useState<string | undefined>(sortBy);\n  const [internalSortOrder, setInternalSortOrder] = React.useState<\"asc\" | \"desc\">(\"asc\");\n\n  const classes = `table-container ${classesByVariant[variant]} ${classesBySize[size]} ${\n    sticky ? \"table-sticky\" : \"\"\n  } ${className || \"\"}`.trim();\n\n  const getRowKey = (record: T, index: number): string => {\n    if (typeof rowKey === \"function\") {\n      return rowKey(record);\n    }\n    return record[rowKey] || index.toString();\n  };\n\n  const handleSort = (columnKey: string) => {\n    const newOrder = \n      internalSortBy === columnKey && internalSortOrder === \"asc\" ? \"desc\" : \"asc\";\n    \n    setInternalSortBy(columnKey);\n    setInternalSortOrder(newOrder);\n    \n    if (onSort) {\n      onSort(columnKey, newOrder);\n    }\n  };\n\n  const handleRowSelect = (recordKey: string, selected: boolean, record: T) => {\n    if (!rowSelection?.onChange) return;\n    \n    const currentSelected = rowSelection.selectedRowKeys || [];\n    const newSelected = selected\n      ? [...currentSelected, recordKey]\n      : currentSelected.filter(key => key !== recordKey);\n    \n    const selectedRows = data.filter(item => \n      newSelected.includes(getRowKey(item, data.indexOf(item)))\n    );\n    \n    rowSelection.onChange(newSelected, selectedRows);\n  };\n\n  const handleSelectAll = (selected: boolean) => {\n    if (!rowSelection?.onChange) return;\n    \n    const selectableRows = data.filter((record, index) => {\n      const checkboxProps = rowSelection.getCheckboxProps?.(record);\n      return !checkboxProps?.disabled;\n    });\n    \n    const newSelected = selected \n      ? selectableRows.map((record, index) => getRowKey(record, index))\n      : [];\n    \n    rowSelection.onChange(newSelected, selected ? selectableRows : []);\n  };\n\n  const handleExpand = (record: T, expanded: boolean) => {\n    if (expandable?.onExpand) {\n      expandable.onExpand(expanded, record);\n    }\n  };\n\n  const isRowSelected = (record: T, index: number): boolean => {\n    const key = getRowKey(record, index);\n    return rowSelection?.selectedRowKeys?.includes(key) || false;\n  };\n\n  const isRowExpanded = (record: T, index: number): boolean => {\n    const key = getRowKey(record, index);\n    return expandable?.expandedRowKeys?.includes(key) || false;\n  };\n\n  const isAllSelected = (): boolean => {\n    if (!rowSelection?.selectedRowKeys) return false;\n    const selectableRows = data.filter((record) => {\n      const checkboxProps = rowSelection.getCheckboxProps?.(record);\n      return !checkboxProps?.disabled;\n    });\n    return selectableRows.length > 0 && \n           selectableRows.every((record, index) => isRowSelected(record, index));\n  };\n\n  const isIndeterminate = (): boolean => {\n    if (!rowSelection?.selectedRowKeys) return false;\n    const selectedCount = data.filter((record, index) => isRowSelected(record, index)).length;\n    return selectedCount > 0 && selectedCount < data.length;\n  };\n\n  const renderCell = (column: TableColumn<T>, record: T, index: number) => {\n    if (column.render) {\n      return column.render(\n        column.dataIndex ? record[column.dataIndex] : undefined,\n        record,\n        index\n      );\n    }\n    return column.dataIndex ? record[column.dataIndex] : \"\";\n  };\n\n  const getSortIcon = (columnKey: string) => {\n    if (internalSortBy !== columnKey) return \"↕\";\n    return internalSortOrder === \"asc\" ? \"↑\" : \"↓\";\n  };\n\n  return (\n    <div {...rest} className={classes}>\n      {loading && (\n        <div className=\"table-loading\" role=\"status\" aria-label=\"Loading\">\n          Loading...\n        </div>\n      )}\n      \n      <div className=\"table-wrapper\">\n        <table className=\"table\" role=\"table\">\n          <thead className=\"table-header\">\n            <tr>\n              {rowSelection && (\n                <th className=\"table-cell table-selection-cell\">\n                  <input\n                    type=\"checkbox\"\n                    checked={isAllSelected()}\n                    ref={(input) => {\n                      if (input) input.indeterminate = isIndeterminate();\n                    }}\n                    onChange={(e) => handleSelectAll(e.target.checked)}\n                    aria-label=\"Select all rows\"\n                  />\n                </th>\n              )}\n              \n              {expandable && (\n                <th className=\"table-cell table-expand-cell\" />\n              )}\n              \n              {columns.map((column) => (\n                <th\n                  key={column.key}\n                  className={`table-cell table-header-cell ${\n                    column.align ? `table-align-${column.align}` : \"\"\n                  } ${column.sortable ? \"table-sortable\" : \"\"}`}\n                  style={{ width: column.width }}\n                  onClick={column.sortable ? () => handleSort(column.key) : undefined}\n                  role=\"columnheader\"\n                  aria-sort={\n                    column.sortable && internalSortBy === column.key\n                      ? internalSortOrder === \"asc\" ? \"ascending\" : \"descending\"\n                      : undefined\n                  }\n                >\n                  <div className=\"table-header-content\">\n                    {column.title}\n                    {column.sortable && (\n                      <span className=\"table-sort-icon\" aria-hidden=\"true\">\n                        {getSortIcon(column.key)}\n                      </span>\n                    )}\n                  </div>\n                </th>\n              ))}\n            </tr>\n          </thead>\n          \n          <tbody className=\"table-body\">\n            {data.length === 0 ? (\n              <tr>\n                <td\n                  className=\"table-cell table-empty\"\n                  colSpan={\n                    columns.length + \n                    (rowSelection ? 1 : 0) + \n                    (expandable ? 1 : 0)\n                  }\n                >\n                  {emptyText}\n                </td>\n              </tr>\n            ) : (\n              data.map((record, index) => {\n                const key = getRowKey(record, index);\n                const selected = isRowSelected(record, index);\n                const expanded = isRowExpanded(record, index);\n                \n                return (\n                  <React.Fragment key={key}>\n                    <tr className={`table-row ${selected ? \"table-row-selected\" : \"\"}`}>\n                      {rowSelection && (\n                        <td className=\"table-cell table-selection-cell\">\n                          <input\n                            type=\"checkbox\"\n                            checked={selected}\n                            onChange={(e) => handleRowSelect(key, e.target.checked, record)}\n                            disabled={rowSelection.getCheckboxProps?.(record)?.disabled}\n                            aria-label={`Select row ${index + 1}`}\n                          />\n                        </td>\n                      )}\n                      \n                      {expandable && (\n                        <td className=\"table-cell table-expand-cell\">\n                          {expandable.expandedRowRender && (\n                            <button\n                              type=\"button\"\n                              className=\"table-expand-button\"\n                              onClick={() => handleExpand(record, !expanded)}\n                              aria-label={expanded ? \"Collapse row\" : \"Expand row\"}\n                              aria-expanded={expanded}\n                            >\n                              {expanded ? \"−\" : \"+\"}\n                            </button>\n                          )}\n                        </td>\n                      )}\n                      \n                      {columns.map((column) => (\n                        <td\n                          key={column.key}\n                          className={`table-cell table-data-cell ${\n                            column.align ? `table-align-${column.align}` : \"\"\n                          }`}\n                          style={{ width: column.width }}\n                        >\n                          {renderCell(column, record, index)}\n                        </td>\n                      ))}\n                    </tr>\n                    \n                    {expandable?.expandedRowRender && expanded && (\n                      <tr className=\"table-expanded-row\">\n                        <td\n                          className=\"table-cell table-expanded-content\"\n                          colSpan={\n                            columns.length + \n                            (rowSelection ? 1 : 0) + \n                            (expandable ? 1 : 0)\n                          }\n                        >\n                          {expandable.expandedRowRender(record)}\n                        </td>\n                      </tr>\n                    )}\n                  </React.Fragment>\n                );\n              })\n            )}\n          </tbody>\n        </table>\n      </div>\n      \n      {pagination && (\n        <div className=\"table-pagination\">\n          <button\n            type=\"button\"\n            disabled={pagination.current === 1}\n            onClick={() => pagination.onChange(pagination.current - 1, pagination.pageSize)}\n          >\n            Previous\n          </button>\n          <span>\n            Page {pagination.current} of {Math.ceil(pagination.total / pagination.pageSize)}\n          </span>\n          <button\n            type=\"button\"\n            disabled={pagination.current >= Math.ceil(pagination.total / pagination.pageSize)}\n            onClick={() => pagination.onChange(pagination.current + 1, pagination.pageSize)}\n          >\n            Next\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nTable.displayName = \"Table\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Table } from \"../Table\";\n\nconst mockColumns = [\n  { key: \"name\", title: \"Name\", dataIndex: \"name\" as const, sortable: true },\n  { key: \"age\", title: \"Age\", dataIndex: \"age\" as const, sortable: true },\n  { key: \"email\", title: \"Email\", dataIndex: \"email\" as const },\n  { \n    key: \"actions\", \n    title: \"Actions\", \n    render: (value: any, record: any) => <button>Edit {record.name}</button> \n  },\n];\n\nconst mockData = [\n  { id: \"1\", name: \"John Doe\", age: 30, email: \"john@example.com\" },\n  { id: \"2\", name: \"Jane Smith\", age: 25, email: \"jane@example.com\" },\n  { id: \"3\", name: \"Bob Johnson\", age: 35, email: \"bob@example.com\" },\n];\n\ntest(\"renders table with data\", () => {\n  render(<Table columns={mockColumns} data={mockData} />);\n  \n  expect(screen.getByRole(\"table\")).toBeInTheDocument();\n  expect(screen.getByText(\"John Doe\")).toBeInTheDocument();\n  expect(screen.getByText(\"Jane Smith\")).toBeInTheDocument();\n  expect(screen.getByText(\"Bob Johnson\")).toBeInTheDocument();\n});\n\ntest(\"renders column headers\", () => {\n  render(<Table columns={mockColumns} data={mockData} />);\n  \n  expect(screen.getByText(\"Name\")).toBeInTheDocument();\n  expect(screen.getByText(\"Age\")).toBeInTheDocument();\n  expect(screen.getByText(\"Email\")).toBeInTheDocument();\n  expect(screen.getByText(\"Actions\")).toBeInTheDocument();\n});\n\ntest(\"renders custom cell content\", () => {\n  render(<Table columns={mockColumns} data={mockData} />);\n  \n  expect(screen.getByText(\"Edit John Doe\")).toBeInTheDocument();\n  expect(screen.getByText(\"Edit Jane Smith\")).toBeInTheDocument();\n  expect(screen.getByText(\"Edit Bob Johnson\")).toBeInTheDocument();\n});\n\ntest(\"shows empty message when no data\", () => {\n  render(<Table columns={mockColumns} data={[]} emptyText=\"No records found\" />);\n  expect(screen.getByText(\"No records found\")).toBeInTheDocument();\n});\n\ntest(\"shows loading state\", () => {\n  render(<Table columns={mockColumns} data={mockData} loading />);\n  expect(screen.getByRole(\"status\", { name: /loading/i })).toBeInTheDocument();\n});\n\ntest(\"handles sorting\", async () => {\n  const user = userEvent.setup();\n  const onSort = vi.fn();\n  render(<Table columns={mockColumns} data={mockData} onSort={onSort} />);\n  \n  const nameHeader = screen.getByText(\"Name\");\n  await user.click(nameHeader);\n  \n  expect(onSort).toHaveBeenCalledWith(\"name\", \"asc\");\n  \n  await user.click(nameHeader);\n  expect(onSort).toHaveBeenCalledWith(\"name\", \"desc\");\n});\n\ntest(\"shows sort indicators\", async () => {\n  const user = userEvent.setup();\n  render(<Table columns={mockColumns} data={mockData} />);\n  \n  const nameHeader = screen.getByText(\"Name\").closest(\"th\");\n  expect(nameHeader).toHaveTextContent(\"↕\");\n  \n  await user.click(screen.getByText(\"Name\"));\n  expect(nameHeader).toHaveTextContent(\"↑\");\n  \n  await user.click(screen.getByText(\"Name\"));\n  expect(nameHeader).toHaveTextContent(\"↓\");\n});\n\ntest(\"handles row selection\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const rowSelection = { selectedRowKeys: [], onChange };\n  \n  render(<Table columns={mockColumns} data={mockData} rowSelection={rowSelection} />);\n  \n  const firstRowCheckbox = screen.getByLabelText(\"Select row 1\");\n  await user.click(firstRowCheckbox);\n  \n  expect(onChange).toHaveBeenCalledWith([\"1\"], [mockData[0]]);\n});\n\ntest(\"handles select all\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const rowSelection = { selectedRowKeys: [], onChange };\n  \n  render(<Table columns={mockColumns} data={mockData} rowSelection={rowSelection} />);\n  \n  const selectAllCheckbox = screen.getByLabelText(\"Select all rows\");\n  await user.click(selectAllCheckbox);\n  \n  expect(onChange).toHaveBeenCalledWith([\"1\", \"2\", \"3\"], mockData);\n});\n\ntest(\"shows indeterminate state for select all\", () => {\n  const rowSelection = { selectedRowKeys: [\"1\"] };\n  render(<Table columns={mockColumns} data={mockData} rowSelection={rowSelection} />);\n  \n  const selectAllCheckbox = screen.getByLabelText(\"Select all rows\") as HTMLInputElement;\n  expect(selectAllCheckbox.indeterminate).toBe(true);\n});\n\ntest(\"handles row expansion\", async () => {\n  const user = userEvent.setup();\n  const onExpand = vi.fn();\n  const expandable = {\n    expandedRowKeys: [],\n    onExpand,\n    expandedRowRender: (record: any) => <div>Expanded content for {record.name}</div>,\n  };\n  \n  render(<Table columns={mockColumns} data={mockData} expandable={expandable} />);\n  \n  const expandButton = screen.getByLabelText(\"Expand row\");\n  await user.click(expandButton);\n  \n  expect(onExpand).toHaveBeenCalledWith(true, mockData[0]);\n});\n\ntest(\"shows expanded content\", () => {\n  const expandable = {\n    expandedRowKeys: [\"1\"],\n    expandedRowRender: (record: any) => <div>Expanded content for {record.name}</div>,\n  };\n  \n  render(<Table columns={mockColumns} data={mockData} expandable={expandable} />);\n  \n  expect(screen.getByText(\"Expanded content for John Doe\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n  const { container } = render(<Table columns={mockColumns} data={mockData} variant=\"striped\" />);\n  expect(container.firstChild).toHaveClass(\"table-striped\");\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<Table columns={mockColumns} data={mockData} size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"table-lg\");\n});\n\ntest(\"handles pagination\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const pagination = {\n    current: 1,\n    pageSize: 10,\n    total: 30,\n    onChange,\n  };\n  \n  render(<Table columns={mockColumns} data={mockData} pagination={pagination} />);\n  \n  expect(screen.getByText(\"Page 1 of 3\")).toBeInTheDocument();\n  \n  const nextButton = screen.getByText(\"Next\");\n  await user.click(nextButton);\n  \n  expect(onChange).toHaveBeenCalledWith(2, 10);\n});\n\ntest(\"disables pagination buttons appropriately\", () => {\n  const pagination = {\n    current: 1,\n    pageSize: 10,\n    total: 30,\n    onChange: vi.fn(),\n  };\n  \n  render(<Table columns={mockColumns} data={mockData} pagination={pagination} />);\n  \n  expect(screen.getByText(\"Previous\")).toBeDisabled();\n  expect(screen.getByText(\"Next\")).not.toBeDisabled();\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface TableColumn<T = any> {\n  key: string;\n  title: string;\n  dataIndex?: keyof T;\n  render?: (value: any, record: T, index: number) => React.ReactNode;\n  width?: string | number;\n  sortable?: boolean;\n  align?: \"left\" | \"center\" | \"right\";\n  fixed?: \"left\" | \"right\";\n}\n\nexport interface TableProps<T = any> extends React.HTMLAttributes<HTMLDivElement> {\n  columns: TableColumn<T>[];\n  data: T[];\n  loading?: boolean;\n  emptyText?: string;\n  variant?: \"default\" | \"striped\" | \"bordered\";\n  size?: \"sm\" | \"md\" | \"lg\";\n  sticky?: boolean;\n  sortBy?: string;\n  sortOrder?: \"asc\" | \"desc\";\n  onSort?: (key: string, order: \"asc\" | \"desc\") => void;\n  rowSelection?: {\n    selectedRowKeys?: string[];\n    onChange?: (selectedKeys: string[], selectedRows: T[]) => void;\n    getCheckboxProps?: (record: T) => { disabled?: boolean };\n  };\n  pagination?: {\n    current: number;\n    pageSize: number;\n    total: number;\n    onChange: (page: number, pageSize: number) => void;\n  };\n  expandable?: {\n    expandedRowKeys?: string[];\n    onExpand?: (expanded: boolean, record: T) => void;\n    expandedRowRender?: (record: T) => React.ReactNode;\n  };\n  rowKey?: string | ((record: T) => string);\n}\n\nconst classesByVariant: Record<NonNullable<TableProps[\"variant\"]>, string> = {\n  default: \"table-default\",\n  striped: \"table-striped\",\n  bordered: \"table-bordered\",\n};\n\nconst classesBySize: Record<NonNullable<TableProps[\"size\"]>, string> = {\n  sm: \"table-sm\",\n  md: \"table-md\",\n  lg: \"table-lg\",\n};\n\nexport const Table = <T extends Record<string, any>>({\n  columns,\n  data,\n  loading = false,\n  emptyText = \"No data\",\n  variant = \"default\",\n  size = \"md\",\n  sticky = false,\n  sortBy,\n  sortOrder,\n  onSort,\n  rowSelection,\n  pagination,\n  expandable,\n  rowKey = \"id\",\n  className,\n  ...rest\n}: TableProps<T>) => {\n  const [internalSortBy, setInternalSortBy] = React.useState<string | undefined>(sortBy);\n  const [internalSortOrder, setInternalSortOrder] = React.useState<\"asc\" | \"desc\">(\"asc\");\n\n  const classes = `table-container ${classesByVariant[variant]} ${classesBySize[size]} ${\n    sticky ? \"table-sticky\" : \"\"\n  } ${className || \"\"}`.trim();\n\n  const getRowKey = (record: T, index: number): string => {\n    if (typeof rowKey === \"function\") {\n      return rowKey(record);\n    }\n    return record[rowKey] || index.toString();\n  };\n\n  const handleSort = (columnKey: string) => {\n    const newOrder = \n      internalSortBy === columnKey && internalSortOrder === \"asc\" ? \"desc\" : \"asc\";\n    \n    setInternalSortBy(columnKey);\n    setInternalSortOrder(newOrder);\n    \n    if (onSort) {\n      onSort(columnKey, newOrder);\n    }\n  };\n\n  const handleRowSelect = (recordKey: string, selected: boolean, record: T) => {\n    if (!rowSelection?.onChange) return;\n    \n    const currentSelected = rowSelection.selectedRowKeys || [];\n    const newSelected = selected\n      ? [...currentSelected, recordKey]\n      : currentSelected.filter(key => key !== recordKey);\n    \n    const selectedRows = data.filter(item => \n      newSelected.includes(getRowKey(item, data.indexOf(item)))\n    );\n    \n    rowSelection.onChange(newSelected, selectedRows);\n  };\n\n  const handleSelectAll = (selected: boolean) => {\n    if (!rowSelection?.onChange) return;\n    \n    const selectableRows = data.filter((record, index) => {\n      const checkboxProps = rowSelection.getCheckboxProps?.(record);\n      return !checkboxProps?.disabled;\n    });\n    \n    const newSelected = selected \n      ? selectableRows.map((record, index) => getRowKey(record, index))\n      : [];\n    \n    rowSelection.onChange(newSelected, selected ? selectableRows : []);\n  };\n\n  const handleExpand = (record: T, expanded: boolean) => {\n    if (expandable?.onExpand) {\n      expandable.onExpand(expanded, record);\n    }\n  };\n\n  const isRowSelected = (record: T, index: number): boolean => {\n    const key = getRowKey(record, index);\n    return rowSelection?.selectedRowKeys?.includes(key) || false;\n  };\n\n  const isRowExpanded = (record: T, index: number): boolean => {\n    const key = getRowKey(record, index);\n    return expandable?.expandedRowKeys?.includes(key) || false;\n  };\n\n  const isAllSelected = (): boolean => {\n    if (!rowSelection?.selectedRowKeys) return false;\n    const selectableRows = data.filter((record) => {\n      const checkboxProps = rowSelection.getCheckboxProps?.(record);\n      return !checkboxProps?.disabled;\n    });\n    return selectableRows.length > 0 && \n           selectableRows.every((record, index) => isRowSelected(record, index));\n  };\n\n  const isIndeterminate = (): boolean => {\n    if (!rowSelection?.selectedRowKeys) return false;\n    const selectedCount = data.filter((record, index) => isRowSelected(record, index)).length;\n    return selectedCount > 0 && selectedCount < data.length;\n  };\n\n  const renderCell = (column: TableColumn<T>, record: T, index: number) => {\n    if (column.render) {\n      return column.render(\n        column.dataIndex ? record[column.dataIndex] : undefined,\n        record,\n        index\n      );\n    }\n    return column.dataIndex ? record[column.dataIndex] : \"\";\n  };\n\n  const getSortIcon = (columnKey: string) => {\n    if (internalSortBy !== columnKey) return \"↕\";\n    return internalSortOrder === \"asc\" ? \"↑\" : \"↓\";\n  };\n\n  return (\n    <div {...rest} className={classes}>\n      {loading && (\n        <div className=\"table-loading\" role=\"status\" aria-label=\"Loading\">\n          Loading...\n        </div>\n      )}\n      \n      <div className=\"table-wrapper\">\n        <table className=\"table\" role=\"table\">\n          <thead className=\"table-header\">\n            <tr>\n              {rowSelection && (\n                <th className=\"table-cell table-selection-cell\">\n                  <input\n                    type=\"checkbox\"\n                    checked={isAllSelected()}\n                    ref={(input) => {\n                      if (input) input.indeterminate = isIndeterminate();\n                    }}\n                    onChange={(e) => handleSelectAll(e.target.checked)}\n                    aria-label=\"Select all rows\"\n                  />\n                </th>\n              )}\n              \n              {expandable && (\n                <th className=\"table-cell table-expand-cell\" />\n              )}\n              \n              {columns.map((column) => (\n                <th\n                  key={column.key}\n                  className={`table-cell table-header-cell ${\n                    column.align ? `table-align-${column.align}` : \"\"\n                  } ${column.sortable ? \"table-sortable\" : \"\"}`}\n                  style={{ width: column.width }}\n                  onClick={column.sortable ? () => handleSort(column.key) : undefined}\n                  role=\"columnheader\"\n                  aria-sort={\n                    column.sortable && internalSortBy === column.key\n                      ? internalSortOrder === \"asc\" ? \"ascending\" : \"descending\"\n                      : undefined\n                  }\n                >\n                  <div className=\"table-header-content\">\n                    {column.title}\n                    {column.sortable && (\n                      <span className=\"table-sort-icon\" aria-hidden=\"true\">\n                        {getSortIcon(column.key)}\n                      </span>\n                    )}\n                  </div>\n                </th>\n              ))}\n            </tr>\n          </thead>\n          \n          <tbody className=\"table-body\">\n            {data.length === 0 ? (\n              <tr>\n                <td\n                  className=\"table-cell table-empty\"\n                  colSpan={\n                    columns.length + \n                    (rowSelection ? 1 : 0) + \n                    (expandable ? 1 : 0)\n                  }\n                >\n                  {emptyText}\n                </td>\n              </tr>\n            ) : (\n              data.map((record, index) => {\n                const key = getRowKey(record, index);\n                const selected = isRowSelected(record, index);\n                const expanded = isRowExpanded(record, index);\n                \n                return (\n                  <React.Fragment key={key}>\n                    <tr className={`table-row ${selected ? \"table-row-selected\" : \"\"}`}>\n                      {rowSelection && (\n                        <td className=\"table-cell table-selection-cell\">\n                          <input\n                            type=\"checkbox\"\n                            checked={selected}\n                            onChange={(e) => handleRowSelect(key, e.target.checked, record)}\n                            disabled={rowSelection.getCheckboxProps?.(record)?.disabled}\n                            aria-label={`Select row ${index + 1}`}\n                          />\n                        </td>\n                      )}\n                      \n                      {expandable && (\n                        <td className=\"table-cell table-expand-cell\">\n                          {expandable.expandedRowRender && (\n                            <button\n                              type=\"button\"\n                              className=\"table-expand-button\"\n                              onClick={() => handleExpand(record, !expanded)}\n                              aria-label={expanded ? \"Collapse row\" : \"Expand row\"}\n                              aria-expanded={expanded}\n                            >\n                              {expanded ? \"−\" : \"+\"}\n                            </button>\n                          )}\n                        </td>\n                      )}\n                      \n                      {columns.map((column) => (\n                        <td\n                          key={column.key}\n                          className={`table-cell table-data-cell ${\n                            column.align ? `table-align-${column.align}` : \"\"\n                          }`}\n                          style={{ width: column.width }}\n                        >\n                          {renderCell(column, record, index)}\n                        </td>\n                      ))}\n                    </tr>\n                    \n                    {expandable?.expandedRowRender && expanded && (\n                      <tr className=\"table-expanded-row\">\n                        <td\n                          className=\"table-cell table-expanded-content\"\n                          colSpan={\n                            columns.length + \n                            (rowSelection ? 1 : 0) + \n                            (expandable ? 1 : 0)\n                          }\n                        >\n                          {expandable.expandedRowRender(record)}\n                        </td>\n                      </tr>\n                    )}\n                  </React.Fragment>\n                );\n              })\n            )}\n          </tbody>\n        </table>\n      </div>\n      \n      {pagination && (\n        <div className=\"table-pagination\">\n          <button\n            type=\"button\"\n            disabled={pagination.current === 1}\n            onClick={() => pagination.onChange(pagination.current - 1, pagination.pageSize)}\n          >\n            Previous\n          </button>\n          <span>\n            Page {pagination.current} of {Math.ceil(pagination.total / pagination.pageSize)}\n          </span>\n          <button\n            type=\"button\"\n            disabled={pagination.current >= Math.ceil(pagination.total / pagination.pageSize)}\n            onClick={() => pagination.onChange(pagination.current + 1, pagination.pageSize)}\n          >\n            Next\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nTable.displayName = \"Table\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Table } from \"../Table\";\n\nconst mockColumns = [\n  { key: \"name\", title: \"Name\", dataIndex: \"name\" as const, sortable: true },\n  { key: \"age\", title: \"Age\", dataIndex: \"age\" as const, sortable: true },\n  { key: \"email\", title: \"Email\", dataIndex: \"email\" as const },\n  { \n    key: \"actions\", \n    title: \"Actions\", \n    render: (value: any, record: any) => <button>Edit {record.name}</button> \n  },\n];\n\nconst mockData = [\n  { id: \"1\", name: \"John Doe\", age: 30, email: \"john@example.com\" },\n  { id: \"2\", name: \"Jane Smith\", age: 25, email: \"jane@example.com\" },\n  { id: \"3\", name: \"Bob Johnson\", age: 35, email: \"bob@example.com\" },\n];\n\ntest(\"renders table with data\", () => {\n  render(<Table columns={mockColumns} data={mockData} />);\n  \n  expect(screen.getByRole(\"table\")).toBeInTheDocument();\n  expect(screen.getByText(\"John Doe\")).toBeInTheDocument();\n  expect(screen.getByText(\"Jane Smith\")).toBeInTheDocument();\n  expect(screen.getByText(\"Bob Johnson\")).toBeInTheDocument();\n});\n\ntest(\"renders column headers\", () => {\n  render(<Table columns={mockColumns} data={mockData} />);\n  \n  expect(screen.getByText(\"Name\")).toBeInTheDocument();\n  expect(screen.getByText(\"Age\")).toBeInTheDocument();\n  expect(screen.getByText(\"Email\")).toBeInTheDocument();\n  expect(screen.getByText(\"Actions\")).toBeInTheDocument();\n});\n\ntest(\"renders custom cell content\", () => {\n  render(<Table columns={mockColumns} data={mockData} />);\n  \n  expect(screen.getByText(\"Edit John Doe\")).toBeInTheDocument();\n  expect(screen.getByText(\"Edit Jane Smith\")).toBeInTheDocument();\n  expect(screen.getByText(\"Edit Bob Johnson\")).toBeInTheDocument();\n});\n\ntest(\"shows empty message when no data\", () => {\n  render(<Table columns={mockColumns} data={[]} emptyText=\"No records found\" />);\n  expect(screen.getByText(\"No records found\")).toBeInTheDocument();\n});\n\ntest(\"shows loading state\", () => {\n  render(<Table columns={mockColumns} data={mockData} loading />);\n  expect(screen.getByRole(\"status\", { name: /loading/i })).toBeInTheDocument();\n});\n\ntest(\"handles sorting\", async () => {\n  const user = userEvent.setup();\n  const onSort = vi.fn();\n  render(<Table columns={mockColumns} data={mockData} onSort={onSort} />);\n  \n  const nameHeader = screen.getByText(\"Name\");\n  await user.click(nameHeader);\n  \n  expect(onSort).toHaveBeenCalledWith(\"name\", \"asc\");\n  \n  await user.click(nameHeader);\n  expect(onSort).toHaveBeenCalledWith(\"name\", \"desc\");\n});\n\ntest(\"shows sort indicators\", async () => {\n  const user = userEvent.setup();\n  render(<Table columns={mockColumns} data={mockData} />);\n  \n  const nameHeader = screen.getByText(\"Name\").closest(\"th\");\n  expect(nameHeader).toHaveTextContent(\"↕\");\n  \n  await user.click(screen.getByText(\"Name\"));\n  expect(nameHeader).toHaveTextContent(\"↑\");\n  \n  await user.click(screen.getByText(\"Name\"));\n  expect(nameHeader).toHaveTextContent(\"↓\");\n});\n\ntest(\"handles row selection\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const rowSelection = { selectedRowKeys: [], onChange };\n  \n  render(<Table columns={mockColumns} data={mockData} rowSelection={rowSelection} />);\n  \n  const firstRowCheckbox = screen.getByLabelText(\"Select row 1\");\n  await user.click(firstRowCheckbox);\n  \n  expect(onChange).toHaveBeenCalledWith([\"1\"], [mockData[0]]);\n});\n\ntest(\"handles select all\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const rowSelection = { selectedRowKeys: [], onChange };\n  \n  render(<Table columns={mockColumns} data={mockData} rowSelection={rowSelection} />);\n  \n  const selectAllCheckbox = screen.getByLabelText(\"Select all rows\");\n  await user.click(selectAllCheckbox);\n  \n  expect(onChange).toHaveBeenCalledWith([\"1\", \"2\", \"3\"], mockData);\n});\n\ntest(\"shows indeterminate state for select all\", () => {\n  const rowSelection = { selectedRowKeys: [\"1\"] };\n  render(<Table columns={mockColumns} data={mockData} rowSelection={rowSelection} />);\n  \n  const selectAllCheckbox = screen.getByLabelText(\"Select all rows\") as HTMLInputElement;\n  expect(selectAllCheckbox.indeterminate).toBe(true);\n});\n\ntest(\"handles row expansion\", async () => {\n  const user = userEvent.setup();\n  const onExpand = vi.fn();\n  const expandable = {\n    expandedRowKeys: [],\n    onExpand,\n    expandedRowRender: (record: any) => <div>Expanded content for {record.name}</div>,\n  };\n  \n  render(<Table columns={mockColumns} data={mockData} expandable={expandable} />);\n  \n  const expandButton = screen.getByLabelText(\"Expand row\");\n  await user.click(expandButton);\n  \n  expect(onExpand).toHaveBeenCalledWith(true, mockData[0]);\n});\n\ntest(\"shows expanded content\", () => {\n  const expandable = {\n    expandedRowKeys: [\"1\"],\n    expandedRowRender: (record: any) => <div>Expanded content for {record.name}</div>,\n  };\n  \n  render(<Table columns={mockColumns} data={mockData} expandable={expandable} />);\n  \n  expect(screen.getByText(\"Expanded content for John Doe\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n  const { container } = render(<Table columns={mockColumns} data={mockData} variant=\"striped\" />);\n  expect(container.firstChild).toHaveClass(\"table-striped\");\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<Table columns={mockColumns} data={mockData} size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"table-lg\");\n});\n\ntest(\"handles pagination\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const pagination = {\n    current: 1,\n    pageSize: 10,\n    total: 30,\n    onChange,\n  };\n  \n  render(<Table columns={mockColumns} data={mockData} pagination={pagination} />);\n  \n  expect(screen.getByText(\"Page 1 of 3\")).toBeInTheDocument();\n  \n  const nextButton = screen.getByText(\"Next\");\n  await user.click(nextButton);\n  \n  expect(onChange).toHaveBeenCalledWith(2, 10);\n});\n\ntest(\"disables pagination buttons appropriately\", () => {\n  const pagination = {\n    current: 1,\n    pageSize: 10,\n    total: 30,\n    onChange: vi.fn(),\n  };\n  \n  render(<Table columns={mockColumns} data={mockData} pagination={pagination} />);\n  \n  expect(screen.getByText(\"Previous\")).toBeDisabled();\n  expect(screen.getByText(\"Next\")).not.toBeDisabled();\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface TableColumn<T = any> {\n  key: string;\n  title: string;\n  dataIndex?: keyof T;\n  render?: (value: any, record: T, index: number) => React.ReactNode;\n  width?: string | number;\n  sortable?: boolean;\n  align?: \"left\" | \"center\" | \"right\";\n  fixed?: \"left\" | \"right\";\n}\n\nexport interface TableProps<T = any> extends React.HTMLAttributes<HTMLDivElement> {\n  columns: TableColumn<T>[];\n  data: T[];\n  loading?: boolean;\n  emptyText?: string;\n  variant?: \"default\" | \"striped\" | \"bordered\";\n  size?: \"sm\" | \"md\" | \"lg\";\n  sticky?: boolean;\n  sortBy?: string;\n  sortOrder?: \"asc\" | \"desc\";\n  onSort?: (key: string, order: \"asc\" | \"desc\") => void;\n  rowSelection?: {\n    selectedRowKeys?: string[];\n    onChange?: (selectedKeys: string[], selectedRows: T[]) => void;\n    getCheckboxProps?: (record: T) => { disabled?: boolean };\n  };\n  pagination?: {\n    current: number;\n    pageSize: number;\n    total: number;\n    onChange: (page: number, pageSize: number) => void;\n  };\n  expandable?: {\n    expandedRowKeys?: string[];\n    onExpand?: (expanded: boolean, record: T) => void;\n    expandedRowRender?: (record: T) => React.ReactNode;\n  };\n  rowKey?: string | ((record: T) => string);\n}\n\nconst classesByVariant: Record<NonNullable<TableProps[\"variant\"]>, string> = {\n  default: \"table-default\",\n  striped: \"table-striped\",\n  bordered: \"table-bordered\",\n};\n\nconst classesBySize: Record<NonNullable<TableProps[\"size\"]>, string> = {\n  sm: \"table-sm\",\n  md: \"table-md\",\n  lg: \"table-lg\",\n};\n\nexport const Table = <T extends Record<string, any>>({\n  columns,\n  data,\n  loading = false,\n  emptyText = \"No data\",\n  variant = \"default\",\n  size = \"md\",\n  sticky = false,\n  sortBy,\n  sortOrder,\n  onSort,\n  rowSelection,\n  pagination,\n  expandable,\n  rowKey = \"id\",\n  className,\n  ...rest\n}: TableProps<T>) => {\n  const [internalSortBy, setInternalSortBy] = React.useState<string | undefined>(sortBy);\n  const [internalSortOrder, setInternalSortOrder] = React.useState<\"asc\" | \"desc\">(\"asc\");\n\n  const classes = `table-container ${classesByVariant[variant]} ${classesBySize[size]} ${\n    sticky ? \"table-sticky\" : \"\"\n  } ${className || \"\"}`.trim();\n\n  const getRowKey = (record: T, index: number): string => {\n    if (typeof rowKey === \"function\") {\n      return rowKey(record);\n    }\n    return record[rowKey] || index.toString();\n  };\n\n  const handleSort = (columnKey: string) => {\n    const newOrder = \n      internalSortBy === columnKey && internalSortOrder === \"asc\" ? \"desc\" : \"asc\";\n    \n    setInternalSortBy(columnKey);\n    setInternalSortOrder(newOrder);\n    \n    if (onSort) {\n      onSort(columnKey, newOrder);\n    }\n  };\n\n  const handleRowSelect = (recordKey: string, selected: boolean, record: T) => {\n    if (!rowSelection?.onChange) return;\n    \n    const currentSelected = rowSelection.selectedRowKeys || [];\n    const newSelected = selected\n      ? [...currentSelected, recordKey]\n      : currentSelected.filter(key => key !== recordKey);\n    \n    const selectedRows = data.filter(item => \n      newSelected.includes(getRowKey(item, data.indexOf(item)))\n    );\n    \n    rowSelection.onChange(newSelected, selectedRows);\n  };\n\n  const handleSelectAll = (selected: boolean) => {\n    if (!rowSelection?.onChange) return;\n    \n    const selectableRows = data.filter((record, index) => {\n      const checkboxProps = rowSelection.getCheckboxProps?.(record);\n      return !checkboxProps?.disabled;\n    });\n    \n    const newSelected = selected \n      ? selectableRows.map((record, index) => getRowKey(record, index))\n      : [];\n    \n    rowSelection.onChange(newSelected, selected ? selectableRows : []);\n  };\n\n  const handleExpand = (record: T, expanded: boolean) => {\n    if (expandable?.onExpand) {\n      expandable.onExpand(expanded, record);\n    }\n  };\n\n  const isRowSelected = (record: T, index: number): boolean => {\n    const key = getRowKey(record, index);\n    return rowSelection?.selectedRowKeys?.includes(key) || false;\n  };\n\n  const isRowExpanded = (record: T, index: number): boolean => {\n    const key = getRowKey(record, index);\n    return expandable?.expandedRowKeys?.includes(key) || false;\n  };\n\n  const isAllSelected = (): boolean => {\n    if (!rowSelection?.selectedRowKeys) return false;\n    const selectableRows = data.filter((record) => {\n      const checkboxProps = rowSelection.getCheckboxProps?.(record);\n      return !checkboxProps?.disabled;\n    });\n    return selectableRows.length > 0 && \n           selectableRows.every((record, index) => isRowSelected(record, index));\n  };\n\n  const isIndeterminate = (): boolean => {\n    if (!rowSelection?.selectedRowKeys) return false;\n    const selectedCount = data.filter((record, index) => isRowSelected(record, index)).length;\n    return selectedCount > 0 && selectedCount < data.length;\n  };\n\n  const renderCell = (column: TableColumn<T>, record: T, index: number) => {\n    if (column.render) {\n      return column.render(\n        column.dataIndex ? record[column.dataIndex] : undefined,\n        record,\n        index\n      );\n    }\n    return column.dataIndex ? record[column.dataIndex] : \"\";\n  };\n\n  const getSortIcon = (columnKey: string) => {\n    if (internalSortBy !== columnKey) return \"↕\";\n    return internalSortOrder === \"asc\" ? \"↑\" : \"↓\";\n  };\n\n  return (\n    <div {...rest} className={classes}>\n      {loading && (\n        <div className=\"table-loading\" role=\"status\" aria-label=\"Loading\">\n          Loading...\n        </div>\n      )}\n      \n      <div className=\"table-wrapper\">\n        <table className=\"table\" role=\"table\">\n          <thead className=\"table-header\">\n            <tr>\n              {rowSelection && (\n                <th className=\"table-cell table-selection-cell\">\n                  <input\n                    type=\"checkbox\"\n                    checked={isAllSelected()}\n                    ref={(input) => {\n                      if (input) input.indeterminate = isIndeterminate();\n                    }}\n                    onChange={(e) => handleSelectAll(e.target.checked)}\n                    aria-label=\"Select all rows\"\n                  />\n                </th>\n              )}\n              \n              {expandable && (\n                <th className=\"table-cell table-expand-cell\" />\n              )}\n              \n              {columns.map((column) => (\n                <th\n                  key={column.key}\n                  className={`table-cell table-header-cell ${\n                    column.align ? `table-align-${column.align}` : \"\"\n                  } ${column.sortable ? \"table-sortable\" : \"\"}`}\n                  style={{ width: column.width }}\n                  onClick={column.sortable ? () => handleSort(column.key) : undefined}\n                  role=\"columnheader\"\n                  aria-sort={\n                    column.sortable && internalSortBy === column.key\n                      ? internalSortOrder === \"asc\" ? \"ascending\" : \"descending\"\n                      : undefined\n                  }\n                >\n                  <div className=\"table-header-content\">\n                    {column.title}\n                    {column.sortable && (\n                      <span className=\"table-sort-icon\" aria-hidden=\"true\">\n                        {getSortIcon(column.key)}\n                      </span>\n                    )}\n                  </div>\n                </th>\n              ))}\n            </tr>\n          </thead>\n          \n          <tbody className=\"table-body\">\n            {data.length === 0 ? (\n              <tr>\n                <td\n                  className=\"table-cell table-empty\"\n                  colSpan={\n                    columns.length + \n                    (rowSelection ? 1 : 0) + \n                    (expandable ? 1 : 0)\n                  }\n                >\n                  {emptyText}\n                </td>\n              </tr>\n            ) : (\n              data.map((record, index) => {\n                const key = getRowKey(record, index);\n                const selected = isRowSelected(record, index);\n                const expanded = isRowExpanded(record, index);\n                \n                return (\n                  <React.Fragment key={key}>\n                    <tr className={`table-row ${selected ? \"table-row-selected\" : \"\"}`}>\n                      {rowSelection && (\n                        <td className=\"table-cell table-selection-cell\">\n                          <input\n                            type=\"checkbox\"\n                            checked={selected}\n                            onChange={(e) => handleRowSelect(key, e.target.checked, record)}\n                            disabled={rowSelection.getCheckboxProps?.(record)?.disabled}\n                            aria-label={`Select row ${index + 1}`}\n                          />\n                        </td>\n                      )}\n                      \n                      {expandable && (\n                        <td className=\"table-cell table-expand-cell\">\n                          {expandable.expandedRowRender && (\n                            <button\n                              type=\"button\"\n                              className=\"table-expand-button\"\n                              onClick={() => handleExpand(record, !expanded)}\n                              aria-label={expanded ? \"Collapse row\" : \"Expand row\"}\n                              aria-expanded={expanded}\n                            >\n                              {expanded ? \"−\" : \"+\"}\n                            </button>\n                          )}\n                        </td>\n                      )}\n                      \n                      {columns.map((column) => (\n                        <td\n                          key={column.key}\n                          className={`table-cell table-data-cell ${\n                            column.align ? `table-align-${column.align}` : \"\"\n                          }`}\n                          style={{ width: column.width }}\n                        >\n                          {renderCell(column, record, index)}\n                        </td>\n                      ))}\n                    </tr>\n                    \n                    {expandable?.expandedRowRender && expanded && (\n                      <tr className=\"table-expanded-row\">\n                        <td\n                          className=\"table-cell table-expanded-content\"\n                          colSpan={\n                            columns.length + \n                            (rowSelection ? 1 : 0) + \n                            (expandable ? 1 : 0)\n                          }\n                        >\n                          {expandable.expandedRowRender(record)}\n                        </td>\n                      </tr>\n                    )}\n                  </React.Fragment>\n                );\n              })\n            )}\n          </tbody>\n        </table>\n      </div>\n      \n      {pagination && (\n        <div className=\"table-pagination\">\n          <button\n            type=\"button\"\n            disabled={pagination.current === 1}\n            onClick={() => pagination.onChange(pagination.current - 1, pagination.pageSize)}\n          >\n            Previous\n          </button>\n          <span>\n            Page {pagination.current} of {Math.ceil(pagination.total / pagination.pageSize)}\n          </span>\n          <button\n            type=\"button\"\n            disabled={pagination.current >= Math.ceil(pagination.total / pagination.pageSize)}\n            onClick={() => pagination.onChange(pagination.current + 1, pagination.pageSize)}\n          >\n            Next\n          </button>\n        </div>\n      )}\n    </div>\n  );\n};\n\nTable.displayName = \"Table\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Table } from \"../Table\";\n\nconst mockColumns = [\n  { key: \"name\", title: \"Name\", dataIndex: \"name\" as const, sortable: true },\n  { key: \"age\", title: \"Age\", dataIndex: \"age\" as const, sortable: true },\n  { key: \"email\", title: \"Email\", dataIndex: \"email\" as const },\n  { \n    key: \"actions\", \n    title: \"Actions\", \n    render: (value: any, record: any) => <button>Edit {record.name}</button> \n  },\n];\n\nconst mockData = [\n  { id: \"1\", name: \"John Doe\", age: 30, email: \"john@example.com\" },\n  { id: \"2\", name: \"Jane Smith\", age: 25, email: \"jane@example.com\" },\n  { id: \"3\", name: \"Bob Johnson\", age: 35, email: \"bob@example.com\" },\n];\n\ntest(\"renders table with data\", () => {\n  render(<Table columns={mockColumns} data={mockData} />);\n  \n  expect(screen.getByRole(\"table\")).toBeInTheDocument();\n  expect(screen.getByText(\"John Doe\")).toBeInTheDocument();\n  expect(screen.getByText(\"Jane Smith\")).toBeInTheDocument();\n  expect(screen.getByText(\"Bob Johnson\")).toBeInTheDocument();\n});\n\ntest(\"renders column headers\", () => {\n  render(<Table columns={mockColumns} data={mockData} />);\n  \n  expect(screen.getByText(\"Name\")).toBeInTheDocument();\n  expect(screen.getByText(\"Age\")).toBeInTheDocument();\n  expect(screen.getByText(\"Email\")).toBeInTheDocument();\n  expect(screen.getByText(\"Actions\")).toBeInTheDocument();\n});\n\ntest(\"renders custom cell content\", () => {\n  render(<Table columns={mockColumns} data={mockData} />);\n  \n  expect(screen.getByText(\"Edit John Doe\")).toBeInTheDocument();\n  expect(screen.getByText(\"Edit Jane Smith\")).toBeInTheDocument();\n  expect(screen.getByText(\"Edit Bob Johnson\")).toBeInTheDocument();\n});\n\ntest(\"shows empty message when no data\", () => {\n  render(<Table columns={mockColumns} data={[]} emptyText=\"No records found\" />);\n  expect(screen.getByText(\"No records found\")).toBeInTheDocument();\n});\n\ntest(\"shows loading state\", () => {\n  render(<Table columns={mockColumns} data={mockData} loading />);\n  expect(screen.getByRole(\"status\", { name: /loading/i })).toBeInTheDocument();\n});\n\ntest(\"handles sorting\", async () => {\n  const user = userEvent.setup();\n  const onSort = vi.fn();\n  render(<Table columns={mockColumns} data={mockData} onSort={onSort} />);\n  \n  const nameHeader = screen.getByText(\"Name\");\n  await user.click(nameHeader);\n  \n  expect(onSort).toHaveBeenCalledWith(\"name\", \"asc\");\n  \n  await user.click(nameHeader);\n  expect(onSort).toHaveBeenCalledWith(\"name\", \"desc\");\n});\n\ntest(\"shows sort indicators\", async () => {\n  const user = userEvent.setup();\n  render(<Table columns={mockColumns} data={mockData} />);\n  \n  const nameHeader = screen.getByText(\"Name\").closest(\"th\");\n  expect(nameHeader).toHaveTextContent(\"↕\");\n  \n  await user.click(screen.getByText(\"Name\"));\n  expect(nameHeader).toHaveTextContent(\"↑\");\n  \n  await user.click(screen.getByText(\"Name\"));\n  expect(nameHeader).toHaveTextContent(\"↓\");\n});\n\ntest(\"handles row selection\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const rowSelection = { selectedRowKeys: [], onChange };\n  \n  render(<Table columns={mockColumns} data={mockData} rowSelection={rowSelection} />);\n  \n  const firstRowCheckbox = screen.getByLabelText(\"Select row 1\");\n  await user.click(firstRowCheckbox);\n  \n  expect(onChange).toHaveBeenCalledWith([\"1\"], [mockData[0]]);\n});\n\ntest(\"handles select all\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const rowSelection = { selectedRowKeys: [], onChange };\n  \n  render(<Table columns={mockColumns} data={mockData} rowSelection={rowSelection} />);\n  \n  const selectAllCheckbox = screen.getByLabelText(\"Select all rows\");\n  await user.click(selectAllCheckbox);\n  \n  expect(onChange).toHaveBeenCalledWith([\"1\", \"2\", \"3\"], mockData);\n});\n\ntest(\"shows indeterminate state for select all\", () => {\n  const rowSelection = { selectedRowKeys: [\"1\"] };\n  render(<Table columns={mockColumns} data={mockData} rowSelection={rowSelection} />);\n  \n  const selectAllCheckbox = screen.getByLabelText(\"Select all rows\") as HTMLInputElement;\n  expect(selectAllCheckbox.indeterminate).toBe(true);\n});\n\ntest(\"handles row expansion\", async () => {\n  const user = userEvent.setup();\n  const onExpand = vi.fn();\n  const expandable = {\n    expandedRowKeys: [],\n    onExpand,\n    expandedRowRender: (record: any) => <div>Expanded content for {record.name}</div>,\n  };\n  \n  render(<Table columns={mockColumns} data={mockData} expandable={expandable} />);\n  \n  const expandButton = screen.getByLabelText(\"Expand row\");\n  await user.click(expandButton);\n  \n  expect(onExpand).toHaveBeenCalledWith(true, mockData[0]);\n});\n\ntest(\"shows expanded content\", () => {\n  const expandable = {\n    expandedRowKeys: [\"1\"],\n    expandedRowRender: (record: any) => <div>Expanded content for {record.name}</div>,\n  };\n  \n  render(<Table columns={mockColumns} data={mockData} expandable={expandable} />);\n  \n  expect(screen.getByText(\"Expanded content for John Doe\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n  const { container } = render(<Table columns={mockColumns} data={mockData} variant=\"striped\" />);\n  expect(container.firstChild).toHaveClass(\"table-striped\");\n});\n\ntest(\"applies size classes\", () => {\n  const { container } = render(<Table columns={mockColumns} data={mockData} size=\"lg\" />);\n  expect(container.firstChild).toHaveClass(\"table-lg\");\n});\n\ntest(\"handles pagination\", async () => {\n  const user = userEvent.setup();\n  const onChange = vi.fn();\n  const pagination = {\n    current: 1,\n    pageSize: 10,\n    total: 30,\n    onChange,\n  };\n  \n  render(<Table columns={mockColumns} data={mockData} pagination={pagination} />);\n  \n  expect(screen.getByText(\"Page 1 of 3\")).toBeInTheDocument();\n  \n  const nextButton = screen.getByText(\"Next\");\n  await user.click(nextButton);\n  \n  expect(onChange).toHaveBeenCalledWith(2, 10);\n});\n\ntest(\"disables pagination buttons appropriately\", () => {\n  const pagination = {\n    current: 1,\n    pageSize: 10,\n    total: 30,\n    onChange: vi.fn(),\n  };\n  \n  render(<Table columns={mockColumns} data={mockData} pagination={pagination} />);\n  \n  expect(screen.getByText(\"Previous\")).toBeDisabled();\n  expect(screen.getByText(\"Next\")).not.toBeDisabled();\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\ntype TextVariant = \"body\" | \"heading\" | \"caption\" | \"label\";\ntype TextSize = \"small\" | \"medium\" | \"large\";\n\nexport interface TextProps extends React.HTMLAttributes<HTMLElement> {\n  variant?: TextVariant;\n  size?: TextSize;\n  as?: keyof JSX.IntrinsicElements;\n  truncate?: boolean;\n}\n\nconst classesByVariant: Record<TextVariant, string> = {\n  body: \"text-body\",\n  heading: \"text-heading\",\n  caption: \"text-caption\",\n  label: \"text-label\",\n};\n\nconst classesBySize: Record<TextSize, string> = {\n  small: \"text-small\",\n  medium: \"text-medium\",\n  large: \"text-large\",\n};\n\nexport const Text = React.forwardRef<HTMLElement, TextProps>(\n  ({ variant = \"body\", size = \"medium\", as = \"span\", truncate = false, className, children, ...rest }, ref) => {\n    const Component = as as React.ElementType;\n    const classes = [\n      classesByVariant[variant],\n      classesBySize[size],\n      truncate && \"text-truncate\",\n      className\n    ].filter(Boolean).join(\" \");\n\n    return (\n      <Component\n        {...rest}\n        ref={ref}\n        className={classes}\n      >\n        {children}\n      </Component>\n    );\n  }\n);\nText.displayName = \"Text\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Text } from \"../Text\";\n\ntest(\"renders with children\", () => {\n  render(<Text>Hello World</Text>);\n  expect(screen.getByText(\"Hello World\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n  render(<Text variant=\"heading\">Heading</Text>);\n  expect(screen.getByText(\"Heading\")).toHaveClass(\"text-heading\");\n});\n\ntest(\"applies size classes\", () => {\n  render(<Text size=\"large\">Large text</Text>);\n  expect(screen.getByText(\"Large text\")).toHaveClass(\"text-large\");\n});\n\ntest(\"renders as different element\", () => {\n  render(<Text as=\"h1\">Heading</Text>);\n  expect(screen.getByRole(\"heading\")).toBeInTheDocument();\n});\n\ntest(\"applies truncate class\", () => {\n  render(<Text truncate>Long text</Text>);\n  expect(screen.getByText(\"Long text\")).toHaveClass(\"text-truncate\");\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\ntype TextVariant = \"body\" | \"heading\" | \"caption\" | \"label\";\ntype TextSize = \"small\" | \"medium\" | \"large\";\n\nexport interface TextProps extends React.HTMLAttributes<HTMLElement> {\n  variant?: TextVariant;\n  size?: TextSize;\n  as?: keyof JSX.IntrinsicElements;\n  truncate?: boolean;\n}\n\nconst classesByVariant: Record<TextVariant, string> = {\n  body: \"text-body\",\n  heading: \"text-heading\",\n  caption: \"text-caption\",\n  label: \"text-label\",\n};\n\nconst classesBySize: Record<TextSize, string> = {\n  small: \"text-small\",\n  medium: \"text-medium\",\n  large: \"text-large\",\n};\n\nexport const Text = React.forwardRef<HTMLElement, TextProps>(\n  ({ variant = \"body\", size = \"medium\", as = \"span\", truncate = false, className, children, ...rest }, ref) => {\n    const Component = as as React.ElementType;\n    const classes = [\n      classesByVariant[variant],\n      classesBySize[size],\n      truncate && \"text-truncate\",\n      className\n    ].filter(Boolean).join(\" \");\n\n    return (\n      <Component\n        {...rest}\n        ref={ref}\n        className={classes}\n      >\n        {children}\n      </Component>\n    );\n  }\n);\nText.displayName = \"Text\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Text } from \"../Text\";\n\ntest(\"renders with children\", () => {\n  render(<Text>Hello World</Text>);\n  expect(screen.getByText(\"Hello World\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n  render(<Text variant=\"heading\">Heading</Text>);\n  expect(screen.getByText(\"Heading\")).toHaveClass(\"text-heading\");\n});\n\ntest(\"applies size classes\", () => {\n  render(<Text size=\"large\">Large text</Text>);\n  expect(screen.getByText(\"Large text\")).toHaveClass(\"text-large\");\n});\n\ntest(\"renders as different element\", () => {\n  render(<Text as=\"h1\">Heading</Text>);\n  expect(screen.getByRole(\"heading\")).toBeInTheDocument();\n});\n\ntest(\"applies truncate class\", () => {\n  render(<Text truncate>Long text</Text>);\n  expect(screen.getByText(\"Long text\")).toHaveClass(\"text-truncate\");\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\ntype TextVariant = \"body\" | \"heading\" | \"caption\" | \"label\";\ntype TextSize = \"small\" | \"medium\" | \"large\";\n\nexport interface TextProps extends React.HTMLAttributes<HTMLElement> {\n  variant?: TextVariant;\n  size?: TextSize;\n  as?: keyof JSX.IntrinsicElements;\n  truncate?: boolean;\n}\n\nconst classesByVariant: Record<TextVariant, string> = {\n  body: \"text-body\",\n  heading: \"text-heading\",\n  caption: \"text-caption\",\n  label: \"text-label\",\n};\n\nconst classesBySize: Record<TextSize, string> = {\n  small: \"text-small\",\n  medium: \"text-medium\",\n  large: \"text-large\",\n};\n\nexport const Text = React.forwardRef<HTMLElement, TextProps>(\n  ({ variant = \"body\", size = \"medium\", as = \"span\", truncate = false, className, children, ...rest }, ref) => {\n    const Component = as as React.ElementType;\n    const classes = [\n      classesByVariant[variant],\n      classesBySize[size],\n      truncate && \"text-truncate\",\n      className\n    ].filter(Boolean).join(\" \");\n\n    return (\n      <Component\n        {...rest}\n        ref={ref}\n        className={classes}\n      >\n        {children}\n      </Component>\n    );\n  }\n);\nText.displayName = \"Text\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Text } from \"../Text\";\n\ntest(\"renders with children\", () => {\n  render(<Text>Hello World</Text>);\n  expect(screen.getByText(\"Hello World\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n  render(<Text variant=\"heading\">Heading</Text>);\n  expect(screen.getByText(\"Heading\")).toHaveClass(\"text-heading\");\n});\n\ntest(\"applies size classes\", () => {\n  render(<Text size=\"large\">Large text</Text>);\n  expect(screen.getByText(\"Large text\")).toHaveClass(\"text-large\");\n});\n\ntest(\"renders as different element\", () => {\n  render(<Text as=\"h1\">Heading</Text>);\n  expect(screen.getByRole(\"heading\")).toBeInTheDocument();\n});\n\ntest(\"applies truncate class\", () => {\n  render(<Text truncate>Long text</Text>);\n  expect(screen.getByText(\"Long text\")).toHaveClass(\"text-truncate\");\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {\n    label?: string;\n    error?: string;\n    helperText?: string;\n    variant?: \"default\" | \"filled\" | \"outlined\";\n    resize?: \"none\" | \"vertical\" | \"horizontal\" | \"both\";\n    autoResize?: boolean;\n    maxLength?: number;\n    showCharacterCount?: boolean;\n}\n\nconst classesByVariant: Record<NonNullable<TextareaProps[\"variant\"]>, string> = {\n    default: \"textarea textarea-default\",\n    filled: \"textarea textarea-filled\",\n    outlined: \"textarea textarea-outlined\",\n};\n\nconst classesByResize: Record<NonNullable<TextareaProps[\"resize\"]>, string> = {\n    none: \"textarea-resize-none\",\n    vertical: \"textarea-resize-vertical\",\n    horizontal: \"textarea-resize-horizontal\",\n    both: \"textarea-resize-both\",\n};\n\nexport const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\n    ({\n        label,\n        error,\n        helperText,\n        variant = \"default\",\n        resize = \"vertical\",\n        autoResize = false,\n        maxLength,\n        showCharacterCount = false,\n        className,\n        id,\n        value,\n        onChange,\n        ...rest\n    }, ref) => {\n        const textareaRef = React.useRef<HTMLTextAreaElement>(null);\n        const combinedRef = React.useMemo(\n            () => ref || textareaRef,\n            [ref]\n        );\n\n        const textareaId = id || React.useId();\n        const errorId = error ? `${textareaId}-error` : undefined;\n        const helperTextId = helperText ? `${textareaId}-helper` : undefined;\n        const characterCountId = showCharacterCount ? `${textareaId}-count` : undefined;\n\n        const classes = `${classesByVariant[variant]} ${classesByResize[resize]} ${error ? \"textarea-error\" : \"\"\n            } ${className || \"\"}`.trim();\n\n        const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n            if (onChange) {\n                onChange(e);\n            }\n\n            if (autoResize && combinedRef && \"current\" in combinedRef && combinedRef.current) {\n                const textarea = combinedRef.current;\n                textarea.style.height = \"auto\";\n                textarea.style.height = `${textarea.scrollHeight}px`;\n            }\n        };\n\n        React.useEffect(() => {\n            if (autoResize && combinedRef && \"current\" in combinedRef && combinedRef.current) {\n                const textarea = combinedRef.current;\n                textarea.style.height = \"auto\";\n                textarea.style.height = `${textarea.scrollHeight}px`;\n            }\n        }, [value, autoResize, combinedRef]);\n\n        const currentLength = typeof value === \"string\" ? value.length : 0;\n        const isOverLimit = maxLength ? currentLength > maxLength : false;\n\n        return (\n            <div className=\"textarea-wrapper\">\n                {label && (\n                    <label htmlFor={textareaId} className=\"textarea-label\">\n                        {label}\n                    </label>\n                )}\n\n                <textarea\n                    {...rest}\n                    ref={combinedRef}\n                    id={textareaId}\n                    className={classes}\n                    value={value}\n                    maxLength={maxLength}\n                    onChange={handleChange}\n                    aria-invalid={error ? true : undefined}\n                    aria-describedby={[errorId, helperTextId, characterCountId].filter(Boolean).join(\" \") || undefined}\n                />\n\n                <div className=\"textarea-footer\">\n                    {showCharacterCount && maxLength && (\n                        <div\n                            id={characterCountId}\n                            className={`textarea-character-count ${isOverLimit ? \"textarea-over-limit\" : \"\"}`}\n                        >\n                            {currentLength}/{maxLength}\n                        </div>\n                    )}\n                </div>\n\n                {error && (\n                    <div id={errorId} className=\"textarea-error-text\" role=\"alert\">\n                        {error}\n                    </div>\n                )}\n                {helperText && !error && (\n                    <div id={helperTextId} className=\"textarea-helper-text\">\n                        {helperText}\n                    </div>\n                )}\n            </div>\n        );\n    }\n);\nTextarea.displayName = \"Textarea\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Textarea } from \"../Textarea\";\n\ntest(\"renders textarea\", () => {\n    render(<Textarea />);\n    expect(screen.getByRole(\"textbox\")).toBeInTheDocument();\n});\n\ntest(\"renders with label\", () => {\n    render(<Textarea label=\"Message\" />);\n    expect(screen.getByLabelText(\"Message\")).toBeInTheDocument();\n});\n\ntest(\"handles user input\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Textarea onChange={onChange} />);\n\n    const textarea = screen.getByRole(\"textbox\");\n    await user.type(textarea, \"Hello world\");\n\n    expect(onChange).toHaveBeenCalled();\n    expect(textarea).toHaveValue(\"Hello world\");\n});\n\ntest(\"shows error state\", () => {\n    render(<Textarea error=\"This field is required\" />);\n    const textarea = screen.getByRole(\"textbox\");\n\n    expect(textarea).toHaveClass(\"textarea-error\");\n    expect(textarea).toHaveAttribute(\"aria-invalid\", \"true\");\n    expect(screen.getByRole(\"alert\")).toHaveTextContent(\"This field is required\");\n});\n\ntest(\"shows helper text\", () => {\n    render(<Textarea helperText=\"Enter your message here\" />);\n    expect(screen.getByText(\"Enter your message here\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Textarea variant=\"outlined\" />);\n    expect(screen.getByRole(\"textbox\")).toHaveClass(\"textarea\", \"textarea-outlined\");\n});\n\ntest(\"applies resize classes\", () => {\n    render(<Textarea resize=\"horizontal\" />);\n    expect(screen.getByRole(\"textbox\")).toHaveClass(\"textarea-resize-horizontal\");\n});\n\ntest(\"shows character count when enabled\", () => {\n    render(\n        <Textarea\n            value=\"Hello\"\n            maxLength={100}\n            showCharacterCount\n            onChange={() => { }}\n        />\n    );\n    expect(screen.getByText(\"5/100\")).toBeInTheDocument();\n});\n\ntest(\"shows over limit styling when character count exceeds maxLength\", () => {\n    render(\n        <Textarea\n            value=\"This is way too long\"\n            maxLength={10}\n            showCharacterCount\n            onChange={() => { }}\n        />\n    );\n    const characterCount = screen.getByText(\"21/10\");\n    expect(characterCount).toHaveClass(\"textarea-over-limit\");\n});\n\ntest(\"respects maxLength attribute\", async () => {\n    const user = userEvent.setup();\n    render(<Textarea maxLength={5} />);\n\n    const textarea = screen.getByRole(\"textbox\");\n    await user.type(textarea, \"123456789\");\n\n    expect(textarea).toHaveValue(\"12345\");\n});\n\ntest(\"associates helper text with textarea\", () => {\n    render(<Textarea helperText=\"Helper text\" />);\n    const textarea = screen.getByRole(\"textbox\");\n    const helperText = screen.getByText(\"Helper text\");\n\n    expect(textarea).toHaveAttribute(\"aria-describedby\", expect.stringContaining(helperText.id));\n});\n\ntest(\"associates character count with textarea\", () => {\n    render(\n        <Textarea\n            value=\"test\"\n            maxLength={10}\n            showCharacterCount\n            onChange={() => { }}\n        />\n    );\n    const textarea = screen.getByRole(\"textbox\");\n    const characterCount = screen.getByText(\"4/10\");\n\n    expect(textarea).toHaveAttribute(\"aria-describedby\", expect.stringContaining(characterCount.id));\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {\n    label?: string;\n    error?: string;\n    helperText?: string;\n    variant?: \"default\" | \"filled\" | \"outlined\";\n    resize?: \"none\" | \"vertical\" | \"horizontal\" | \"both\";\n    autoResize?: boolean;\n    maxLength?: number;\n    showCharacterCount?: boolean;\n}\n\nconst classesByVariant: Record<NonNullable<TextareaProps[\"variant\"]>, string> = {\n    default: \"textarea textarea-default\",\n    filled: \"textarea textarea-filled\",\n    outlined: \"textarea textarea-outlined\",\n};\n\nconst classesByResize: Record<NonNullable<TextareaProps[\"resize\"]>, string> = {\n    none: \"textarea-resize-none\",\n    vertical: \"textarea-resize-vertical\",\n    horizontal: \"textarea-resize-horizontal\",\n    both: \"textarea-resize-both\",\n};\n\nexport const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\n    ({\n        label,\n        error,\n        helperText,\n        variant = \"default\",\n        resize = \"vertical\",\n        autoResize = false,\n        maxLength,\n        showCharacterCount = false,\n        className,\n        id,\n        value,\n        onChange,\n        ...rest\n    }, ref) => {\n        const textareaRef = React.useRef<HTMLTextAreaElement>(null);\n        const combinedRef = React.useMemo(\n            () => ref || textareaRef,\n            [ref]\n        );\n\n        const textareaId = id || React.useId();\n        const errorId = error ? `${textareaId}-error` : undefined;\n        const helperTextId = helperText ? `${textareaId}-helper` : undefined;\n        const characterCountId = showCharacterCount ? `${textareaId}-count` : undefined;\n\n        const classes = `${classesByVariant[variant]} ${classesByResize[resize]} ${error ? \"textarea-error\" : \"\"\n            } ${className || \"\"}`.trim();\n\n        const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n            if (onChange) {\n                onChange(e);\n            }\n\n            if (autoResize && combinedRef && \"current\" in combinedRef && combinedRef.current) {\n                const textarea = combinedRef.current;\n                textarea.style.height = \"auto\";\n                textarea.style.height = `${textarea.scrollHeight}px`;\n            }\n        };\n\n        React.useEffect(() => {\n            if (autoResize && combinedRef && \"current\" in combinedRef && combinedRef.current) {\n                const textarea = combinedRef.current;\n                textarea.style.height = \"auto\";\n                textarea.style.height = `${textarea.scrollHeight}px`;\n            }\n        }, [value, autoResize, combinedRef]);\n\n        const currentLength = typeof value === \"string\" ? value.length : 0;\n        const isOverLimit = maxLength ? currentLength > maxLength : false;\n\n        return (\n            <div className=\"textarea-wrapper\">\n                {label && (\n                    <label htmlFor={textareaId} className=\"textarea-label\">\n                        {label}\n                    </label>\n                )}\n\n                <textarea\n                    {...rest}\n                    ref={combinedRef}\n                    id={textareaId}\n                    className={classes}\n                    value={value}\n                    maxLength={maxLength}\n                    onChange={handleChange}\n                    aria-invalid={error ? true : undefined}\n                    aria-describedby={[errorId, helperTextId, characterCountId].filter(Boolean).join(\" \") || undefined}\n                />\n\n                <div className=\"textarea-footer\">\n                    {showCharacterCount && maxLength && (\n                        <div\n                            id={characterCountId}\n                            className={`textarea-character-count ${isOverLimit ? \"textarea-over-limit\" : \"\"}`}\n                        >\n                            {currentLength}/{maxLength}\n                        </div>\n                    )}\n                </div>\n\n                {error && (\n                    <div id={errorId} className=\"textarea-error-text\" role=\"alert\">\n                        {error}\n                    </div>\n                )}\n                {helperText && !error && (\n                    <div id={helperTextId} className=\"textarea-helper-text\">\n                        {helperText}\n                    </div>\n                )}\n            </div>\n        );\n    }\n);\nTextarea.displayName = \"Textarea\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Textarea } from \"../Textarea\";\n\ntest(\"renders textarea\", () => {\n    render(<Textarea />);\n    expect(screen.getByRole(\"textbox\")).toBeInTheDocument();\n});\n\ntest(\"renders with label\", () => {\n    render(<Textarea label=\"Message\" />);\n    expect(screen.getByLabelText(\"Message\")).toBeInTheDocument();\n});\n\ntest(\"handles user input\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Textarea onChange={onChange} />);\n\n    const textarea = screen.getByRole(\"textbox\");\n    await user.type(textarea, \"Hello world\");\n\n    expect(onChange).toHaveBeenCalled();\n    expect(textarea).toHaveValue(\"Hello world\");\n});\n\ntest(\"shows error state\", () => {\n    render(<Textarea error=\"This field is required\" />);\n    const textarea = screen.getByRole(\"textbox\");\n\n    expect(textarea).toHaveClass(\"textarea-error\");\n    expect(textarea).toHaveAttribute(\"aria-invalid\", \"true\");\n    expect(screen.getByRole(\"alert\")).toHaveTextContent(\"This field is required\");\n});\n\ntest(\"shows helper text\", () => {\n    render(<Textarea helperText=\"Enter your message here\" />);\n    expect(screen.getByText(\"Enter your message here\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Textarea variant=\"outlined\" />);\n    expect(screen.getByRole(\"textbox\")).toHaveClass(\"textarea\", \"textarea-outlined\");\n});\n\ntest(\"applies resize classes\", () => {\n    render(<Textarea resize=\"horizontal\" />);\n    expect(screen.getByRole(\"textbox\")).toHaveClass(\"textarea-resize-horizontal\");\n});\n\ntest(\"shows character count when enabled\", () => {\n    render(\n        <Textarea\n            value=\"Hello\"\n            maxLength={100}\n            showCharacterCount\n            onChange={() => { }}\n        />\n    );\n    expect(screen.getByText(\"5/100\")).toBeInTheDocument();\n});\n\ntest(\"shows over limit styling when character count exceeds maxLength\", () => {\n    render(\n        <Textarea\n            value=\"This is way too long\"\n            maxLength={10}\n            showCharacterCount\n            onChange={() => { }}\n        />\n    );\n    const characterCount = screen.getByText(\"21/10\");\n    expect(characterCount).toHaveClass(\"textarea-over-limit\");\n});\n\ntest(\"respects maxLength attribute\", async () => {\n    const user = userEvent.setup();\n    render(<Textarea maxLength={5} />);\n\n    const textarea = screen.getByRole(\"textbox\");\n    await user.type(textarea, \"123456789\");\n\n    expect(textarea).toHaveValue(\"12345\");\n});\n\ntest(\"associates helper text with textarea\", () => {\n    render(<Textarea helperText=\"Helper text\" />);\n    const textarea = screen.getByRole(\"textbox\");\n    const helperText = screen.getByText(\"Helper text\");\n\n    expect(textarea).toHaveAttribute(\"aria-describedby\", expect.stringContaining(helperText.id));\n});\n\ntest(\"associates character count with textarea\", () => {\n    render(\n        <Textarea\n            value=\"test\"\n            maxLength={10}\n            showCharacterCount\n            onChange={() => { }}\n        />\n    );\n    const textarea = screen.getByRole(\"textbox\");\n    const characterCount = screen.getByText(\"4/10\");\n\n    expect(textarea).toHaveAttribute(\"aria-describedby\", expect.stringContaining(characterCount.id));\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface TextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {\n    label?: string;\n    error?: string;\n    helperText?: string;\n    variant?: \"default\" | \"filled\" | \"outlined\";\n    resize?: \"none\" | \"vertical\" | \"horizontal\" | \"both\";\n    autoResize?: boolean;\n    maxLength?: number;\n    showCharacterCount?: boolean;\n}\n\nconst classesByVariant: Record<NonNullable<TextareaProps[\"variant\"]>, string> = {\n    default: \"textarea textarea-default\",\n    filled: \"textarea textarea-filled\",\n    outlined: \"textarea textarea-outlined\",\n};\n\nconst classesByResize: Record<NonNullable<TextareaProps[\"resize\"]>, string> = {\n    none: \"textarea-resize-none\",\n    vertical: \"textarea-resize-vertical\",\n    horizontal: \"textarea-resize-horizontal\",\n    both: \"textarea-resize-both\",\n};\n\nexport const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\n    ({\n        label,\n        error,\n        helperText,\n        variant = \"default\",\n        resize = \"vertical\",\n        autoResize = false,\n        maxLength,\n        showCharacterCount = false,\n        className,\n        id,\n        value,\n        onChange,\n        ...rest\n    }, ref) => {\n        const textareaRef = React.useRef<HTMLTextAreaElement>(null);\n        const combinedRef = React.useMemo(\n            () => ref || textareaRef,\n            [ref]\n        );\n\n        const textareaId = id || React.useId();\n        const errorId = error ? `${textareaId}-error` : undefined;\n        const helperTextId = helperText ? `${textareaId}-helper` : undefined;\n        const characterCountId = showCharacterCount ? `${textareaId}-count` : undefined;\n\n        const classes = `${classesByVariant[variant]} ${classesByResize[resize]} ${error ? \"textarea-error\" : \"\"\n            } ${className || \"\"}`.trim();\n\n        const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n            if (onChange) {\n                onChange(e);\n            }\n\n            if (autoResize && combinedRef && \"current\" in combinedRef && combinedRef.current) {\n                const textarea = combinedRef.current;\n                textarea.style.height = \"auto\";\n                textarea.style.height = `${textarea.scrollHeight}px`;\n            }\n        };\n\n        React.useEffect(() => {\n            if (autoResize && combinedRef && \"current\" in combinedRef && combinedRef.current) {\n                const textarea = combinedRef.current;\n                textarea.style.height = \"auto\";\n                textarea.style.height = `${textarea.scrollHeight}px`;\n            }\n        }, [value, autoResize, combinedRef]);\n\n        const currentLength = typeof value === \"string\" ? value.length : 0;\n        const isOverLimit = maxLength ? currentLength > maxLength : false;\n\n        return (\n            <div className=\"textarea-wrapper\">\n                {label && (\n                    <label htmlFor={textareaId} className=\"textarea-label\">\n                        {label}\n                    </label>\n                )}\n\n                <textarea\n                    {...rest}\n                    ref={combinedRef}\n                    id={textareaId}\n                    className={classes}\n                    value={value}\n                    maxLength={maxLength}\n                    onChange={handleChange}\n                    aria-invalid={error ? true : undefined}\n                    aria-describedby={[errorId, helperTextId, characterCountId].filter(Boolean).join(\" \") || undefined}\n                />\n\n                <div className=\"textarea-footer\">\n                    {showCharacterCount && maxLength && (\n                        <div\n                            id={characterCountId}\n                            className={`textarea-character-count ${isOverLimit ? \"textarea-over-limit\" : \"\"}`}\n                        >\n                            {currentLength}/{maxLength}\n                        </div>\n                    )}\n                </div>\n\n                {error && (\n                    <div id={errorId} className=\"textarea-error-text\" role=\"alert\">\n                        {error}\n                    </div>\n                )}\n                {helperText && !error && (\n                    <div id={helperTextId} className=\"textarea-helper-text\">\n                        {helperText}\n                    </div>\n                )}\n            </div>\n        );\n    }\n);\nTextarea.displayName = \"Textarea\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Textarea } from \"../Textarea\";\n\ntest(\"renders textarea\", () => {\n    render(<Textarea />);\n    expect(screen.getByRole(\"textbox\")).toBeInTheDocument();\n});\n\ntest(\"renders with label\", () => {\n    render(<Textarea label=\"Message\" />);\n    expect(screen.getByLabelText(\"Message\")).toBeInTheDocument();\n});\n\ntest(\"handles user input\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Textarea onChange={onChange} />);\n\n    const textarea = screen.getByRole(\"textbox\");\n    await user.type(textarea, \"Hello world\");\n\n    expect(onChange).toHaveBeenCalled();\n    expect(textarea).toHaveValue(\"Hello world\");\n});\n\ntest(\"shows error state\", () => {\n    render(<Textarea error=\"This field is required\" />);\n    const textarea = screen.getByRole(\"textbox\");\n\n    expect(textarea).toHaveClass(\"textarea-error\");\n    expect(textarea).toHaveAttribute(\"aria-invalid\", \"true\");\n    expect(screen.getByRole(\"alert\")).toHaveTextContent(\"This field is required\");\n});\n\ntest(\"shows helper text\", () => {\n    render(<Textarea helperText=\"Enter your message here\" />);\n    expect(screen.getByText(\"Enter your message here\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes\", () => {\n    render(<Textarea variant=\"outlined\" />);\n    expect(screen.getByRole(\"textbox\")).toHaveClass(\"textarea\", \"textarea-outlined\");\n});\n\ntest(\"applies resize classes\", () => {\n    render(<Textarea resize=\"horizontal\" />);\n    expect(screen.getByRole(\"textbox\")).toHaveClass(\"textarea-resize-horizontal\");\n});\n\ntest(\"shows character count when enabled\", () => {\n    render(\n        <Textarea\n            value=\"Hello\"\n            maxLength={100}\n            showCharacterCount\n            onChange={() => { }}\n        />\n    );\n    expect(screen.getByText(\"5/100\")).toBeInTheDocument();\n});\n\ntest(\"shows over limit styling when character count exceeds maxLength\", () => {\n    render(\n        <Textarea\n            value=\"This is way too long\"\n            maxLength={10}\n            showCharacterCount\n            onChange={() => { }}\n        />\n    );\n    const characterCount = screen.getByText(\"21/10\");\n    expect(characterCount).toHaveClass(\"textarea-over-limit\");\n});\n\ntest(\"respects maxLength attribute\", async () => {\n    const user = userEvent.setup();\n    render(<Textarea maxLength={5} />);\n\n    const textarea = screen.getByRole(\"textbox\");\n    await user.type(textarea, \"123456789\");\n\n    expect(textarea).toHaveValue(\"12345\");\n});\n\ntest(\"associates helper text with textarea\", () => {\n    render(<Textarea helperText=\"Helper text\" />);\n    const textarea = screen.getByRole(\"textbox\");\n    const helperText = screen.getByText(\"Helper text\");\n\n    expect(textarea).toHaveAttribute(\"aria-describedby\", expect.stringContaining(helperText.id));\n});\n\ntest(\"associates character count with textarea\", () => {\n    render(\n        <Textarea\n            value=\"test\"\n            maxLength={10}\n            showCharacterCount\n            onChange={() => { }}\n        />\n    );\n    const textarea = screen.getByRole(\"textbox\");\n    const characterCount = screen.getByText(\"4/10\");\n\n    expect(textarea).toHaveAttribute(\"aria-describedby\", expect.stringContaining(characterCount.id));\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface TimelineItem {\n    id: string;\n    title: string;\n    description?: string;\n    timestamp?: string;\n    icon?: React.ReactNode;\n    variant?: \"default\" | \"success\" | \"warning\" | \"error\" | \"info\";\n    content?: React.ReactNode;\n}\n\nexport interface TimelineProps extends React.HTMLAttributes<HTMLDivElement> {\n    items: TimelineItem[];\n    orientation?: \"vertical\" | \"horizontal\";\n    alternate?: boolean;\n    size?: \"sm\" | \"md\" | \"lg\";\n}\n\nconst classesBySize: Record<NonNullable<TimelineProps[\"size\"]>, string> = {\n    sm: \"timeline-sm\",\n    md: \"timeline-md\",\n    lg: \"timeline-lg\",\n};\n\nconst classesByItemVariant: Record<NonNullable<TimelineItem[\"variant\"]>, string> = {\n    default: \"timeline-item-default\",\n    success: \"timeline-item-success\",\n    warning: \"timeline-item-warning\",\n    error: \"timeline-item-error\",\n    info: \"timeline-item-info\",\n};\n\nexport const Timeline = React.forwardRef<HTMLDivElement, TimelineProps>(\n    ({\n        items,\n        orientation = \"vertical\",\n        alternate = false,\n        size = \"md\",\n        className,\n        ...rest\n    }, ref) => {\n        const classes = `timeline timeline-${orientation} ${alternate ? \"timeline-alternate\" : \"\"\n            } ${classesBySize[size]} ${className || \"\"}`.trim();\n\n        return (\n            <div {...rest} ref={ref} className={classes} role=\"list\">\n                {items.map((item, index) => {\n                    const isLast = index === items.length - 1;\n                    const itemVariant = item.variant || \"default\";\n                    const isAlternate = alternate && index % 2 === 1;\n\n                    return (\n                        <div\n                            key={item.id}\n                            className={`timeline-item ${classesByItemVariant[itemVariant]} ${isAlternate ? \"timeline-item-alternate\" : \"\"\n                                }`}\n                            role=\"listitem\"\n                        >\n                            {/* Timeline dot and connector */}\n                            <div className=\"timeline-separator\">\n                                <div className={`timeline-dot timeline-dot-${itemVariant}`}>\n                                    {item.icon || <div className=\"timeline-dot-inner\" />}\n                                </div>\n                                {!isLast && (\n                                    <div className=\"timeline-connector\" />\n                                )}\n                            </div>\n\n                            {/* Timeline content */}\n                            <div className=\"timeline-content\">\n                                <div className=\"timeline-header\">\n                                    <h3 className=\"timeline-title\">{item.title}</h3>\n                                    {item.timestamp && (\n                                        <time className=\"timeline-timestamp\" dateTime={item.timestamp}>\n                                            {item.timestamp}\n                                        </time>\n                                    )}\n                                </div>\n\n                                {item.description && (\n                                    <p className=\"timeline-description\">{item.description}</p>\n                                )}\n\n                                {item.content && (\n                                    <div className=\"timeline-item-content\">\n                                        {item.content}\n                                    </div>\n                                )}\n                            </div>\n                        </div>\n                    );\n                })}\n            </div>\n        );\n    }\n);\nTimeline.displayName = \"Timeline\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Timeline } from \"../Timeline\";\n\nconst mockItems = [\n    {\n        id: \"1\",\n        title: \"First Event\",\n        description: \"This is the first event\",\n        timestamp: \"2024-01-01\",\n        variant: \"success\" as const,\n    },\n    {\n        id: \"2\",\n        title: \"Second Event\",\n        description: \"This is the second event\",\n        timestamp: \"2024-01-02\",\n        variant: \"warning\" as const,\n        icon: <span>📅</span>,\n    },\n    {\n        id: \"3\",\n        title: \"Third Event\",\n        content: <div>Custom content</div>,\n    },\n];\n\ntest(\"renders timeline items\", () => {\n    render(<Timeline items={mockItems} />);\n\n    expect(screen.getByText(\"First Event\")).toBeInTheDocument();\n    expect(screen.getByText(\"Second Event\")).toBeInTheDocument();\n    expect(screen.getByText(\"Third Event\")).toBeInTheDocument();\n});\n\ntest(\"shows descriptions when provided\", () => {\n    render(<Timeline items={mockItems} />);\n\n    expect(screen.getByText(\"This is the first event\")).toBeInTheDocument();\n    expect(screen.getByText(\"This is the second event\")).toBeInTheDocument();\n});\n\ntest(\"shows timestamps when provided\", () => {\n    render(<Timeline items={mockItems} />);\n\n    const timestamps = screen.getAllByText(/2024-01-0[12]/);\n    expect(timestamps).toHaveLength(2);\n\n    timestamps.forEach(timestamp => {\n        expect(timestamp.tagName).toBe(\"TIME\");\n        expect(timestamp).toHaveAttribute(\"datetime\");\n    });\n});\n\ntest(\"renders custom icons\", () => {\n    render(<Timeline items={mockItems} />);\n    expect(screen.getByText(\"📅\")).toBeInTheDocument();\n});\n\ntest(\"renders custom content\", () => {\n    render(<Timeline items={mockItems} />);\n    expect(screen.getByText(\"Custom content\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes to timeline items\", () => {\n    const { container } = render(<Timeline items={mockItems} />);\n\n    const items = container.querySelectorAll(\".timeline-item\");\n    expect(items[0]).toHaveClass(\"timeline-item-success\");\n    expect(items[1]).toHaveClass(\"timeline-item-warning\");\n    expect(items[2]).toHaveClass(\"timeline-item-default\");\n});\n\ntest(\"applies variant classes to timeline dots\", () => {\n    const { container } = render(<Timeline items={mockItems} />);\n\n    const dots = container.querySelectorAll(\".timeline-dot\");\n    expect(dots[0]).toHaveClass(\"timeline-dot-success\");\n    expect(dots[1]).toHaveClass(\"timeline-dot-warning\");\n    expect(dots[2]).toHaveClass(\"timeline-dot-default\");\n});\n\ntest(\"applies orientation classes\", () => {\n    const { container } = render(<Timeline items={mockItems} orientation=\"horizontal\" />);\n    expect(container.firstChild).toHaveClass(\"timeline-horizontal\");\n});\n\ntest(\"applies alternate classes when enabled\", () => {\n    const { container } = render(<Timeline items={mockItems} alternate />);\n\n    expect(container.firstChild).toHaveClass(\"timeline-alternate\");\n\n    const items = container.querySelectorAll(\".timeline-item\");\n    expect(items[0]).not.toHaveClass(\"timeline-item-alternate\");\n    expect(items[1]).toHaveClass(\"timeline-item-alternate\");\n    expect(items[2]).not.toHaveClass(\"timeline-item-alternate\");\n});\n\ntest(\"applies size classes\", () => {\n    const { container } = render(<Timeline items={mockItems} size=\"lg\" />);\n    expect(container.firstChild).toHaveClass(\"timeline-lg\");\n});\n\ntest(\"shows connectors between items\", () => {\n    const { container } = render(<Timeline items={mockItems} />);\n\n    const connectors = container.querySelectorAll(\".timeline-connector\");\n    // Should have connectors for all items except the last one\n    expect(connectors).toHaveLength(mockItems.length - 1);\n});\n\ntest(\"does not show connector for last item\", () => {\n    const singleItem = [{ id: \"1\", title: \"Only Event\" }];\n    const { container } = render(<Timeline items={singleItem} />);\n\n    const connectors = container.querySelectorAll(\".timeline-connector\");\n    expect(connectors).toHaveLength(0);\n});\n\ntest(\"has proper accessibility attributes\", () => {\n    render(<Timeline items={mockItems} />);\n\n    expect(screen.getByRole(\"list\")).toBeInTheDocument();\n    expect(screen.getAllByRole(\"listitem\")).toHaveLength(3);\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface TimelineItem {\n    id: string;\n    title: string;\n    description?: string;\n    timestamp?: string;\n    icon?: React.ReactNode;\n    variant?: \"default\" | \"success\" | \"warning\" | \"error\" | \"info\";\n    content?: React.ReactNode;\n}\n\nexport interface TimelineProps extends React.HTMLAttributes<HTMLDivElement> {\n    items: TimelineItem[];\n    orientation?: \"vertical\" | \"horizontal\";\n    alternate?: boolean;\n    size?: \"sm\" | \"md\" | \"lg\";\n}\n\nconst classesBySize: Record<NonNullable<TimelineProps[\"size\"]>, string> = {\n    sm: \"timeline-sm\",\n    md: \"timeline-md\",\n    lg: \"timeline-lg\",\n};\n\nconst classesByItemVariant: Record<NonNullable<TimelineItem[\"variant\"]>, string> = {\n    default: \"timeline-item-default\",\n    success: \"timeline-item-success\",\n    warning: \"timeline-item-warning\",\n    error: \"timeline-item-error\",\n    info: \"timeline-item-info\",\n};\n\nexport const Timeline = React.forwardRef<HTMLDivElement, TimelineProps>(\n    ({\n        items,\n        orientation = \"vertical\",\n        alternate = false,\n        size = \"md\",\n        className,\n        ...rest\n    }, ref) => {\n        const classes = `timeline timeline-${orientation} ${alternate ? \"timeline-alternate\" : \"\"\n            } ${classesBySize[size]} ${className || \"\"}`.trim();\n\n        return (\n            <div {...rest} ref={ref} className={classes} role=\"list\">\n                {items.map((item, index) => {\n                    const isLast = index === items.length - 1;\n                    const itemVariant = item.variant || \"default\";\n                    const isAlternate = alternate && index % 2 === 1;\n\n                    return (\n                        <div\n                            key={item.id}\n                            className={`timeline-item ${classesByItemVariant[itemVariant]} ${isAlternate ? \"timeline-item-alternate\" : \"\"\n                                }`}\n                            role=\"listitem\"\n                        >\n                            {/* Timeline dot and connector */}\n                            <div className=\"timeline-separator\">\n                                <div className={`timeline-dot timeline-dot-${itemVariant}`}>\n                                    {item.icon || <div className=\"timeline-dot-inner\" />}\n                                </div>\n                                {!isLast && (\n                                    <div className=\"timeline-connector\" />\n                                )}\n                            </div>\n\n                            {/* Timeline content */}\n                            <div className=\"timeline-content\">\n                                <div className=\"timeline-header\">\n                                    <h3 className=\"timeline-title\">{item.title}</h3>\n                                    {item.timestamp && (\n                                        <time className=\"timeline-timestamp\" dateTime={item.timestamp}>\n                                            {item.timestamp}\n                                        </time>\n                                    )}\n                                </div>\n\n                                {item.description && (\n                                    <p className=\"timeline-description\">{item.description}</p>\n                                )}\n\n                                {item.content && (\n                                    <div className=\"timeline-item-content\">\n                                        {item.content}\n                                    </div>\n                                )}\n                            </div>\n                        </div>\n                    );\n                })}\n            </div>\n        );\n    }\n);\nTimeline.displayName = \"Timeline\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Timeline } from \"../Timeline\";\n\nconst mockItems = [\n    {\n        id: \"1\",\n        title: \"First Event\",\n        description: \"This is the first event\",\n        timestamp: \"2024-01-01\",\n        variant: \"success\" as const,\n    },\n    {\n        id: \"2\",\n        title: \"Second Event\",\n        description: \"This is the second event\",\n        timestamp: \"2024-01-02\",\n        variant: \"warning\" as const,\n        icon: <span>📅</span>,\n    },\n    {\n        id: \"3\",\n        title: \"Third Event\",\n        content: <div>Custom content</div>,\n    },\n];\n\ntest(\"renders timeline items\", () => {\n    render(<Timeline items={mockItems} />);\n\n    expect(screen.getByText(\"First Event\")).toBeInTheDocument();\n    expect(screen.getByText(\"Second Event\")).toBeInTheDocument();\n    expect(screen.getByText(\"Third Event\")).toBeInTheDocument();\n});\n\ntest(\"shows descriptions when provided\", () => {\n    render(<Timeline items={mockItems} />);\n\n    expect(screen.getByText(\"This is the first event\")).toBeInTheDocument();\n    expect(screen.getByText(\"This is the second event\")).toBeInTheDocument();\n});\n\ntest(\"shows timestamps when provided\", () => {\n    render(<Timeline items={mockItems} />);\n\n    const timestamps = screen.getAllByText(/2024-01-0[12]/);\n    expect(timestamps).toHaveLength(2);\n\n    timestamps.forEach(timestamp => {\n        expect(timestamp.tagName).toBe(\"TIME\");\n        expect(timestamp).toHaveAttribute(\"datetime\");\n    });\n});\n\ntest(\"renders custom icons\", () => {\n    render(<Timeline items={mockItems} />);\n    expect(screen.getByText(\"📅\")).toBeInTheDocument();\n});\n\ntest(\"renders custom content\", () => {\n    render(<Timeline items={mockItems} />);\n    expect(screen.getByText(\"Custom content\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes to timeline items\", () => {\n    const { container } = render(<Timeline items={mockItems} />);\n\n    const items = container.querySelectorAll(\".timeline-item\");\n    expect(items[0]).toHaveClass(\"timeline-item-success\");\n    expect(items[1]).toHaveClass(\"timeline-item-warning\");\n    expect(items[2]).toHaveClass(\"timeline-item-default\");\n});\n\ntest(\"applies variant classes to timeline dots\", () => {\n    const { container } = render(<Timeline items={mockItems} />);\n\n    const dots = container.querySelectorAll(\".timeline-dot\");\n    expect(dots[0]).toHaveClass(\"timeline-dot-success\");\n    expect(dots[1]).toHaveClass(\"timeline-dot-warning\");\n    expect(dots[2]).toHaveClass(\"timeline-dot-default\");\n});\n\ntest(\"applies orientation classes\", () => {\n    const { container } = render(<Timeline items={mockItems} orientation=\"horizontal\" />);\n    expect(container.firstChild).toHaveClass(\"timeline-horizontal\");\n});\n\ntest(\"applies alternate classes when enabled\", () => {\n    const { container } = render(<Timeline items={mockItems} alternate />);\n\n    expect(container.firstChild).toHaveClass(\"timeline-alternate\");\n\n    const items = container.querySelectorAll(\".timeline-item\");\n    expect(items[0]).not.toHaveClass(\"timeline-item-alternate\");\n    expect(items[1]).toHaveClass(\"timeline-item-alternate\");\n    expect(items[2]).not.toHaveClass(\"timeline-item-alternate\");\n});\n\ntest(\"applies size classes\", () => {\n    const { container } = render(<Timeline items={mockItems} size=\"lg\" />);\n    expect(container.firstChild).toHaveClass(\"timeline-lg\");\n});\n\ntest(\"shows connectors between items\", () => {\n    const { container } = render(<Timeline items={mockItems} />);\n\n    const connectors = container.querySelectorAll(\".timeline-connector\");\n    // Should have connectors for all items except the last one\n    expect(connectors).toHaveLength(mockItems.length - 1);\n});\n\ntest(\"does not show connector for last item\", () => {\n    const singleItem = [{ id: \"1\", title: \"Only Event\" }];\n    const { container } = render(<Timeline items={singleItem} />);\n\n    const connectors = container.querySelectorAll(\".timeline-connector\");\n    expect(connectors).toHaveLength(0);\n});\n\ntest(\"has proper accessibility attributes\", () => {\n    render(<Timeline items={mockItems} />);\n\n    expect(screen.getByRole(\"list\")).toBeInTheDocument();\n    expect(screen.getAllByRole(\"listitem\")).toHaveLength(3);\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface TimelineItem {\n    id: string;\n    title: string;\n    description?: string;\n    timestamp?: string;\n    icon?: React.ReactNode;\n    variant?: \"default\" | \"success\" | \"warning\" | \"error\" | \"info\";\n    content?: React.ReactNode;\n}\n\nexport interface TimelineProps extends React.HTMLAttributes<HTMLDivElement> {\n    items: TimelineItem[];\n    orientation?: \"vertical\" | \"horizontal\";\n    alternate?: boolean;\n    size?: \"sm\" | \"md\" | \"lg\";\n}\n\nconst classesBySize: Record<NonNullable<TimelineProps[\"size\"]>, string> = {\n    sm: \"timeline-sm\",\n    md: \"timeline-md\",\n    lg: \"timeline-lg\",\n};\n\nconst classesByItemVariant: Record<NonNullable<TimelineItem[\"variant\"]>, string> = {\n    default: \"timeline-item-default\",\n    success: \"timeline-item-success\",\n    warning: \"timeline-item-warning\",\n    error: \"timeline-item-error\",\n    info: \"timeline-item-info\",\n};\n\nexport const Timeline = React.forwardRef<HTMLDivElement, TimelineProps>(\n    ({\n        items,\n        orientation = \"vertical\",\n        alternate = false,\n        size = \"md\",\n        className,\n        ...rest\n    }, ref) => {\n        const classes = `timeline timeline-${orientation} ${alternate ? \"timeline-alternate\" : \"\"\n            } ${classesBySize[size]} ${className || \"\"}`.trim();\n\n        return (\n            <div {...rest} ref={ref} className={classes} role=\"list\">\n                {items.map((item, index) => {\n                    const isLast = index === items.length - 1;\n                    const itemVariant = item.variant || \"default\";\n                    const isAlternate = alternate && index % 2 === 1;\n\n                    return (\n                        <div\n                            key={item.id}\n                            className={`timeline-item ${classesByItemVariant[itemVariant]} ${isAlternate ? \"timeline-item-alternate\" : \"\"\n                                }`}\n                            role=\"listitem\"\n                        >\n                            {/* Timeline dot and connector */}\n                            <div className=\"timeline-separator\">\n                                <div className={`timeline-dot timeline-dot-${itemVariant}`}>\n                                    {item.icon || <div className=\"timeline-dot-inner\" />}\n                                </div>\n                                {!isLast && (\n                                    <div className=\"timeline-connector\" />\n                                )}\n                            </div>\n\n                            {/* Timeline content */}\n                            <div className=\"timeline-content\">\n                                <div className=\"timeline-header\">\n                                    <h3 className=\"timeline-title\">{item.title}</h3>\n                                    {item.timestamp && (\n                                        <time className=\"timeline-timestamp\" dateTime={item.timestamp}>\n                                            {item.timestamp}\n                                        </time>\n                                    )}\n                                </div>\n\n                                {item.description && (\n                                    <p className=\"timeline-description\">{item.description}</p>\n                                )}\n\n                                {item.content && (\n                                    <div className=\"timeline-item-content\">\n                                        {item.content}\n                                    </div>\n                                )}\n                            </div>\n                        </div>\n                    );\n                })}\n            </div>\n        );\n    }\n);\nTimeline.displayName = \"Timeline\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport { Timeline } from \"../Timeline\";\n\nconst mockItems = [\n    {\n        id: \"1\",\n        title: \"First Event\",\n        description: \"This is the first event\",\n        timestamp: \"2024-01-01\",\n        variant: \"success\" as const,\n    },\n    {\n        id: \"2\",\n        title: \"Second Event\",\n        description: \"This is the second event\",\n        timestamp: \"2024-01-02\",\n        variant: \"warning\" as const,\n        icon: <span>📅</span>,\n    },\n    {\n        id: \"3\",\n        title: \"Third Event\",\n        content: <div>Custom content</div>,\n    },\n];\n\ntest(\"renders timeline items\", () => {\n    render(<Timeline items={mockItems} />);\n\n    expect(screen.getByText(\"First Event\")).toBeInTheDocument();\n    expect(screen.getByText(\"Second Event\")).toBeInTheDocument();\n    expect(screen.getByText(\"Third Event\")).toBeInTheDocument();\n});\n\ntest(\"shows descriptions when provided\", () => {\n    render(<Timeline items={mockItems} />);\n\n    expect(screen.getByText(\"This is the first event\")).toBeInTheDocument();\n    expect(screen.getByText(\"This is the second event\")).toBeInTheDocument();\n});\n\ntest(\"shows timestamps when provided\", () => {\n    render(<Timeline items={mockItems} />);\n\n    const timestamps = screen.getAllByText(/2024-01-0[12]/);\n    expect(timestamps).toHaveLength(2);\n\n    timestamps.forEach(timestamp => {\n        expect(timestamp.tagName).toBe(\"TIME\");\n        expect(timestamp).toHaveAttribute(\"datetime\");\n    });\n});\n\ntest(\"renders custom icons\", () => {\n    render(<Timeline items={mockItems} />);\n    expect(screen.getByText(\"📅\")).toBeInTheDocument();\n});\n\ntest(\"renders custom content\", () => {\n    render(<Timeline items={mockItems} />);\n    expect(screen.getByText(\"Custom content\")).toBeInTheDocument();\n});\n\ntest(\"applies variant classes to timeline items\", () => {\n    const { container } = render(<Timeline items={mockItems} />);\n\n    const items = container.querySelectorAll(\".timeline-item\");\n    expect(items[0]).toHaveClass(\"timeline-item-success\");\n    expect(items[1]).toHaveClass(\"timeline-item-warning\");\n    expect(items[2]).toHaveClass(\"timeline-item-default\");\n});\n\ntest(\"applies variant classes to timeline dots\", () => {\n    const { container } = render(<Timeline items={mockItems} />);\n\n    const dots = container.querySelectorAll(\".timeline-dot\");\n    expect(dots[0]).toHaveClass(\"timeline-dot-success\");\n    expect(dots[1]).toHaveClass(\"timeline-dot-warning\");\n    expect(dots[2]).toHaveClass(\"timeline-dot-default\");\n});\n\ntest(\"applies orientation classes\", () => {\n    const { container } = render(<Timeline items={mockItems} orientation=\"horizontal\" />);\n    expect(container.firstChild).toHaveClass(\"timeline-horizontal\");\n});\n\ntest(\"applies alternate classes when enabled\", () => {\n    const { container } = render(<Timeline items={mockItems} alternate />);\n\n    expect(container.firstChild).toHaveClass(\"timeline-alternate\");\n\n    const items = container.querySelectorAll(\".timeline-item\");\n    expect(items[0]).not.toHaveClass(\"timeline-item-alternate\");\n    expect(items[1]).toHaveClass(\"timeline-item-alternate\");\n    expect(items[2]).not.toHaveClass(\"timeline-item-alternate\");\n});\n\ntest(\"applies size classes\", () => {\n    const { container } = render(<Timeline items={mockItems} size=\"lg\" />);\n    expect(container.firstChild).toHaveClass(\"timeline-lg\");\n});\n\ntest(\"shows connectors between items\", () => {\n    const { container } = render(<Timeline items={mockItems} />);\n\n    const connectors = container.querySelectorAll(\".timeline-connector\");\n    // Should have connectors for all items except the last one\n    expect(connectors).toHaveLength(mockItems.length - 1);\n});\n\ntest(\"does not show connector for last item\", () => {\n    const singleItem = [{ id: \"1\", title: \"Only Event\" }];\n    const { container } = render(<Timeline items={singleItem} />);\n\n    const connectors = container.querySelectorAll(\".timeline-connector\");\n    expect(connectors).toHaveLength(0);\n});\n\ntest(\"has proper accessibility attributes\", () => {\n    render(<Timeline items={mockItems} />);\n\n    expect(screen.getByRole(\"list\")).toBeInTheDocument();\n    expect(screen.getAllByRole(\"listitem\")).toHaveLength(3);\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface ToggleProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, \"size\"> {\n    label?: string;\n    helperText?: string;\n    size?: \"sm\" | \"md\" | \"lg\";\n    variant?: \"default\" | \"success\" | \"warning\" | \"danger\";\n    labelPosition?: \"left\" | \"right\";\n    showLabels?: boolean;\n    onLabel?: string;\n    offLabel?: string;\n}\n\nconst classesBySize: Record<NonNullable<ToggleProps[\"size\"]>, string> = {\n    sm: \"toggle-sm\",\n    md: \"toggle-md\",\n    lg: \"toggle-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<ToggleProps[\"variant\"]>, string> = {\n    default: \"toggle-default\",\n    success: \"toggle-success\",\n    warning: \"toggle-warning\",\n    danger: \"toggle-danger\",\n};\n\nexport const Toggle = React.forwardRef<HTMLInputElement, ToggleProps>(\n    ({\n        label,\n        helperText,\n        size = \"md\",\n        variant = \"default\",\n        labelPosition = \"right\",\n        showLabels = false,\n        onLabel = \"On\",\n        offLabel = \"Off\",\n        className,\n        disabled,\n        checked,\n        id,\n        ...rest\n    }, ref) => {\n        const toggleId = id || React.useId();\n        const helperTextId = helperText ? `${toggleId}-helper` : undefined;\n\n        const toggleClasses = `toggle ${classesBySize[size]} ${classesByVariant[variant]} ${disabled ? \"toggle-disabled\" : \"\"\n            } ${className || \"\"}`.trim();\n\n        const toggleElement = (\n            <div className={toggleClasses}>\n                <input\n                    {...rest}\n                    ref={ref}\n                    type=\"checkbox\"\n                    id={toggleId}\n                    className=\"toggle-input\"\n                    disabled={disabled}\n                    checked={checked}\n                    aria-describedby={helperTextId}\n                />\n                <div className=\"toggle-track\">\n                    <div className=\"toggle-thumb\" />\n                    {showLabels && (\n                        <>\n                            <span className=\"toggle-label-on\" aria-hidden=\"true\">\n                                {onLabel}\n                            </span>\n                            <span className=\"toggle-label-off\" aria-hidden=\"true\">\n                                {offLabel}\n                            </span>\n                        </>\n                    )}\n                </div>\n            </div>\n        );\n\n        if (!label && !helperText) {\n            return toggleElement;\n        }\n\n        return (\n            <div className=\"toggle-wrapper\">\n                <div className={`toggle-container toggle-label-${labelPosition}`}>\n                    {label && labelPosition === \"left\" && (\n                        <label htmlFor={toggleId} className=\"toggle-label\">\n                            {label}\n                        </label>\n                    )}\n                    {toggleElement}\n                    {label && labelPosition === \"right\" && (\n                        <label htmlFor={toggleId} className=\"toggle-label\">\n                            {label}\n                        </label>\n                    )}\n                </div>\n                {helperText && (\n                    <div id={helperTextId} className=\"toggle-helper-text\">\n                        {helperText}\n                    </div>\n                )}\n            </div>\n        );\n    }\n);\nToggle.displayName = \"Toggle\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Toggle } from \"../Toggle\";\n\ntest(\"renders toggle input\", () => {\n    render(<Toggle />);\n    expect(screen.getByRole(\"checkbox\")).toBeInTheDocument();\n});\n\ntest(\"renders with label\", () => {\n    render(<Toggle label=\"Enable notifications\" />);\n    expect(screen.getByLabelText(\"Enable notifications\")).toBeInTheDocument();\n});\n\ntest(\"handles toggle interaction\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Toggle onChange={onChange} />);\n\n    const toggle = screen.getByRole(\"checkbox\");\n    await user.click(toggle);\n\n    expect(onChange).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows checked state\", () => {\n    render(<Toggle checked />);\n    const toggle = screen.getByRole(\"checkbox\");\n    expect(toggle).toBeChecked();\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Toggle disabled onChange={onChange} />);\n\n    const toggle = screen.getByRole(\"checkbox\");\n    expect(toggle).toBeDisabled();\n\n    await user.click(toggle);\n    expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"shows helper text\", () => {\n    render(<Toggle helperText=\"Toggle to enable feature\" />);\n    expect(screen.getByText(\"Toggle to enable feature\")).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n    const { container } = render(<Toggle size=\"lg\" />);\n    expect(container.querySelector(\".toggle\")).toHaveClass(\"toggle-lg\");\n});\n\ntest(\"applies variant classes\", () => {\n    const { container } = render(<Toggle variant=\"success\" />);\n    expect(container.querySelector(\".toggle\")).toHaveClass(\"toggle-success\");\n});\n\ntest(\"shows on/off labels when enabled\", () => {\n    render(<Toggle showLabels onLabel=\"YES\" offLabel=\"NO\" />);\n    expect(screen.getByText(\"YES\")).toBeInTheDocument();\n    expect(screen.getByText(\"NO\")).toBeInTheDocument();\n});\n\ntest(\"positions label correctly\", () => {\n    const { container } = render(<Toggle label=\"Left label\" labelPosition=\"left\" />);\n    expect(container.querySelector(\".toggle-label-left\")).toBeInTheDocument();\n});\n\ntest(\"associates helper text with input\", () => {\n    render(<Toggle helperText=\"Helper text\" />);\n    const toggle = screen.getByRole(\"checkbox\");\n    const helperText = screen.getByText(\"Helper text\");\n\n    expect(toggle).toHaveAttribute(\"aria-describedby\", helperText.id);\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface ToggleProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, \"size\"> {\n    label?: string;\n    helperText?: string;\n    size?: \"sm\" | \"md\" | \"lg\";\n    variant?: \"default\" | \"success\" | \"warning\" | \"danger\";\n    labelPosition?: \"left\" | \"right\";\n    showLabels?: boolean;\n    onLabel?: string;\n    offLabel?: string;\n}\n\nconst classesBySize: Record<NonNullable<ToggleProps[\"size\"]>, string> = {\n    sm: \"toggle-sm\",\n    md: \"toggle-md\",\n    lg: \"toggle-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<ToggleProps[\"variant\"]>, string> = {\n    default: \"toggle-default\",\n    success: \"toggle-success\",\n    warning: \"toggle-warning\",\n    danger: \"toggle-danger\",\n};\n\nexport const Toggle = React.forwardRef<HTMLInputElement, ToggleProps>(\n    ({\n        label,\n        helperText,\n        size = \"md\",\n        variant = \"default\",\n        labelPosition = \"right\",\n        showLabels = false,\n        onLabel = \"On\",\n        offLabel = \"Off\",\n        className,\n        disabled,\n        checked,\n        id,\n        ...rest\n    }, ref) => {\n        const toggleId = id || React.useId();\n        const helperTextId = helperText ? `${toggleId}-helper` : undefined;\n\n        const toggleClasses = `toggle ${classesBySize[size]} ${classesByVariant[variant]} ${disabled ? \"toggle-disabled\" : \"\"\n            } ${className || \"\"}`.trim();\n\n        const toggleElement = (\n            <div className={toggleClasses}>\n                <input\n                    {...rest}\n                    ref={ref}\n                    type=\"checkbox\"\n                    id={toggleId}\n                    className=\"toggle-input\"\n                    disabled={disabled}\n                    checked={checked}\n                    aria-describedby={helperTextId}\n                />\n                <div className=\"toggle-track\">\n                    <div className=\"toggle-thumb\" />\n                    {showLabels && (\n                        <>\n                            <span className=\"toggle-label-on\" aria-hidden=\"true\">\n                                {onLabel}\n                            </span>\n                            <span className=\"toggle-label-off\" aria-hidden=\"true\">\n                                {offLabel}\n                            </span>\n                        </>\n                    )}\n                </div>\n            </div>\n        );\n\n        if (!label && !helperText) {\n            return toggleElement;\n        }\n\n        return (\n            <div className=\"toggle-wrapper\">\n                <div className={`toggle-container toggle-label-${labelPosition}`}>\n                    {label && labelPosition === \"left\" && (\n                        <label htmlFor={toggleId} className=\"toggle-label\">\n                            {label}\n                        </label>\n                    )}\n                    {toggleElement}\n                    {label && labelPosition === \"right\" && (\n                        <label htmlFor={toggleId} className=\"toggle-label\">\n                            {label}\n                        </label>\n                    )}\n                </div>\n                {helperText && (\n                    <div id={helperTextId} className=\"toggle-helper-text\">\n                        {helperText}\n                    </div>\n                )}\n            </div>\n        );\n    }\n);\nToggle.displayName = \"Toggle\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Toggle } from \"../Toggle\";\n\ntest(\"renders toggle input\", () => {\n    render(<Toggle />);\n    expect(screen.getByRole(\"checkbox\")).toBeInTheDocument();\n});\n\ntest(\"renders with label\", () => {\n    render(<Toggle label=\"Enable notifications\" />);\n    expect(screen.getByLabelText(\"Enable notifications\")).toBeInTheDocument();\n});\n\ntest(\"handles toggle interaction\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Toggle onChange={onChange} />);\n\n    const toggle = screen.getByRole(\"checkbox\");\n    await user.click(toggle);\n\n    expect(onChange).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows checked state\", () => {\n    render(<Toggle checked />);\n    const toggle = screen.getByRole(\"checkbox\");\n    expect(toggle).toBeChecked();\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Toggle disabled onChange={onChange} />);\n\n    const toggle = screen.getByRole(\"checkbox\");\n    expect(toggle).toBeDisabled();\n\n    await user.click(toggle);\n    expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"shows helper text\", () => {\n    render(<Toggle helperText=\"Toggle to enable feature\" />);\n    expect(screen.getByText(\"Toggle to enable feature\")).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n    const { container } = render(<Toggle size=\"lg\" />);\n    expect(container.querySelector(\".toggle\")).toHaveClass(\"toggle-lg\");\n});\n\ntest(\"applies variant classes\", () => {\n    const { container } = render(<Toggle variant=\"success\" />);\n    expect(container.querySelector(\".toggle\")).toHaveClass(\"toggle-success\");\n});\n\ntest(\"shows on/off labels when enabled\", () => {\n    render(<Toggle showLabels onLabel=\"YES\" offLabel=\"NO\" />);\n    expect(screen.getByText(\"YES\")).toBeInTheDocument();\n    expect(screen.getByText(\"NO\")).toBeInTheDocument();\n});\n\ntest(\"positions label correctly\", () => {\n    const { container } = render(<Toggle label=\"Left label\" labelPosition=\"left\" />);\n    expect(container.querySelector(\".toggle-label-left\")).toBeInTheDocument();\n});\n\ntest(\"associates helper text with input\", () => {\n    render(<Toggle helperText=\"Helper text\" />);\n    const toggle = screen.getByRole(\"checkbox\");\n    const helperText = screen.getByText(\"Helper text\");\n\n    expect(toggle).toHaveAttribute(\"aria-describedby\", helperText.id);\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface ToggleProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, \"size\"> {\n    label?: string;\n    helperText?: string;\n    size?: \"sm\" | \"md\" | \"lg\";\n    variant?: \"default\" | \"success\" | \"warning\" | \"danger\";\n    labelPosition?: \"left\" | \"right\";\n    showLabels?: boolean;\n    onLabel?: string;\n    offLabel?: string;\n}\n\nconst classesBySize: Record<NonNullable<ToggleProps[\"size\"]>, string> = {\n    sm: \"toggle-sm\",\n    md: \"toggle-md\",\n    lg: \"toggle-lg\",\n};\n\nconst classesByVariant: Record<NonNullable<ToggleProps[\"variant\"]>, string> = {\n    default: \"toggle-default\",\n    success: \"toggle-success\",\n    warning: \"toggle-warning\",\n    danger: \"toggle-danger\",\n};\n\nexport const Toggle = React.forwardRef<HTMLInputElement, ToggleProps>(\n    ({\n        label,\n        helperText,\n        size = \"md\",\n        variant = \"default\",\n        labelPosition = \"right\",\n        showLabels = false,\n        onLabel = \"On\",\n        offLabel = \"Off\",\n        className,\n        disabled,\n        checked,\n        id,\n        ...rest\n    }, ref) => {\n        const toggleId = id || React.useId();\n        const helperTextId = helperText ? `${toggleId}-helper` : undefined;\n\n        const toggleClasses = `toggle ${classesBySize[size]} ${classesByVariant[variant]} ${disabled ? \"toggle-disabled\" : \"\"\n            } ${className || \"\"}`.trim();\n\n        const toggleElement = (\n            <div className={toggleClasses}>\n                <input\n                    {...rest}\n                    ref={ref}\n                    type=\"checkbox\"\n                    id={toggleId}\n                    className=\"toggle-input\"\n                    disabled={disabled}\n                    checked={checked}\n                    aria-describedby={helperTextId}\n                />\n                <div className=\"toggle-track\">\n                    <div className=\"toggle-thumb\" />\n                    {showLabels && (\n                        <>\n                            <span className=\"toggle-label-on\" aria-hidden=\"true\">\n                                {onLabel}\n                            </span>\n                            <span className=\"toggle-label-off\" aria-hidden=\"true\">\n                                {offLabel}\n                            </span>\n                        </>\n                    )}\n                </div>\n            </div>\n        );\n\n        if (!label && !helperText) {\n            return toggleElement;\n        }\n\n        return (\n            <div className=\"toggle-wrapper\">\n                <div className={`toggle-container toggle-label-${labelPosition}`}>\n                    {label && labelPosition === \"left\" && (\n                        <label htmlFor={toggleId} className=\"toggle-label\">\n                            {label}\n                        </label>\n                    )}\n                    {toggleElement}\n                    {label && labelPosition === \"right\" && (\n                        <label htmlFor={toggleId} className=\"toggle-label\">\n                            {label}\n                        </label>\n                    )}\n                </div>\n                {helperText && (\n                    <div id={helperTextId} className=\"toggle-helper-text\">\n                        {helperText}\n                    </div>\n                )}\n            </div>\n        );\n    }\n);\nToggle.displayName = \"Toggle\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Toggle } from \"../Toggle\";\n\ntest(\"renders toggle input\", () => {\n    render(<Toggle />);\n    expect(screen.getByRole(\"checkbox\")).toBeInTheDocument();\n});\n\ntest(\"renders with label\", () => {\n    render(<Toggle label=\"Enable notifications\" />);\n    expect(screen.getByLabelText(\"Enable notifications\")).toBeInTheDocument();\n});\n\ntest(\"handles toggle interaction\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Toggle onChange={onChange} />);\n\n    const toggle = screen.getByRole(\"checkbox\");\n    await user.click(toggle);\n\n    expect(onChange).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows checked state\", () => {\n    render(<Toggle checked />);\n    const toggle = screen.getByRole(\"checkbox\");\n    expect(toggle).toBeChecked();\n});\n\ntest(\"is disabled when disabled prop is true\", async () => {\n    const user = userEvent.setup();\n    const onChange = vi.fn();\n    render(<Toggle disabled onChange={onChange} />);\n\n    const toggle = screen.getByRole(\"checkbox\");\n    expect(toggle).toBeDisabled();\n\n    await user.click(toggle);\n    expect(onChange).not.toHaveBeenCalled();\n});\n\ntest(\"shows helper text\", () => {\n    render(<Toggle helperText=\"Toggle to enable feature\" />);\n    expect(screen.getByText(\"Toggle to enable feature\")).toBeInTheDocument();\n});\n\ntest(\"applies size classes\", () => {\n    const { container } = render(<Toggle size=\"lg\" />);\n    expect(container.querySelector(\".toggle\")).toHaveClass(\"toggle-lg\");\n});\n\ntest(\"applies variant classes\", () => {\n    const { container } = render(<Toggle variant=\"success\" />);\n    expect(container.querySelector(\".toggle\")).toHaveClass(\"toggle-success\");\n});\n\ntest(\"shows on/off labels when enabled\", () => {\n    render(<Toggle showLabels onLabel=\"YES\" offLabel=\"NO\" />);\n    expect(screen.getByText(\"YES\")).toBeInTheDocument();\n    expect(screen.getByText(\"NO\")).toBeInTheDocument();\n});\n\ntest(\"positions label correctly\", () => {\n    const { container } = render(<Toggle label=\"Left label\" labelPosition=\"left\" />);\n    expect(container.querySelector(\".toggle-label-left\")).toBeInTheDocument();\n});\n\ntest(\"associates helper text with input\", () => {\n    render(<Toggle helperText=\"Helper text\" />);\n    const toggle = screen.getByRole(\"checkbox\");\n    const helperText = screen.getByText(\"Helper text\");\n\n    expect(toggle).toHaveAttribute(\"aria-describedby\", helperText.id);\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\ntype TooltipPlacement = \"top\" | \"bottom\" | \"left\" | \"right\";\n\nexport interface TooltipProps {\n    content: React.ReactNode;\n    placement?: TooltipPlacement;\n    delay?: number;\n    children: React.ReactElement;\n}\n\nexport const Tooltip: React.FC<TooltipProps> = ({\n    content,\n    placement = \"top\",\n    delay = 500,\n    children\n}) => {\n    const [isVisible, setIsVisible] = React.useState(false);\n    const timeoutRef = React.useRef<NodeJS.Timeout>();\n    const tooltipId = React.useId();\n\n    const showTooltip = () => {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(() => {\n            setIsVisible(true);\n        }, delay);\n    };\n\n    const hideTooltip = () => {\n        clearTimeout(timeoutRef.current);\n        setIsVisible(false);\n    };\n\n    React.useEffect(() => {\n        return () => {\n            clearTimeout(timeoutRef.current);\n        };\n    }, []);\n\n    const child = React.cloneElement(children, {\n        onMouseEnter: showTooltip,\n        onMouseLeave: hideTooltip,\n        onFocus: showTooltip,\n        onBlur: hideTooltip,\n        'aria-describedby': isVisible ? tooltipId : undefined,\n    });\n\n    return (\n        <div className=\"tooltip-container\">\n            {child}\n            {isVisible && (\n                <div\n                    id={tooltipId}\n                    role=\"tooltip\"\n                    className={`tooltip tooltip-${placement}`}\n                >\n                    {content}\n                </div>\n            )}\n        </div>\n    );\n};",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Tooltip } from \"../Tooltip\";\n\ntest(\"shows tooltip on hover\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Tooltip text\">\n            <button>Hover me</button>\n        </Tooltip>\n    );\n\n    const button = screen.getByRole(\"button\", { name: /hover me/i });\n    await user.hover(button);\n\n    // Wait for delay\n    await new Promise(resolve => setTimeout(resolve, 600));\n\n    expect(screen.getByRole(\"tooltip\")).toHaveTextContent(\"Tooltip text\");\n});\n\ntest(\"hides tooltip on mouse leave\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Tooltip text\" delay={0}>\n            <button>Hover me</button>\n        </Tooltip>\n    );\n\n    const button = screen.getByRole(\"button\");\n    await user.hover(button);\n    await user.unhover(button);\n\n    expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"shows tooltip on focus\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Tooltip text\" delay={0}>\n            <button>Focus me</button>\n        </Tooltip>\n    );\n\n    await user.tab();\n    expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n});\n\ntest(\"applies placement class\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Bottom tooltip\" placement=\"bottom\" delay={0}>\n            <button>Button</button>\n        </Tooltip>\n    );\n\n    await user.hover(screen.getByRole(\"button\"));\n    expect(screen.getByRole(\"tooltip\")).toHaveClass(\"tooltip-bottom\");\n});\n\ntest(\"adds aria-describedby when visible\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Description\" delay={0}>\n            <button>Button</button>\n        </Tooltip>\n    );\n\n    const button = screen.getByRole(\"button\");\n    await user.hover(button);\n    expect(button).toHaveAttribute(\"aria-describedby\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\ntype TooltipPlacement = \"top\" | \"bottom\" | \"left\" | \"right\";\n\nexport interface TooltipProps {\n    content: React.ReactNode;\n    placement?: TooltipPlacement;\n    delay?: number;\n    children: React.ReactElement;\n}\n\nexport const Tooltip: React.FC<TooltipProps> = ({\n    content,\n    placement = \"top\",\n    delay = 500,\n    children\n}) => {\n    const [isVisible, setIsVisible] = React.useState(false);\n    const timeoutRef = React.useRef<NodeJS.Timeout>();\n    const tooltipId = React.useId();\n\n    const showTooltip = () => {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(() => {\n            setIsVisible(true);\n        }, delay);\n    };\n\n    const hideTooltip = () => {\n        clearTimeout(timeoutRef.current);\n        setIsVisible(false);\n    };\n\n    React.useEffect(() => {\n        return () => {\n            clearTimeout(timeoutRef.current);\n        };\n    }, []);\n\n    const child = React.cloneElement(children, {\n        onMouseEnter: showTooltip,\n        onMouseLeave: hideTooltip,\n        onFocus: showTooltip,\n        onBlur: hideTooltip,\n        'aria-describedby': isVisible ? tooltipId : undefined,\n    });\n\n    return (\n        <div className=\"tooltip-container\">\n            {child}\n            {isVisible && (\n                <div\n                    id={tooltipId}\n                    role=\"tooltip\"\n                    className={`tooltip tooltip-${placement}`}\n                >\n                    {content}\n                </div>\n            )}\n        </div>\n    );\n};",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Tooltip } from \"../Tooltip\";\n\ntest(\"shows tooltip on hover\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Tooltip text\">\n            <button>Hover me</button>\n        </Tooltip>\n    );\n\n    const button = screen.getByRole(\"button\", { name: /hover me/i });\n    await user.hover(button);\n\n    // Wait for delay\n    await new Promise(resolve => setTimeout(resolve, 600));\n\n    expect(screen.getByRole(\"tooltip\")).toHaveTextContent(\"Tooltip text\");\n});\n\ntest(\"hides tooltip on mouse leave\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Tooltip text\" delay={0}>\n            <button>Hover me</button>\n        </Tooltip>\n    );\n\n    const button = screen.getByRole(\"button\");\n    await user.hover(button);\n    await user.unhover(button);\n\n    expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"shows tooltip on focus\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Tooltip text\" delay={0}>\n            <button>Focus me</button>\n        </Tooltip>\n    );\n\n    await user.tab();\n    expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n});\n\ntest(\"applies placement class\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Bottom tooltip\" placement=\"bottom\" delay={0}>\n            <button>Button</button>\n        </Tooltip>\n    );\n\n    await user.hover(screen.getByRole(\"button\"));\n    expect(screen.getByRole(\"tooltip\")).toHaveClass(\"tooltip-bottom\");\n});\n\ntest(\"adds aria-describedby when visible\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Description\" delay={0}>\n            <button>Button</button>\n        </Tooltip>\n    );\n\n    const button = screen.getByRole(\"button\");\n    await user.hover(button);\n    expect(button).toHaveAttribute(\"aria-describedby\");\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\ntype TooltipPlacement = \"top\" | \"bottom\" | \"left\" | \"right\";\n\nexport interface TooltipProps {\n    content: React.ReactNode;\n    placement?: TooltipPlacement;\n    delay?: number;\n    children: React.ReactElement;\n}\n\nexport const Tooltip: React.FC<TooltipProps> = ({\n    content,\n    placement = \"top\",\n    delay = 500,\n    children\n}) => {\n    const [isVisible, setIsVisible] = React.useState(false);\n    const timeoutRef = React.useRef<NodeJS.Timeout>();\n    const tooltipId = React.useId();\n\n    const showTooltip = () => {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(() => {\n            setIsVisible(true);\n        }, delay);\n    };\n\n    const hideTooltip = () => {\n        clearTimeout(timeoutRef.current);\n        setIsVisible(false);\n    };\n\n    React.useEffect(() => {\n        return () => {\n            clearTimeout(timeoutRef.current);\n        };\n    }, []);\n\n    const child = React.cloneElement(children, {\n        onMouseEnter: showTooltip,\n        onMouseLeave: hideTooltip,\n        onFocus: showTooltip,\n        onBlur: hideTooltip,\n        'aria-describedby': isVisible ? tooltipId : undefined,\n    });\n\n    return (\n        <div className=\"tooltip-container\">\n            {child}\n            {isVisible && (\n                <div\n                    id={tooltipId}\n                    role=\"tooltip\"\n                    className={`tooltip tooltip-${placement}`}\n                >\n                    {content}\n                </div>\n            )}\n        </div>\n    );\n};",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Tooltip } from \"../Tooltip\";\n\ntest(\"shows tooltip on hover\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Tooltip text\">\n            <button>Hover me</button>\n        </Tooltip>\n    );\n\n    const button = screen.getByRole(\"button\", { name: /hover me/i });\n    await user.hover(button);\n\n    // Wait for delay\n    await new Promise(resolve => setTimeout(resolve, 600));\n\n    expect(screen.getByRole(\"tooltip\")).toHaveTextContent(\"Tooltip text\");\n});\n\ntest(\"hides tooltip on mouse leave\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Tooltip text\" delay={0}>\n            <button>Hover me</button>\n        </Tooltip>\n    );\n\n    const button = screen.getByRole(\"button\");\n    await user.hover(button);\n    await user.unhover(button);\n\n    expect(screen.queryByRole(\"tooltip\")).not.toBeInTheDocument();\n});\n\ntest(\"shows tooltip on focus\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Tooltip text\" delay={0}>\n            <button>Focus me</button>\n        </Tooltip>\n    );\n\n    await user.tab();\n    expect(screen.getByRole(\"tooltip\")).toBeInTheDocument();\n});\n\ntest(\"applies placement class\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Bottom tooltip\" placement=\"bottom\" delay={0}>\n            <button>Button</button>\n        </Tooltip>\n    );\n\n    await user.hover(screen.getByRole(\"button\"));\n    expect(screen.getByRole(\"tooltip\")).toHaveClass(\"tooltip-bottom\");\n});\n\ntest(\"adds aria-describedby when visible\", async () => {\n    const user = userEvent.setup();\n    render(\n        <Tooltip content=\"Description\" delay={0}>\n            <button>Button</button>\n        </Tooltip>\n    );\n\n    const button = screen.getByRole(\"button\");\n    await user.hover(button);\n    expect(button).toHaveAttribute(\"aria-describedby\");\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface TreeNode {\n  key: string;\n  title: string;\n  children?: TreeNode[];\n  disabled?: boolean;\n  checkable?: boolean;\n  selectable?: boolean;\n  icon?: React.ReactNode;\n  isLeaf?: boolean;\n}\n\nexport interface TreeProps extends React.HTMLAttributes<HTMLDivElement> {\n  treeData: TreeNode[];\n  checkable?: boolean;\n  selectable?: boolean;\n  multiple?: boolean;\n  defaultExpandedKeys?: string[];\n  defaultSelectedKeys?: string[];\n  defaultCheckedKeys?: string[];\n  expandedKeys?: string[];\n  selectedKeys?: string[];\n  checkedKeys?: string[];\n  onExpand?: (expandedKeys: string[], info: { expanded: boolean; node: TreeNode }) => void;\n  onSelect?: (selectedKeys: string[], info: { selected: boolean; node: TreeNode }) => void;\n  onCheck?: (checkedKeys: string[], info: { checked: boolean; node: TreeNode }) => void;\n  showLine?: boolean;\n  showIcon?: boolean;\n  blockNode?: boolean;\n  loadData?: (node: TreeNode) => Promise<void>;\n}\n\nexport const Tree = React.forwardRef<HTMLDivElement, TreeProps>(\n  ({\n    treeData,\n    checkable = false,\n    selectable = true,\n    multiple = false,\n    defaultExpandedKeys = [],\n    defaultSelectedKeys = [],\n    defaultCheckedKeys = [],\n    expandedKeys: controlledExpandedKeys,\n    selectedKeys: controlledSelectedKeys,\n    checkedKeys: controlledCheckedKeys,\n    onExpand,\n    onSelect,\n    onCheck,\n    showLine = false,\n    showIcon = false,\n    blockNode = false,\n    loadData,\n    className,\n    ...rest\n  }, ref) => {\n    const [internalExpandedKeys, setInternalExpandedKeys] = React.useState<string[]>(defaultExpandedKeys);\n    const [internalSelectedKeys, setInternalSelectedKeys] = React.useState<string[]>(defaultSelectedKeys);\n    const [internalCheckedKeys, setInternalCheckedKeys] = React.useState<string[]>(defaultCheckedKeys);\n    const [loadingKeys, setLoadingKeys] = React.useState<string[]>([]);\n\n    const isExpandedControlled = controlledExpandedKeys !== undefined;\n    const isSelectedControlled = controlledSelectedKeys !== undefined;\n    const isCheckedControlled = controlledCheckedKeys !== undefined;\n\n    const expandedKeys = isExpandedControlled ? controlledExpandedKeys : internalExpandedKeys;\n    const selectedKeys = isSelectedControlled ? controlledSelectedKeys : internalSelectedKeys;\n    const checkedKeys = isCheckedControlled ? controlledCheckedKeys : internalCheckedKeys;\n\n    const classes = `tree ${showLine ? \"tree-show-line\" : \"\"} ${\n      blockNode ? \"tree-block-node\" : \"\"\n    } ${className || \"\"}`.trim();\n\n    const updateExpandedKeys = (newKeys: string[], info: { expanded: boolean; node: TreeNode }) => {\n      if (onExpand) {\n        onExpand(newKeys, info);\n      }\n      if (!isExpandedControlled) {\n        setInternalExpandedKeys(newKeys);\n      }\n    };\n\n    const updateSelectedKeys = (newKeys: string[], info: { selected: boolean; node: TreeNode }) => {\n      if (onSelect) {\n        onSelect(newKeys, info);\n      }\n      if (!isSelectedControlled) {\n        setInternalSelectedKeys(newKeys);\n      }\n    };\n\n    const updateCheckedKeys = (newKeys: string[], info: { checked: boolean; node: TreeNode }) => {\n      if (onCheck) {\n        onCheck(newKeys, info);\n      }\n      if (!isCheckedControlled) {\n        setInternalCheckedKeys(newKeys);\n      }\n    };\n\n    const getAllDescendantKeys = (node: TreeNode): string[] => {\n      const keys = [node.key];\n      if (node.children) {\n        node.children.forEach(child => {\n          keys.push(...getAllDescendantKeys(child));\n        });\n      }\n      return keys;\n    };\n\n    const handleExpand = async (node: TreeNode) => {\n      const isExpanded = expandedKeys.includes(node.key);\n      const newExpandedKeys = isExpanded\n        ? expandedKeys.filter(key => key !== node.key)\n        : [...expandedKeys, node.key];\n\n      if (!isExpanded && loadData && (!node.children || node.children.length === 0)) {\n        setLoadingKeys(prev => [...prev, node.key]);\n        try {\n          await loadData(node);\n        } finally {\n          setLoadingKeys(prev => prev.filter(key => key !== node.key));\n        }\n      }\n\n      updateExpandedKeys(newExpandedKeys, { expanded: !isExpanded, node });\n    };\n\n    const handleSelect = (node: TreeNode) => {\n      if (!selectable || node.disabled || (node.selectable === false)) return;\n\n      const isSelected = selectedKeys.includes(node.key);\n      let newSelectedKeys: string[];\n\n      if (multiple) {\n        newSelectedKeys = isSelected\n          ? selectedKeys.filter(key => key !== node.key)\n          : [...selectedKeys, node.key];\n      } else {\n        newSelectedKeys = isSelected ? [] : [node.key];\n      }\n\n      updateSelectedKeys(newSelectedKeys, { selected: !isSelected, node });\n    };\n\n    const handleCheck = (node: TreeNode) => {\n      if (!checkable || node.disabled || (node.checkable === false)) return;\n\n      const isChecked = checkedKeys.includes(node.key);\n      const descendantKeys = getAllDescendantKeys(node);\n      \n      let newCheckedKeys: string[];\n      if (isChecked) {\n        // Uncheck node and all descendants\n        newCheckedKeys = checkedKeys.filter(key => !descendantKeys.includes(key));\n      } else {\n        // Check node and all descendants\n        newCheckedKeys = [...new Set([...checkedKeys, ...descendantKeys])];\n      }\n\n      updateCheckedKeys(newCheckedKeys, { checked: !isChecked, node });\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent, node: TreeNode) => {\n      switch (e.key) {\n        case \"Enter\":\n        case \" \":\n          e.preventDefault();\n          if (checkable && (node.checkable !== false)) {\n            handleCheck(node);\n          } else if (selectable && (node.selectable !== false)) {\n            handleSelect(node);\n          }\n          break;\n        case \"ArrowRight\":\n          e.preventDefault();\n          if (!expandedKeys.includes(node.key) && (node.children || loadData)) {\n            handleExpand(node);\n          }\n          break;\n        case \"ArrowLeft\":\n          e.preventDefault();\n          if (expandedKeys.includes(node.key)) {\n            handleExpand(node);\n          }\n          break;\n      }\n    };\n\n    const renderTreeNode = (node: TreeNode, level: number = 0): React.ReactNode => {\n      const isExpanded = expandedKeys.includes(node.key);\n      const isSelected = selectedKeys.includes(node.key);\n      const isChecked = checkedKeys.includes(node.key);\n      const isLoading = loadingKeys.includes(node.key);\n      const hasChildren = node.children && node.children.length > 0;\n      const canExpand = hasChildren || (loadData && !node.isLeaf);\n\n      return (\n        <div key={node.key} className=\"tree-treenode\" role=\"treeitem\" aria-expanded={canExpand ? isExpanded : undefined}>\n          <div\n            className={`tree-node-content ${isSelected ? \"tree-node-selected\" : \"\"} ${\n              node.disabled ? \"tree-node-disabled\" : \"\"\n            }`}\n            style={{ paddingLeft: `${level * 24}px` }}\n            onClick={() => !node.disabled && handleSelect(node)}\n            onKeyDown={(e) => handleKeyDown(e, node)}\n            tabIndex={0}\n            aria-selected={selectable ? isSelected : undefined}\n            aria-checked={checkable ? isChecked : undefined}\n            aria-disabled={node.disabled}\n          >\n            {canExpand && (\n              <button\n                type=\"button\"\n                className={`tree-switcher ${isExpanded ? \"tree-switcher-open\" : \"tree-switcher-close\"}`}\n                onClick={(e) => {\n                  e.stopPropagation();\n                  handleExpand(node);\n                }}\n                aria-label={isExpanded ? \"Collapse\" : \"Expand\"}\n                disabled={node.disabled}\n              >\n                {isLoading ? \"...\" : isExpanded ? \"−\" : \"+\"}\n              </button>\n            )}\n            \n            {!canExpand && showLine && (\n              <span className=\"tree-switcher tree-switcher-noop\" />\n            )}\n\n            {checkable && node.checkable !== false && (\n              <label className=\"tree-checkbox-wrapper\">\n                <input\n                  type=\"checkbox\"\n                  className=\"tree-checkbox\"\n                  checked={isChecked}\n                  onChange={() => handleCheck(node)}\n                  disabled={node.disabled}\n                  aria-label={`Check ${node.title}`}\n                />\n                <span className=\"tree-checkbox-inner\" />\n              </label>\n            )}\n\n            {showIcon && node.icon && (\n              <span className=\"tree-icon\">{node.icon}</span>\n            )}\n\n            <span className=\"tree-title\">{node.title}</span>\n          </div>\n\n          {hasChildren && isExpanded && (\n            <div className=\"tree-child-tree\" role=\"group\">\n              {node.children!.map(child => renderTreeNode(child, level + 1))}\n            </div>\n          )}\n        </div>\n      );\n    };\n\n    return (\n      <div {...rest} ref={ref} className={classes} role=\"tree\">\n        {treeData.map(node => renderTreeNode(node))}\n      </div>\n    );\n  }\n);\nTree.displayName = \"Tree\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Tree } from \"../Tree\";\n\nconst mockTreeData = [\n  {\n    key: \"parent1\",\n    title: \"Parent 1\",\n    children: [\n      { key: \"child1\", title: \"Child 1\" },\n      { key: \"child2\", title: \"Child 2\" },\n    ],\n  },\n  {\n    key: \"parent2\", \n    title: \"Parent 2\",\n    children: [\n      {\n        key: \"child3\",\n        title: \"Child 3\",\n        children: [\n          { key: \"grandchild1\", title: \"Grandchild 1\" },\n        ],\n      },\n    ],\n  },\n  { key: \"leaf\", title: \"Leaf Node\" },\n];\n\ntest(\"renders tree nodes\", () => {\n  render(<Tree treeData={mockTreeData} />);\n  \n  expect(screen.getByText(\"Parent 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Parent 2\")).toBeInTheDocument();\n  expect(screen.getByText(\"Leaf Node\")).toBeInTheDocument();\n});\n\ntest(\"expands and collapses nodes\", async () => {\n  const user = userEvent.setup();\n  render(<Tree treeData={mockTreeData} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\");\n  const expandButton = parent1.parentElement?.querySelector(\".tree-switcher\");\n  \n  // Initially collapsed\n  expect(screen.queryByText(\"Child 1\")).not.toBeInTheDocument();\n  \n  // Click to expand\n  if (expandButton) {\n    await user.click(expandButton);\n  }\n  expect(screen.getByText(\"Child 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Child 2\")).toBeInTheDocument();\n  \n  // Click to collapse\n  if (expandButton) {\n    await user.click(expandButton);\n  }\n  expect(screen.queryByText(\"Child 1\")).not.toBeInTheDocument();\n});\n\ntest(\"handles node selection\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Tree treeData={mockTreeData} onSelect={onSelect} />);\n  \n  await user.click(screen.getByText(\"Parent 1\"));\n  expect(onSelect).toHaveBeenCalledWith([\"parent1\"], { selected: true, node: expect.any(Object) });\n});\n\ntest(\"handles multiple selection\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Tree treeData={mockTreeData} multiple onSelect={onSelect} />);\n  \n  await user.click(screen.getByText(\"Parent 1\"));\n  await user.click(screen.getByText(\"Parent 2\"));\n  \n  expect(onSelect).toHaveBeenCalledWith([\"parent1\"], expect.any(Object));\n  expect(onSelect).toHaveBeenCalledWith([\"parent1\", \"parent2\"], expect.any(Object));\n});\n\ntest(\"handles checkboxes when checkable\", async () => {\n  const user = userEvent.setup();\n  const onCheck = vi.fn();\n  render(<Tree treeData={mockTreeData} checkable onCheck={onCheck} />);\n  \n  const checkbox = screen.getByLabelText(\"Check Parent 1\");\n  await user.click(checkbox);\n  \n  expect(onCheck).toHaveBeenCalledWith(\n    [\"parent1\", \"child1\", \"child2\"], \n    { checked: true, node: expect.any(Object) }\n  );\n});\n\ntest(\"shows default expanded nodes\", () => {\n  render(<Tree treeData={mockTreeData} defaultExpandedKeys={[\"parent1\"]} />);\n  \n  expect(screen.getByText(\"Child 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Child 2\")).toBeInTheDocument();\n});\n\ntest(\"shows default selected nodes\", () => {\n  render(<Tree treeData={mockTreeData} defaultSelectedKeys={[\"parent1\"]} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  expect(parent1).toHaveClass(\"tree-node-selected\");\n});\n\ntest(\"shows default checked nodes\", () => {\n  render(<Tree treeData={mockTreeData} checkable defaultCheckedKeys={[\"parent1\"]} />);\n  \n  const checkbox = screen.getByLabelText(\"Check Parent 1\") as HTMLInputElement;\n  expect(checkbox.checked).toBe(true);\n});\n\ntest(\"works in controlled mode\", () => {\n  const onExpand = vi.fn();\n  render(\n    <Tree \n      treeData={mockTreeData} \n      expandedKeys={[\"parent1\"]} \n      onExpand={onExpand} \n    />\n  );\n  \n  expect(screen.getByText(\"Child 1\")).toBeInTheDocument();\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Tree treeData={mockTreeData} onSelect={onSelect} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  parent1?.focus();\n  \n  await user.keyboard(\"{Enter}\");\n  expect(onSelect).toHaveBeenCalledWith([\"parent1\"], expect.any(Object));\n});\n\ntest(\"expands node with arrow right key\", async () => {\n  const user = userEvent.setup();\n  const onExpand = vi.fn();\n  render(<Tree treeData={mockTreeData} onExpand={onExpand} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  parent1?.focus();\n  \n  await user.keyboard(\"{ArrowRight}\");\n  expect(onExpand).toHaveBeenCalledWith([\"parent1\"], expect.any(Object));\n});\n\ntest(\"collapses node with arrow left key\", async () => {\n  const user = userEvent.setup();\n  const onExpand = vi.fn();\n  render(<Tree treeData={mockTreeData} defaultExpandedKeys={[\"parent1\"]} onExpand={onExpand} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  parent1?.focus();\n  \n  await user.keyboard(\"{ArrowLeft}\");\n  expect(onExpand).toHaveBeenCalledWith([], expect.any(Object));\n});\n\ntest(\"handles disabled nodes\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  const dataWithDisabled = [\n    { key: \"disabled\", title: \"Disabled Node\", disabled: true },\n    { key: \"enabled\", title: \"Enabled Node\" },\n  ];\n  \n  render(<Tree treeData={dataWithDisabled} onSelect={onSelect} />);\n  \n  const disabledNode = screen.getByText(\"Disabled Node\").parentElement;\n  expect(disabledNode).toHaveClass(\"tree-node-disabled\");\n  expect(disabledNode).toHaveAttribute(\"aria-disabled\", \"true\");\n  \n  await user.click(disabledNode!);\n  expect(onSelect).not.toHaveBeenCalledWith([\"disabled\"], expect.any(Object));\n});\n\ntest(\"shows icons when enabled\", () => {\n  const dataWithIcons = [\n    { key: \"folder\", title: \"Folder\", icon: <span>📁</span> },\n  ];\n  \n  render(<Tree treeData={dataWithIcons} showIcon />);\n  expect(screen.getByText(\"📁\")).toBeInTheDocument();\n});\n\ntest(\"applies block node styling\", () => {\n  const { container } = render(<Tree treeData={mockTreeData} blockNode />);\n  expect(container.firstChild).toHaveClass(\"tree-block-node\");\n});\n\ntest(\"shows line connections\", () => {\n  const { container } = render(<Tree treeData={mockTreeData} showLine />);\n  expect(container.firstChild).toHaveClass(\"tree-show-line\");\n});\n\ntest(\"handles nested expansion correctly\", async () => {\n  const user = userEvent.setup();\n  render(<Tree treeData={mockTreeData} defaultExpandedKeys={[\"parent2\"]} />);\n  \n  expect(screen.getByText(\"Child 3\")).toBeInTheDocument();\n  expect(screen.queryByText(\"Grandchild 1\")).not.toBeInTheDocument();\n  \n  const child3Expander = screen.getByText(\"Child 3\").parentElement?.querySelector(\".tree-switcher\");\n  if (child3Expander) {\n    await user.click(child3Expander);\n  }\n  \n  expect(screen.getByText(\"Grandchild 1\")).toBeInTheDocument();\n});\n\ntest(\"handles load data functionality\", async () => {\n  const user = userEvent.setup();\n  const loadData = vi.fn().mockResolvedValue(undefined);\n  const dataWithLoadable = [\n    { key: \"loadable\", title: \"Loadable Node\" },\n  ];\n  \n  render(<Tree treeData={dataWithLoadable} loadData={loadData} />);\n  \n  const expander = screen.getByText(\"Loadable Node\").parentElement?.querySelector(\".tree-switcher\");\n  if (expander) {\n    await user.click(expander);\n  }\n  \n  expect(loadData).toHaveBeenCalledWith({ key: \"loadable\", title: \"Loadable Node\" });\n});\n\ntest(\"shows loading state during data loading\", async () => {\n  const user = userEvent.setup();\n  let resolveLoadData: () => void;\n  const loadDataPromise = new Promise<void>((resolve) => {\n    resolveLoadData = resolve;\n  });\n  const loadData = vi.fn().mockReturnValue(loadDataPromise);\n  \n  const dataWithLoadable = [\n    { key: \"loadable\", title: \"Loadable Node\" },\n  ];\n  \n  render(<Tree treeData={dataWithLoadable} loadData={loadData} />);\n  \n  const expander = screen.getByText(\"Loadable Node\").parentElement?.querySelector(\".tree-switcher\");\n  if (expander) {\n    await user.click(expander);\n  }\n  \n  expect(expander).toHaveTextContent(\"...\");\n  \n  resolveLoadData!();\n  await loadDataPromise;\n});\n\ntest(\"respects node-level checkable and selectable properties\", async () => {\n  const user = userEvent.setup();\n  const onCheck = vi.fn();\n  const onSelect = vi.fn();\n  \n  const dataWithMixedProps = [\n    { key: \"checkable\", title: \"Checkable Node\", checkable: true },\n    { key: \"not-checkable\", title: \"Not Checkable\", checkable: false },\n    { key: \"selectable\", title: \"Selectable Node\", selectable: true },\n    { key: \"not-selectable\", title: \"Not Selectable\", selectable: false },\n  ];\n  \n  render(\n    <Tree \n      treeData={dataWithMixedProps} \n      checkable \n      onCheck={onCheck} \n      onSelect={onSelect} \n    />\n  );\n  \n  // Should have checkbox\n  expect(screen.getByLabelText(\"Check Checkable Node\")).toBeInTheDocument();\n  // Should not have checkbox\n  expect(screen.queryByLabelText(\"Check Not Checkable\")).not.toBeInTheDocument();\n  \n  // Test non-selectable node\n  await user.click(screen.getByText(\"Not Selectable\"));\n  expect(onSelect).not.toHaveBeenCalledWith([\"not-selectable\"], expect.any(Object));\n});\n\ntest(\"has proper accessibility attributes\", () => {\n  render(<Tree treeData={mockTreeData} />);\n  \n  expect(screen.getByRole(\"tree\")).toBeInTheDocument();\n  \n  const treeItems = screen.getAllByRole(\"treeitem\");\n  expect(treeItems).toHaveLength(3); // Top level nodes\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  expect(parent1).toHaveAttribute(\"aria-expanded\", \"false\");\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\nexport interface TreeNode {\n  key: string;\n  title: string;\n  children?: TreeNode[];\n  disabled?: boolean;\n  checkable?: boolean;\n  selectable?: boolean;\n  icon?: React.ReactNode;\n  isLeaf?: boolean;\n}\n\nexport interface TreeProps extends React.HTMLAttributes<HTMLDivElement> {\n  treeData: TreeNode[];\n  checkable?: boolean;\n  selectable?: boolean;\n  multiple?: boolean;\n  defaultExpandedKeys?: string[];\n  defaultSelectedKeys?: string[];\n  defaultCheckedKeys?: string[];\n  expandedKeys?: string[];\n  selectedKeys?: string[];\n  checkedKeys?: string[];\n  onExpand?: (expandedKeys: string[], info: { expanded: boolean; node: TreeNode }) => void;\n  onSelect?: (selectedKeys: string[], info: { selected: boolean; node: TreeNode }) => void;\n  onCheck?: (checkedKeys: string[], info: { checked: boolean; node: TreeNode }) => void;\n  showLine?: boolean;\n  showIcon?: boolean;\n  blockNode?: boolean;\n  loadData?: (node: TreeNode) => Promise<void>;\n}\n\nexport const Tree = React.forwardRef<HTMLDivElement, TreeProps>(\n  ({\n    treeData,\n    checkable = false,\n    selectable = true,\n    multiple = false,\n    defaultExpandedKeys = [],\n    defaultSelectedKeys = [],\n    defaultCheckedKeys = [],\n    expandedKeys: controlledExpandedKeys,\n    selectedKeys: controlledSelectedKeys,\n    checkedKeys: controlledCheckedKeys,\n    onExpand,\n    onSelect,\n    onCheck,\n    showLine = false,\n    showIcon = false,\n    blockNode = false,\n    loadData,\n    className,\n    ...rest\n  }, ref) => {\n    const [internalExpandedKeys, setInternalExpandedKeys] = React.useState<string[]>(defaultExpandedKeys);\n    const [internalSelectedKeys, setInternalSelectedKeys] = React.useState<string[]>(defaultSelectedKeys);\n    const [internalCheckedKeys, setInternalCheckedKeys] = React.useState<string[]>(defaultCheckedKeys);\n    const [loadingKeys, setLoadingKeys] = React.useState<string[]>([]);\n\n    const isExpandedControlled = controlledExpandedKeys !== undefined;\n    const isSelectedControlled = controlledSelectedKeys !== undefined;\n    const isCheckedControlled = controlledCheckedKeys !== undefined;\n\n    const expandedKeys = isExpandedControlled ? controlledExpandedKeys : internalExpandedKeys;\n    const selectedKeys = isSelectedControlled ? controlledSelectedKeys : internalSelectedKeys;\n    const checkedKeys = isCheckedControlled ? controlledCheckedKeys : internalCheckedKeys;\n\n    const classes = `tree ${showLine ? \"tree-show-line\" : \"\"} ${\n      blockNode ? \"tree-block-node\" : \"\"\n    } ${className || \"\"}`.trim();\n\n    const updateExpandedKeys = (newKeys: string[], info: { expanded: boolean; node: TreeNode }) => {\n      if (onExpand) {\n        onExpand(newKeys, info);\n      }\n      if (!isExpandedControlled) {\n        setInternalExpandedKeys(newKeys);\n      }\n    };\n\n    const updateSelectedKeys = (newKeys: string[], info: { selected: boolean; node: TreeNode }) => {\n      if (onSelect) {\n        onSelect(newKeys, info);\n      }\n      if (!isSelectedControlled) {\n        setInternalSelectedKeys(newKeys);\n      }\n    };\n\n    const updateCheckedKeys = (newKeys: string[], info: { checked: boolean; node: TreeNode }) => {\n      if (onCheck) {\n        onCheck(newKeys, info);\n      }\n      if (!isCheckedControlled) {\n        setInternalCheckedKeys(newKeys);\n      }\n    };\n\n    const getAllDescendantKeys = (node: TreeNode): string[] => {\n      const keys = [node.key];\n      if (node.children) {\n        node.children.forEach(child => {\n          keys.push(...getAllDescendantKeys(child));\n        });\n      }\n      return keys;\n    };\n\n    const handleExpand = async (node: TreeNode) => {\n      const isExpanded = expandedKeys.includes(node.key);\n      const newExpandedKeys = isExpanded\n        ? expandedKeys.filter(key => key !== node.key)\n        : [...expandedKeys, node.key];\n\n      if (!isExpanded && loadData && (!node.children || node.children.length === 0)) {\n        setLoadingKeys(prev => [...prev, node.key]);\n        try {\n          await loadData(node);\n        } finally {\n          setLoadingKeys(prev => prev.filter(key => key !== node.key));\n        }\n      }\n\n      updateExpandedKeys(newExpandedKeys, { expanded: !isExpanded, node });\n    };\n\n    const handleSelect = (node: TreeNode) => {\n      if (!selectable || node.disabled || (node.selectable === false)) return;\n\n      const isSelected = selectedKeys.includes(node.key);\n      let newSelectedKeys: string[];\n\n      if (multiple) {\n        newSelectedKeys = isSelected\n          ? selectedKeys.filter(key => key !== node.key)\n          : [...selectedKeys, node.key];\n      } else {\n        newSelectedKeys = isSelected ? [] : [node.key];\n      }\n\n      updateSelectedKeys(newSelectedKeys, { selected: !isSelected, node });\n    };\n\n    const handleCheck = (node: TreeNode) => {\n      if (!checkable || node.disabled || (node.checkable === false)) return;\n\n      const isChecked = checkedKeys.includes(node.key);\n      const descendantKeys = getAllDescendantKeys(node);\n      \n      let newCheckedKeys: string[];\n      if (isChecked) {\n        // Uncheck node and all descendants\n        newCheckedKeys = checkedKeys.filter(key => !descendantKeys.includes(key));\n      } else {\n        // Check node and all descendants\n        newCheckedKeys = [...new Set([...checkedKeys, ...descendantKeys])];\n      }\n\n      updateCheckedKeys(newCheckedKeys, { checked: !isChecked, node });\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent, node: TreeNode) => {\n      switch (e.key) {\n        case \"Enter\":\n        case \" \":\n          e.preventDefault();\n          if (checkable && (node.checkable !== false)) {\n            handleCheck(node);\n          } else if (selectable && (node.selectable !== false)) {\n            handleSelect(node);\n          }\n          break;\n        case \"ArrowRight\":\n          e.preventDefault();\n          if (!expandedKeys.includes(node.key) && (node.children || loadData)) {\n            handleExpand(node);\n          }\n          break;\n        case \"ArrowLeft\":\n          e.preventDefault();\n          if (expandedKeys.includes(node.key)) {\n            handleExpand(node);\n          }\n          break;\n      }\n    };\n\n    const renderTreeNode = (node: TreeNode, level: number = 0): React.ReactNode => {\n      const isExpanded = expandedKeys.includes(node.key);\n      const isSelected = selectedKeys.includes(node.key);\n      const isChecked = checkedKeys.includes(node.key);\n      const isLoading = loadingKeys.includes(node.key);\n      const hasChildren = node.children && node.children.length > 0;\n      const canExpand = hasChildren || (loadData && !node.isLeaf);\n\n      return (\n        <div key={node.key} className=\"tree-treenode\" role=\"treeitem\" aria-expanded={canExpand ? isExpanded : undefined}>\n          <div\n            className={`tree-node-content ${isSelected ? \"tree-node-selected\" : \"\"} ${\n              node.disabled ? \"tree-node-disabled\" : \"\"\n            }`}\n            style={{ paddingLeft: `${level * 24}px` }}\n            onClick={() => !node.disabled && handleSelect(node)}\n            onKeyDown={(e) => handleKeyDown(e, node)}\n            tabIndex={0}\n            aria-selected={selectable ? isSelected : undefined}\n            aria-checked={checkable ? isChecked : undefined}\n            aria-disabled={node.disabled}\n          >\n            {canExpand && (\n              <button\n                type=\"button\"\n                className={`tree-switcher ${isExpanded ? \"tree-switcher-open\" : \"tree-switcher-close\"}`}\n                onClick={(e) => {\n                  e.stopPropagation();\n                  handleExpand(node);\n                }}\n                aria-label={isExpanded ? \"Collapse\" : \"Expand\"}\n                disabled={node.disabled}\n              >\n                {isLoading ? \"...\" : isExpanded ? \"−\" : \"+\"}\n              </button>\n            )}\n            \n            {!canExpand && showLine && (\n              <span className=\"tree-switcher tree-switcher-noop\" />\n            )}\n\n            {checkable && node.checkable !== false && (\n              <label className=\"tree-checkbox-wrapper\">\n                <input\n                  type=\"checkbox\"\n                  className=\"tree-checkbox\"\n                  checked={isChecked}\n                  onChange={() => handleCheck(node)}\n                  disabled={node.disabled}\n                  aria-label={`Check ${node.title}`}\n                />\n                <span className=\"tree-checkbox-inner\" />\n              </label>\n            )}\n\n            {showIcon && node.icon && (\n              <span className=\"tree-icon\">{node.icon}</span>\n            )}\n\n            <span className=\"tree-title\">{node.title}</span>\n          </div>\n\n          {hasChildren && isExpanded && (\n            <div className=\"tree-child-tree\" role=\"group\">\n              {node.children!.map(child => renderTreeNode(child, level + 1))}\n            </div>\n          )}\n        </div>\n      );\n    };\n\n    return (\n      <div {...rest} ref={ref} className={classes} role=\"tree\">\n        {treeData.map(node => renderTreeNode(node))}\n      </div>\n    );\n  }\n);\nTree.displayName = \"Tree\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Tree } from \"../Tree\";\n\nconst mockTreeData = [\n  {\n    key: \"parent1\",\n    title: \"Parent 1\",\n    children: [\n      { key: \"child1\", title: \"Child 1\" },\n      { key: \"child2\", title: \"Child 2\" },\n    ],\n  },\n  {\n    key: \"parent2\", \n    title: \"Parent 2\",\n    children: [\n      {\n        key: \"child3\",\n        title: \"Child 3\",\n        children: [\n          { key: \"grandchild1\", title: \"Grandchild 1\" },\n        ],\n      },\n    ],\n  },\n  { key: \"leaf\", title: \"Leaf Node\" },\n];\n\ntest(\"renders tree nodes\", () => {\n  render(<Tree treeData={mockTreeData} />);\n  \n  expect(screen.getByText(\"Parent 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Parent 2\")).toBeInTheDocument();\n  expect(screen.getByText(\"Leaf Node\")).toBeInTheDocument();\n});\n\ntest(\"expands and collapses nodes\", async () => {\n  const user = userEvent.setup();\n  render(<Tree treeData={mockTreeData} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\");\n  const expandButton = parent1.parentElement?.querySelector(\".tree-switcher\");\n  \n  // Initially collapsed\n  expect(screen.queryByText(\"Child 1\")).not.toBeInTheDocument();\n  \n  // Click to expand\n  if (expandButton) {\n    await user.click(expandButton);\n  }\n  expect(screen.getByText(\"Child 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Child 2\")).toBeInTheDocument();\n  \n  // Click to collapse\n  if (expandButton) {\n    await user.click(expandButton);\n  }\n  expect(screen.queryByText(\"Child 1\")).not.toBeInTheDocument();\n});\n\ntest(\"handles node selection\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Tree treeData={mockTreeData} onSelect={onSelect} />);\n  \n  await user.click(screen.getByText(\"Parent 1\"));\n  expect(onSelect).toHaveBeenCalledWith([\"parent1\"], { selected: true, node: expect.any(Object) });\n});\n\ntest(\"handles multiple selection\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Tree treeData={mockTreeData} multiple onSelect={onSelect} />);\n  \n  await user.click(screen.getByText(\"Parent 1\"));\n  await user.click(screen.getByText(\"Parent 2\"));\n  \n  expect(onSelect).toHaveBeenCalledWith([\"parent1\"], expect.any(Object));\n  expect(onSelect).toHaveBeenCalledWith([\"parent1\", \"parent2\"], expect.any(Object));\n});\n\ntest(\"handles checkboxes when checkable\", async () => {\n  const user = userEvent.setup();\n  const onCheck = vi.fn();\n  render(<Tree treeData={mockTreeData} checkable onCheck={onCheck} />);\n  \n  const checkbox = screen.getByLabelText(\"Check Parent 1\");\n  await user.click(checkbox);\n  \n  expect(onCheck).toHaveBeenCalledWith(\n    [\"parent1\", \"child1\", \"child2\"], \n    { checked: true, node: expect.any(Object) }\n  );\n});\n\ntest(\"shows default expanded nodes\", () => {\n  render(<Tree treeData={mockTreeData} defaultExpandedKeys={[\"parent1\"]} />);\n  \n  expect(screen.getByText(\"Child 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Child 2\")).toBeInTheDocument();\n});\n\ntest(\"shows default selected nodes\", () => {\n  render(<Tree treeData={mockTreeData} defaultSelectedKeys={[\"parent1\"]} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  expect(parent1).toHaveClass(\"tree-node-selected\");\n});\n\ntest(\"shows default checked nodes\", () => {\n  render(<Tree treeData={mockTreeData} checkable defaultCheckedKeys={[\"parent1\"]} />);\n  \n  const checkbox = screen.getByLabelText(\"Check Parent 1\") as HTMLInputElement;\n  expect(checkbox.checked).toBe(true);\n});\n\ntest(\"works in controlled mode\", () => {\n  const onExpand = vi.fn();\n  render(\n    <Tree \n      treeData={mockTreeData} \n      expandedKeys={[\"parent1\"]} \n      onExpand={onExpand} \n    />\n  );\n  \n  expect(screen.getByText(\"Child 1\")).toBeInTheDocument();\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Tree treeData={mockTreeData} onSelect={onSelect} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  parent1?.focus();\n  \n  await user.keyboard(\"{Enter}\");\n  expect(onSelect).toHaveBeenCalledWith([\"parent1\"], expect.any(Object));\n});\n\ntest(\"expands node with arrow right key\", async () => {\n  const user = userEvent.setup();\n  const onExpand = vi.fn();\n  render(<Tree treeData={mockTreeData} onExpand={onExpand} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  parent1?.focus();\n  \n  await user.keyboard(\"{ArrowRight}\");\n  expect(onExpand).toHaveBeenCalledWith([\"parent1\"], expect.any(Object));\n});\n\ntest(\"collapses node with arrow left key\", async () => {\n  const user = userEvent.setup();\n  const onExpand = vi.fn();\n  render(<Tree treeData={mockTreeData} defaultExpandedKeys={[\"parent1\"]} onExpand={onExpand} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  parent1?.focus();\n  \n  await user.keyboard(\"{ArrowLeft}\");\n  expect(onExpand).toHaveBeenCalledWith([], expect.any(Object));\n});\n\ntest(\"handles disabled nodes\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  const dataWithDisabled = [\n    { key: \"disabled\", title: \"Disabled Node\", disabled: true },\n    { key: \"enabled\", title: \"Enabled Node\" },\n  ];\n  \n  render(<Tree treeData={dataWithDisabled} onSelect={onSelect} />);\n  \n  const disabledNode = screen.getByText(\"Disabled Node\").parentElement;\n  expect(disabledNode).toHaveClass(\"tree-node-disabled\");\n  expect(disabledNode).toHaveAttribute(\"aria-disabled\", \"true\");\n  \n  await user.click(disabledNode!);\n  expect(onSelect).not.toHaveBeenCalledWith([\"disabled\"], expect.any(Object));\n});\n\ntest(\"shows icons when enabled\", () => {\n  const dataWithIcons = [\n    { key: \"folder\", title: \"Folder\", icon: <span>📁</span> },\n  ];\n  \n  render(<Tree treeData={dataWithIcons} showIcon />);\n  expect(screen.getByText(\"📁\")).toBeInTheDocument();\n});\n\ntest(\"applies block node styling\", () => {\n  const { container } = render(<Tree treeData={mockTreeData} blockNode />);\n  expect(container.firstChild).toHaveClass(\"tree-block-node\");\n});\n\ntest(\"shows line connections\", () => {\n  const { container } = render(<Tree treeData={mockTreeData} showLine />);\n  expect(container.firstChild).toHaveClass(\"tree-show-line\");\n});\n\ntest(\"handles nested expansion correctly\", async () => {\n  const user = userEvent.setup();\n  render(<Tree treeData={mockTreeData} defaultExpandedKeys={[\"parent2\"]} />);\n  \n  expect(screen.getByText(\"Child 3\")).toBeInTheDocument();\n  expect(screen.queryByText(\"Grandchild 1\")).not.toBeInTheDocument();\n  \n  const child3Expander = screen.getByText(\"Child 3\").parentElement?.querySelector(\".tree-switcher\");\n  if (child3Expander) {\n    await user.click(child3Expander);\n  }\n  \n  expect(screen.getByText(\"Grandchild 1\")).toBeInTheDocument();\n});\n\ntest(\"handles load data functionality\", async () => {\n  const user = userEvent.setup();\n  const loadData = vi.fn().mockResolvedValue(undefined);\n  const dataWithLoadable = [\n    { key: \"loadable\", title: \"Loadable Node\" },\n  ];\n  \n  render(<Tree treeData={dataWithLoadable} loadData={loadData} />);\n  \n  const expander = screen.getByText(\"Loadable Node\").parentElement?.querySelector(\".tree-switcher\");\n  if (expander) {\n    await user.click(expander);\n  }\n  \n  expect(loadData).toHaveBeenCalledWith({ key: \"loadable\", title: \"Loadable Node\" });\n});\n\ntest(\"shows loading state during data loading\", async () => {\n  const user = userEvent.setup();\n  let resolveLoadData: () => void;\n  const loadDataPromise = new Promise<void>((resolve) => {\n    resolveLoadData = resolve;\n  });\n  const loadData = vi.fn().mockReturnValue(loadDataPromise);\n  \n  const dataWithLoadable = [\n    { key: \"loadable\", title: \"Loadable Node\" },\n  ];\n  \n  render(<Tree treeData={dataWithLoadable} loadData={loadData} />);\n  \n  const expander = screen.getByText(\"Loadable Node\").parentElement?.querySelector(\".tree-switcher\");\n  if (expander) {\n    await user.click(expander);\n  }\n  \n  expect(expander).toHaveTextContent(\"...\");\n  \n  resolveLoadData!();\n  await loadDataPromise;\n});\n\ntest(\"respects node-level checkable and selectable properties\", async () => {\n  const user = userEvent.setup();\n  const onCheck = vi.fn();\n  const onSelect = vi.fn();\n  \n  const dataWithMixedProps = [\n    { key: \"checkable\", title: \"Checkable Node\", checkable: true },\n    { key: \"not-checkable\", title: \"Not Checkable\", checkable: false },\n    { key: \"selectable\", title: \"Selectable Node\", selectable: true },\n    { key: \"not-selectable\", title: \"Not Selectable\", selectable: false },\n  ];\n  \n  render(\n    <Tree \n      treeData={dataWithMixedProps} \n      checkable \n      onCheck={onCheck} \n      onSelect={onSelect} \n    />\n  );\n  \n  // Should have checkbox\n  expect(screen.getByLabelText(\"Check Checkable Node\")).toBeInTheDocument();\n  // Should not have checkbox\n  expect(screen.queryByLabelText(\"Check Not Checkable\")).not.toBeInTheDocument();\n  \n  // Test non-selectable node\n  await user.click(screen.getByText(\"Not Selectable\"));\n  expect(onSelect).not.toHaveBeenCalledWith([\"not-selectable\"], expect.any(Object));\n});\n\ntest(\"has proper accessibility attributes\", () => {\n  render(<Tree treeData={mockTreeData} />);\n  \n  expect(screen.getByRole(\"tree\")).toBeInTheDocument();\n  \n  const treeItems = screen.getAllByRole(\"treeitem\");\n  expect(treeItems).toHaveLength(3); // Top level nodes\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  expect(parent1).toHaveAttribute(\"aria-expanded\", \"false\");\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface TreeNode {\n  key: string;\n  title: string;\n  children?: TreeNode[];\n  disabled?: boolean;\n  checkable?: boolean;\n  selectable?: boolean;\n  icon?: React.ReactNode;\n  isLeaf?: boolean;\n}\n\nexport interface TreeProps extends React.HTMLAttributes<HTMLDivElement> {\n  treeData: TreeNode[];\n  checkable?: boolean;\n  selectable?: boolean;\n  multiple?: boolean;\n  defaultExpandedKeys?: string[];\n  defaultSelectedKeys?: string[];\n  defaultCheckedKeys?: string[];\n  expandedKeys?: string[];\n  selectedKeys?: string[];\n  checkedKeys?: string[];\n  onExpand?: (expandedKeys: string[], info: { expanded: boolean; node: TreeNode }) => void;\n  onSelect?: (selectedKeys: string[], info: { selected: boolean; node: TreeNode }) => void;\n  onCheck?: (checkedKeys: string[], info: { checked: boolean; node: TreeNode }) => void;\n  showLine?: boolean;\n  showIcon?: boolean;\n  blockNode?: boolean;\n  loadData?: (node: TreeNode) => Promise<void>;\n}\n\nexport const Tree = React.forwardRef<HTMLDivElement, TreeProps>(\n  ({\n    treeData,\n    checkable = false,\n    selectable = true,\n    multiple = false,\n    defaultExpandedKeys = [],\n    defaultSelectedKeys = [],\n    defaultCheckedKeys = [],\n    expandedKeys: controlledExpandedKeys,\n    selectedKeys: controlledSelectedKeys,\n    checkedKeys: controlledCheckedKeys,\n    onExpand,\n    onSelect,\n    onCheck,\n    showLine = false,\n    showIcon = false,\n    blockNode = false,\n    loadData,\n    className,\n    ...rest\n  }, ref) => {\n    const [internalExpandedKeys, setInternalExpandedKeys] = React.useState<string[]>(defaultExpandedKeys);\n    const [internalSelectedKeys, setInternalSelectedKeys] = React.useState<string[]>(defaultSelectedKeys);\n    const [internalCheckedKeys, setInternalCheckedKeys] = React.useState<string[]>(defaultCheckedKeys);\n    const [loadingKeys, setLoadingKeys] = React.useState<string[]>([]);\n\n    const isExpandedControlled = controlledExpandedKeys !== undefined;\n    const isSelectedControlled = controlledSelectedKeys !== undefined;\n    const isCheckedControlled = controlledCheckedKeys !== undefined;\n\n    const expandedKeys = isExpandedControlled ? controlledExpandedKeys : internalExpandedKeys;\n    const selectedKeys = isSelectedControlled ? controlledSelectedKeys : internalSelectedKeys;\n    const checkedKeys = isCheckedControlled ? controlledCheckedKeys : internalCheckedKeys;\n\n    const classes = `tree ${showLine ? \"tree-show-line\" : \"\"} ${\n      blockNode ? \"tree-block-node\" : \"\"\n    } ${className || \"\"}`.trim();\n\n    const updateExpandedKeys = (newKeys: string[], info: { expanded: boolean; node: TreeNode }) => {\n      if (onExpand) {\n        onExpand(newKeys, info);\n      }\n      if (!isExpandedControlled) {\n        setInternalExpandedKeys(newKeys);\n      }\n    };\n\n    const updateSelectedKeys = (newKeys: string[], info: { selected: boolean; node: TreeNode }) => {\n      if (onSelect) {\n        onSelect(newKeys, info);\n      }\n      if (!isSelectedControlled) {\n        setInternalSelectedKeys(newKeys);\n      }\n    };\n\n    const updateCheckedKeys = (newKeys: string[], info: { checked: boolean; node: TreeNode }) => {\n      if (onCheck) {\n        onCheck(newKeys, info);\n      }\n      if (!isCheckedControlled) {\n        setInternalCheckedKeys(newKeys);\n      }\n    };\n\n    const getAllDescendantKeys = (node: TreeNode): string[] => {\n      const keys = [node.key];\n      if (node.children) {\n        node.children.forEach(child => {\n          keys.push(...getAllDescendantKeys(child));\n        });\n      }\n      return keys;\n    };\n\n    const handleExpand = async (node: TreeNode) => {\n      const isExpanded = expandedKeys.includes(node.key);\n      const newExpandedKeys = isExpanded\n        ? expandedKeys.filter(key => key !== node.key)\n        : [...expandedKeys, node.key];\n\n      if (!isExpanded && loadData && (!node.children || node.children.length === 0)) {\n        setLoadingKeys(prev => [...prev, node.key]);\n        try {\n          await loadData(node);\n        } finally {\n          setLoadingKeys(prev => prev.filter(key => key !== node.key));\n        }\n      }\n\n      updateExpandedKeys(newExpandedKeys, { expanded: !isExpanded, node });\n    };\n\n    const handleSelect = (node: TreeNode) => {\n      if (!selectable || node.disabled || (node.selectable === false)) return;\n\n      const isSelected = selectedKeys.includes(node.key);\n      let newSelectedKeys: string[];\n\n      if (multiple) {\n        newSelectedKeys = isSelected\n          ? selectedKeys.filter(key => key !== node.key)\n          : [...selectedKeys, node.key];\n      } else {\n        newSelectedKeys = isSelected ? [] : [node.key];\n      }\n\n      updateSelectedKeys(newSelectedKeys, { selected: !isSelected, node });\n    };\n\n    const handleCheck = (node: TreeNode) => {\n      if (!checkable || node.disabled || (node.checkable === false)) return;\n\n      const isChecked = checkedKeys.includes(node.key);\n      const descendantKeys = getAllDescendantKeys(node);\n      \n      let newCheckedKeys: string[];\n      if (isChecked) {\n        // Uncheck node and all descendants\n        newCheckedKeys = checkedKeys.filter(key => !descendantKeys.includes(key));\n      } else {\n        // Check node and all descendants\n        newCheckedKeys = [...new Set([...checkedKeys, ...descendantKeys])];\n      }\n\n      updateCheckedKeys(newCheckedKeys, { checked: !isChecked, node });\n    };\n\n    const handleKeyDown = (e: React.KeyboardEvent, node: TreeNode) => {\n      switch (e.key) {\n        case \"Enter\":\n        case \" \":\n          e.preventDefault();\n          if (checkable && (node.checkable !== false)) {\n            handleCheck(node);\n          } else if (selectable && (node.selectable !== false)) {\n            handleSelect(node);\n          }\n          break;\n        case \"ArrowRight\":\n          e.preventDefault();\n          if (!expandedKeys.includes(node.key) && (node.children || loadData)) {\n            handleExpand(node);\n          }\n          break;\n        case \"ArrowLeft\":\n          e.preventDefault();\n          if (expandedKeys.includes(node.key)) {\n            handleExpand(node);\n          }\n          break;\n      }\n    };\n\n    const renderTreeNode = (node: TreeNode, level: number = 0): React.ReactNode => {\n      const isExpanded = expandedKeys.includes(node.key);\n      const isSelected = selectedKeys.includes(node.key);\n      const isChecked = checkedKeys.includes(node.key);\n      const isLoading = loadingKeys.includes(node.key);\n      const hasChildren = node.children && node.children.length > 0;\n      const canExpand = hasChildren || (loadData && !node.isLeaf);\n\n      return (\n        <div key={node.key} className=\"tree-treenode\" role=\"treeitem\" aria-expanded={canExpand ? isExpanded : undefined}>\n          <div\n            className={`tree-node-content ${isSelected ? \"tree-node-selected\" : \"\"} ${\n              node.disabled ? \"tree-node-disabled\" : \"\"\n            }`}\n            style={{ paddingLeft: `${level * 24}px` }}\n            onClick={() => !node.disabled && handleSelect(node)}\n            onKeyDown={(e) => handleKeyDown(e, node)}\n            tabIndex={0}\n            aria-selected={selectable ? isSelected : undefined}\n            aria-checked={checkable ? isChecked : undefined}\n            aria-disabled={node.disabled}\n          >\n            {canExpand && (\n              <button\n                type=\"button\"\n                className={`tree-switcher ${isExpanded ? \"tree-switcher-open\" : \"tree-switcher-close\"}`}\n                onClick={(e) => {\n                  e.stopPropagation();\n                  handleExpand(node);\n                }}\n                aria-label={isExpanded ? \"Collapse\" : \"Expand\"}\n                disabled={node.disabled}\n              >\n                {isLoading ? \"...\" : isExpanded ? \"−\" : \"+\"}\n              </button>\n            )}\n            \n            {!canExpand && showLine && (\n              <span className=\"tree-switcher tree-switcher-noop\" />\n            )}\n\n            {checkable && node.checkable !== false && (\n              <label className=\"tree-checkbox-wrapper\">\n                <input\n                  type=\"checkbox\"\n                  className=\"tree-checkbox\"\n                  checked={isChecked}\n                  onChange={() => handleCheck(node)}\n                  disabled={node.disabled}\n                  aria-label={`Check ${node.title}`}\n                />\n                <span className=\"tree-checkbox-inner\" />\n              </label>\n            )}\n\n            {showIcon && node.icon && (\n              <span className=\"tree-icon\">{node.icon}</span>\n            )}\n\n            <span className=\"tree-title\">{node.title}</span>\n          </div>\n\n          {hasChildren && isExpanded && (\n            <div className=\"tree-child-tree\" role=\"group\">\n              {node.children!.map(child => renderTreeNode(child, level + 1))}\n            </div>\n          )}\n        </div>\n      );\n    };\n\n    return (\n      <div {...rest} ref={ref} className={classes} role=\"tree\">\n        {treeData.map(node => renderTreeNode(node))}\n      </div>\n    );\n  }\n);\nTree.displayName = \"Tree\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Tree } from \"../Tree\";\n\nconst mockTreeData = [\n  {\n    key: \"parent1\",\n    title: \"Parent 1\",\n    children: [\n      { key: \"child1\", title: \"Child 1\" },\n      { key: \"child2\", title: \"Child 2\" },\n    ],\n  },\n  {\n    key: \"parent2\", \n    title: \"Parent 2\",\n    children: [\n      {\n        key: \"child3\",\n        title: \"Child 3\",\n        children: [\n          { key: \"grandchild1\", title: \"Grandchild 1\" },\n        ],\n      },\n    ],\n  },\n  { key: \"leaf\", title: \"Leaf Node\" },\n];\n\ntest(\"renders tree nodes\", () => {\n  render(<Tree treeData={mockTreeData} />);\n  \n  expect(screen.getByText(\"Parent 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Parent 2\")).toBeInTheDocument();\n  expect(screen.getByText(\"Leaf Node\")).toBeInTheDocument();\n});\n\ntest(\"expands and collapses nodes\", async () => {\n  const user = userEvent.setup();\n  render(<Tree treeData={mockTreeData} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\");\n  const expandButton = parent1.parentElement?.querySelector(\".tree-switcher\");\n  \n  // Initially collapsed\n  expect(screen.queryByText(\"Child 1\")).not.toBeInTheDocument();\n  \n  // Click to expand\n  if (expandButton) {\n    await user.click(expandButton);\n  }\n  expect(screen.getByText(\"Child 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Child 2\")).toBeInTheDocument();\n  \n  // Click to collapse\n  if (expandButton) {\n    await user.click(expandButton);\n  }\n  expect(screen.queryByText(\"Child 1\")).not.toBeInTheDocument();\n});\n\ntest(\"handles node selection\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Tree treeData={mockTreeData} onSelect={onSelect} />);\n  \n  await user.click(screen.getByText(\"Parent 1\"));\n  expect(onSelect).toHaveBeenCalledWith([\"parent1\"], { selected: true, node: expect.any(Object) });\n});\n\ntest(\"handles multiple selection\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Tree treeData={mockTreeData} multiple onSelect={onSelect} />);\n  \n  await user.click(screen.getByText(\"Parent 1\"));\n  await user.click(screen.getByText(\"Parent 2\"));\n  \n  expect(onSelect).toHaveBeenCalledWith([\"parent1\"], expect.any(Object));\n  expect(onSelect).toHaveBeenCalledWith([\"parent1\", \"parent2\"], expect.any(Object));\n});\n\ntest(\"handles checkboxes when checkable\", async () => {\n  const user = userEvent.setup();\n  const onCheck = vi.fn();\n  render(<Tree treeData={mockTreeData} checkable onCheck={onCheck} />);\n  \n  const checkbox = screen.getByLabelText(\"Check Parent 1\");\n  await user.click(checkbox);\n  \n  expect(onCheck).toHaveBeenCalledWith(\n    [\"parent1\", \"child1\", \"child2\"], \n    { checked: true, node: expect.any(Object) }\n  );\n});\n\ntest(\"shows default expanded nodes\", () => {\n  render(<Tree treeData={mockTreeData} defaultExpandedKeys={[\"parent1\"]} />);\n  \n  expect(screen.getByText(\"Child 1\")).toBeInTheDocument();\n  expect(screen.getByText(\"Child 2\")).toBeInTheDocument();\n});\n\ntest(\"shows default selected nodes\", () => {\n  render(<Tree treeData={mockTreeData} defaultSelectedKeys={[\"parent1\"]} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  expect(parent1).toHaveClass(\"tree-node-selected\");\n});\n\ntest(\"shows default checked nodes\", () => {\n  render(<Tree treeData={mockTreeData} checkable defaultCheckedKeys={[\"parent1\"]} />);\n  \n  const checkbox = screen.getByLabelText(\"Check Parent 1\") as HTMLInputElement;\n  expect(checkbox.checked).toBe(true);\n});\n\ntest(\"works in controlled mode\", () => {\n  const onExpand = vi.fn();\n  render(\n    <Tree \n      treeData={mockTreeData} \n      expandedKeys={[\"parent1\"]} \n      onExpand={onExpand} \n    />\n  );\n  \n  expect(screen.getByText(\"Child 1\")).toBeInTheDocument();\n});\n\ntest(\"handles keyboard navigation\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Tree treeData={mockTreeData} onSelect={onSelect} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  parent1?.focus();\n  \n  await user.keyboard(\"{Enter}\");\n  expect(onSelect).toHaveBeenCalledWith([\"parent1\"], expect.any(Object));\n});\n\ntest(\"expands node with arrow right key\", async () => {\n  const user = userEvent.setup();\n  const onExpand = vi.fn();\n  render(<Tree treeData={mockTreeData} onExpand={onExpand} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  parent1?.focus();\n  \n  await user.keyboard(\"{ArrowRight}\");\n  expect(onExpand).toHaveBeenCalledWith([\"parent1\"], expect.any(Object));\n});\n\ntest(\"collapses node with arrow left key\", async () => {\n  const user = userEvent.setup();\n  const onExpand = vi.fn();\n  render(<Tree treeData={mockTreeData} defaultExpandedKeys={[\"parent1\"]} onExpand={onExpand} />);\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  parent1?.focus();\n  \n  await user.keyboard(\"{ArrowLeft}\");\n  expect(onExpand).toHaveBeenCalledWith([], expect.any(Object));\n});\n\ntest(\"handles disabled nodes\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  const dataWithDisabled = [\n    { key: \"disabled\", title: \"Disabled Node\", disabled: true },\n    { key: \"enabled\", title: \"Enabled Node\" },\n  ];\n  \n  render(<Tree treeData={dataWithDisabled} onSelect={onSelect} />);\n  \n  const disabledNode = screen.getByText(\"Disabled Node\").parentElement;\n  expect(disabledNode).toHaveClass(\"tree-node-disabled\");\n  expect(disabledNode).toHaveAttribute(\"aria-disabled\", \"true\");\n  \n  await user.click(disabledNode!);\n  expect(onSelect).not.toHaveBeenCalledWith([\"disabled\"], expect.any(Object));\n});\n\ntest(\"shows icons when enabled\", () => {\n  const dataWithIcons = [\n    { key: \"folder\", title: \"Folder\", icon: <span>📁</span> },\n  ];\n  \n  render(<Tree treeData={dataWithIcons} showIcon />);\n  expect(screen.getByText(\"📁\")).toBeInTheDocument();\n});\n\ntest(\"applies block node styling\", () => {\n  const { container } = render(<Tree treeData={mockTreeData} blockNode />);\n  expect(container.firstChild).toHaveClass(\"tree-block-node\");\n});\n\ntest(\"shows line connections\", () => {\n  const { container } = render(<Tree treeData={mockTreeData} showLine />);\n  expect(container.firstChild).toHaveClass(\"tree-show-line\");\n});\n\ntest(\"handles nested expansion correctly\", async () => {\n  const user = userEvent.setup();\n  render(<Tree treeData={mockTreeData} defaultExpandedKeys={[\"parent2\"]} />);\n  \n  expect(screen.getByText(\"Child 3\")).toBeInTheDocument();\n  expect(screen.queryByText(\"Grandchild 1\")).not.toBeInTheDocument();\n  \n  const child3Expander = screen.getByText(\"Child 3\").parentElement?.querySelector(\".tree-switcher\");\n  if (child3Expander) {\n    await user.click(child3Expander);\n  }\n  \n  expect(screen.getByText(\"Grandchild 1\")).toBeInTheDocument();\n});\n\ntest(\"handles load data functionality\", async () => {\n  const user = userEvent.setup();\n  const loadData = vi.fn().mockResolvedValue(undefined);\n  const dataWithLoadable = [\n    { key: \"loadable\", title: \"Loadable Node\" },\n  ];\n  \n  render(<Tree treeData={dataWithLoadable} loadData={loadData} />);\n  \n  const expander = screen.getByText(\"Loadable Node\").parentElement?.querySelector(\".tree-switcher\");\n  if (expander) {\n    await user.click(expander);\n  }\n  \n  expect(loadData).toHaveBeenCalledWith({ key: \"loadable\", title: \"Loadable Node\" });\n});\n\ntest(\"shows loading state during data loading\", async () => {\n  const user = userEvent.setup();\n  let resolveLoadData: () => void;\n  const loadDataPromise = new Promise<void>((resolve) => {\n    resolveLoadData = resolve;\n  });\n  const loadData = vi.fn().mockReturnValue(loadDataPromise);\n  \n  const dataWithLoadable = [\n    { key: \"loadable\", title: \"Loadable Node\" },\n  ];\n  \n  render(<Tree treeData={dataWithLoadable} loadData={loadData} />);\n  \n  const expander = screen.getByText(\"Loadable Node\").parentElement?.querySelector(\".tree-switcher\");\n  if (expander) {\n    await user.click(expander);\n  }\n  \n  expect(expander).toHaveTextContent(\"...\");\n  \n  resolveLoadData!();\n  await loadDataPromise;\n});\n\ntest(\"respects node-level checkable and selectable properties\", async () => {\n  const user = userEvent.setup();\n  const onCheck = vi.fn();\n  const onSelect = vi.fn();\n  \n  const dataWithMixedProps = [\n    { key: \"checkable\", title: \"Checkable Node\", checkable: true },\n    { key: \"not-checkable\", title: \"Not Checkable\", checkable: false },\n    { key: \"selectable\", title: \"Selectable Node\", selectable: true },\n    { key: \"not-selectable\", title: \"Not Selectable\", selectable: false },\n  ];\n  \n  render(\n    <Tree \n      treeData={dataWithMixedProps} \n      checkable \n      onCheck={onCheck} \n      onSelect={onSelect} \n    />\n  );\n  \n  // Should have checkbox\n  expect(screen.getByLabelText(\"Check Checkable Node\")).toBeInTheDocument();\n  // Should not have checkbox\n  expect(screen.queryByLabelText(\"Check Not Checkable\")).not.toBeInTheDocument();\n  \n  // Test non-selectable node\n  await user.click(screen.getByText(\"Not Selectable\"));\n  expect(onSelect).not.toHaveBeenCalledWith([\"not-selectable\"], expect.any(Object));\n});\n\ntest(\"has proper accessibility attributes\", () => {\n  render(<Tree treeData={mockTreeData} />);\n  \n  expect(screen.getByRole(\"tree\")).toBeInTheDocument();\n  \n  const treeItems = screen.getAllByRole(\"treeitem\");\n  expect(treeItems).toHaveLength(3); // Top level nodes\n  \n  const parent1 = screen.getByText(\"Parent 1\").parentElement;\n  expect(parent1).toHaveAttribute(\"aria-expanded\", \"false\");\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\ntype ButtonVariant = \"primary\" | \"secondary\" | \"ghost\";\n\nexport interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  variant?: ButtonVariant;\n  isLoading?: boolean;\n}\n\nconst classesByVariant: Record<ButtonVariant, string> = {\n  primary: \"btn btn-primary\",\n  secondary: \"btn btn-secondary\",\n  ghost: \"btn btn-ghost\",\n};\n\nexport const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ variant = \"primary\", isLoading = false, disabled, children, ...rest }, ref) => {\n    const isDisabled = disabled || isLoading;\n    return (\n      <button\n        {...rest}\n        ref={ref}\n        className={classesByVariant[variant]}\n        disabled={isDisabled}\n        aria-busy={isLoading || undefined}\n      >\n        {isLoading ? \"Loading…\" : children}\n      </button>\n    );\n  }\n);\nButton.displayName = \"Button\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Button } from \"../Button\";\n\ntest(\"renders with children and handles click\", async () => {\n  const user = userEvent.setup();\n  const onClick = vi.fn();\n  render(<Button onClick={onClick}>Save</Button>);\n\n  await user.click(screen.getByRole(\"button\", { name: /save/i }));\n  expect(onClick).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows loading state disables button\", async () => {\n  const user = userEvent.setup();\n  const onClick = vi.fn();\n  render(<Button isLoading onClick={onClick}>Save</Button>);\n\n  const btn = screen.getByRole(\"button\", { name: /loading…/i });\n  expect(btn).toBeDisabled();\n  expect(btn).toHaveAttribute(\"aria-busy\", \"true\");\n\n  await user.click(btn);\n  expect(onClick).not.toHaveBeenCalled();\n});\n\ntest(\"variant applies class\", () => {\n  render(<Button variant=\"secondary\">Go</Button>);\n  expect(screen.getByRole(\"button\", { name: /go/i })).toHaveClass(\"btn\", \"btn-secondary\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\ntype ButtonVariant = \"primary\" | \"secondary\" | \"ghost\";\n\nexport interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  variant?: ButtonVariant;\n  isLoading?: boolean;\n}\n\nconst classesByVariant: Record<ButtonVariant, string> = {\n  primary: \"btn btn-primary\",\n  secondary: \"btn btn-secondary\",\n  ghost: \"btn btn-ghost\",\n};\n\nexport const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ variant = \"primary\", isLoading = false, disabled, children, ...rest }, ref) => {\n    const isDisabled = disabled || isLoading;\n    return (\n      <button\n        {...rest}\n        ref={ref}\n        className={classesByVariant[variant]}\n        disabled={isDisabled}\n        aria-busy={isLoading || undefined}\n      >\n        {isLoading ? \"Loading…\" : children}\n      </button>\n    );\n  }\n);\nButton.displayName = \"Button\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Button } from \"../Button\";\n\ntest(\"renders with children and handles click\", async () => {\n  const user = userEvent.setup();\n  const onClick = vi.fn();\n  render(<Button onClick={onClick}>Save</Button>);\n\n  await user.click(screen.getByRole(\"button\", { name: /save/i }));\n  expect(onClick).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows loading state disables button\", async () => {\n  const user = userEvent.setup();\n  const onClick = vi.fn();\n  render(<Button isLoading onClick={onClick}>Save</Button>);\n\n  const btn = screen.getByRole(\"button\", { name: /loading…/i });\n  expect(btn).toBeDisabled();\n  expect(btn).toHaveAttribute(\"aria-busy\", \"true\");\n\n  await user.click(btn);\n  expect(onClick).not.toHaveBeenCalled();\n});\n\ntest(\"variant applies class\", () => {\n  render(<Button variant=\"secondary\">Go</Button>);\n  expect(screen.getByRole(\"button\", { name: /go/i })).toHaveClass(\"btn\", \"btn-secondary\");\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\ntype ButtonVariant = \"primary\" | \"secondary\" | \"ghost\";\n\nexport interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  variant?: ButtonVariant;\n  isLoading?: boolean;\n}\n\nconst classesByVariant: Record<ButtonVariant, string> = {\n  primary: \"btn btn-primary\",\n  secondary: \"btn btn-secondary\",\n  ghost: \"btn btn-ghost\",\n};\n\nexport const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ variant = \"primary\", isLoading = false, disabled, children, ...rest }, ref) => {\n    const isDisabled = disabled || isLoading;\n    return (\n      <button\n        {...rest}\n        ref={ref}\n        className={classesByVariant[variant]}\n        disabled={isDisabled}\n        aria-busy={isLoading || undefined}\n      >\n        {isLoading ? \"Loading…\" : children}\n      </button>\n    );\n  }\n);\nButton.displayName = \"Button\";",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Button } from \"../Button\";\n\ntest(\"renders with children and handles click\", async () => {\n  const user = userEvent.setup();\n  const onClick = vi.fn();\n  render(<Button onClick={onClick}>Save</Button>);\n\n  await user.click(screen.getByRole(\"button\", { name: /save/i }));\n  expect(onClick).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows loading state disables button\", async () => {\n  const user = userEvent.setup();\n  const onClick = vi.fn();\n  render(<Button isLoading onClick={onClick}>Save</Button>);\n\n  const btn = screen.getByRole(\"button\", { name: /loading…/i });\n  expect(btn).toBeDisabled();\n  expect(btn).toHaveAttribute(\"aria-busy\", \"true\");\n\n  await user.click(btn);\n  expect(onClick).not.toHaveBeenCalled();\n});\n\ntest(\"variant applies class\", () => {\n  render(<Button variant=\"secondary\">Go</Button>);\n  expect(screen.getByRole(\"button\", { name: /go/i })).toHaveClass(\"btn\", \"btn-secondary\");\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import * as React from \"react\";\n\ninterface ComboboxProps {\n  options: string[];\n  onSelect: (value: string) => void;\n  label?: string;\n  id?: string;\n}\n\nexport function Combobox({ options, onSelect, label = \"Choose\", id = \"combo\" }: ComboboxProps) {\n  const [input, setInput] = React.useState(\"\");\n  const [open, setOpen] = React.useState(false);\n  const [activeIndex, setActiveIndex] = React.useState<number>(-1);\n\n  const filtered = options.filter(o => o.toLowerCase().includes(input.toLowerCase()));\n\n  const commit = (value: string) => {\n    setInput(value);\n    setOpen(false);\n    onSelect(value);\n  };\n\n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input\n        id={id}\n        role=\"combobox\"\n        aria-expanded={open}\n        aria-controls={`${id}-listbox`}\n        aria-autocomplete=\"list\"\n        value={input}\n        onChange={(e) => { setInput(e.target.value); setOpen(true); setActiveIndex(-1); }}\n        onKeyDown={(e) => {\n          if (!open && (e.key === \"ArrowDown\" || e.key === \"ArrowUp\")) setOpen(true);\n          if (e.key === \"ArrowDown\") setActiveIndex((i) => Math.min(i + 1, filtered.length - 1));\n          if (e.key === \"ArrowUp\") setActiveIndex((i) => Math.max(i - 1, 0));\n          if (e.key === \"Enter\" && activeIndex >= 0) commit(filtered[activeIndex]);\n          if (e.key === \"Escape\") setOpen(false);\n        }}\n        onBlur={() => setTimeout(() => setOpen(false), 100)}\n      />\n      {open && (\n        <ul role=\"listbox\" id={`${id}-listbox`}>\n          {filtered.length ? (\n            filtered.map((o, i) => (\n              <li\n                key={o}\n                role=\"option\"\n                aria-selected={i === activeIndex}\n                onMouseDown={(e) => e.preventDefault()}\n                onClick={() => commit(o)}\n              >\n                {o}\n              </li>\n            ))\n          ) : (\n            <li role=\"option\" aria-disabled=\"true\">No matches</li>\n          )}\n        </ul>\n      )}\n    </div>\n  );\n}",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Combobox } from \"../Combobox\";\n\ntest(\"filters and selects with keyboard\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Combobox options={[\"React\", \"Redux\", \"TypeScript\"]} onSelect={onSelect} />);\n\n  const cb = screen.getByRole(\"combobox\", { name: /choose/i });\n  await user.type(cb, \"re\");\n  const list = screen.getByRole(\"listbox\");\n  expect(list).toBeInTheDocument();\n\n  await user.keyboard(\"{ArrowDown}{Enter}\");\n  expect(onSelect).toHaveBeenCalledWith(\"React\");\n  expect(screen.queryByRole(\"listbox\")).not.toBeInTheDocument();\n});\n\ntest(\"shows no matches\", async () => {\n  const user = userEvent.setup();\n  render(<Combobox options={[\"apple\"]} onSelect={() => {}} />);\n  const cb = screen.getByRole(\"combobox\", { name: /choose/i });\n  await user.type(cb, \"zz\");\n  expect(screen.getByRole(\"option\", { name: /no matches/i })).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\ninterface ComboboxProps {\n  options: string[];\n  onSelect: (value: string) => void;\n  label?: string;\n  id?: string;\n}\n\nexport function Combobox({ options, onSelect, label = \"Choose\", id = \"combo\" }: ComboboxProps) {\n  const [input, setInput] = React.useState(\"\");\n  const [open, setOpen] = React.useState(false);\n  const [activeIndex, setActiveIndex] = React.useState<number>(-1);\n\n  const filtered = options.filter(o => o.toLowerCase().includes(input.toLowerCase()));\n\n  const commit = (value: string) => {\n    setInput(value);\n    setOpen(false);\n    onSelect(value);\n  };\n\n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input\n        id={id}\n        role=\"combobox\"\n        aria-expanded={open}\n        aria-controls={`${id}-listbox`}\n        aria-autocomplete=\"list\"\n        value={input}\n        onChange={(e) => { setInput(e.target.value); setOpen(true); setActiveIndex(-1); }}\n        onKeyDown={(e) => {\n          if (!open && (e.key === \"ArrowDown\" || e.key === \"ArrowUp\")) setOpen(true);\n          if (e.key === \"ArrowDown\") setActiveIndex((i) => Math.min(i + 1, filtered.length - 1));\n          if (e.key === \"ArrowUp\") setActiveIndex((i) => Math.max(i - 1, 0));\n          if (e.key === \"Enter\" && activeIndex >= 0) commit(filtered[activeIndex]);\n          if (e.key === \"Escape\") setOpen(false);\n        }}\n        onBlur={() => setTimeout(() => setOpen(false), 100)}\n      />\n      {open && (\n        <ul role=\"listbox\" id={`${id}-listbox`}>\n          {filtered.length ? (\n            filtered.map((o, i) => (\n              <li\n                key={o}\n                role=\"option\"\n                aria-selected={i === activeIndex}\n                onMouseDown={(e) => e.preventDefault()}\n                onClick={() => commit(o)}\n              >\n                {o}\n              </li>\n            ))\n          ) : (\n            <li role=\"option\" aria-disabled=\"true\">No matches</li>\n          )}\n        </ul>\n      )}\n    </div>\n  );\n}",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Combobox } from \"../Combobox\";\n\ntest(\"filters and selects with keyboard\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Combobox options={[\"React\", \"Redux\", \"TypeScript\"]} onSelect={onSelect} />);\n\n  const cb = screen.getByRole(\"combobox\", { name: /choose/i });\n  await user.type(cb, \"re\");\n  const list = screen.getByRole(\"listbox\");\n  expect(list).toBeInTheDocument();\n\n  await user.keyboard(\"{ArrowDown}{Enter}\");\n  expect(onSelect).toHaveBeenCalledWith(\"React\");\n  expect(screen.queryByRole(\"listbox\")).not.toBeInTheDocument();\n});\n\ntest(\"shows no matches\", async () => {\n  const user = userEvent.setup();\n  render(<Combobox options={[\"apple\"]} onSelect={() => {}} />);\n  const cb = screen.getByRole(\"combobox\", { name: /choose/i });\n  await user.type(cb, \"zz\");\n  expect(screen.getByRole(\"option\", { name: /no matches/i })).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\ninterface ComboboxProps {\n  options: string[];\n  onSelect: (value: string) => void;\n  label?: string;\n  id?: string;\n}\n\nexport function Combobox({ options, onSelect, label = \"Choose\", id = \"combo\" }: ComboboxProps) {\n  const [input, setInput] = React.useState(\"\");\n  const [open, setOpen] = React.useState(false);\n  const [activeIndex, setActiveIndex] = React.useState<number>(-1);\n\n  const filtered = options.filter(o => o.toLowerCase().includes(input.toLowerCase()));\n\n  const commit = (value: string) => {\n    setInput(value);\n    setOpen(false);\n    onSelect(value);\n  };\n\n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input\n        id={id}\n        role=\"combobox\"\n        aria-expanded={open}\n        aria-controls={`${id}-listbox`}\n        aria-autocomplete=\"list\"\n        value={input}\n        onChange={(e) => { setInput(e.target.value); setOpen(true); setActiveIndex(-1); }}\n        onKeyDown={(e) => {\n          if (!open && (e.key === \"ArrowDown\" || e.key === \"ArrowUp\")) setOpen(true);\n          if (e.key === \"ArrowDown\") setActiveIndex((i) => Math.min(i + 1, filtered.length - 1));\n          if (e.key === \"ArrowUp\") setActiveIndex((i) => Math.max(i - 1, 0));\n          if (e.key === \"Enter\" && activeIndex >= 0) commit(filtered[activeIndex]);\n          if (e.key === \"Escape\") setOpen(false);\n        }}\n        onBlur={() => setTimeout(() => setOpen(false), 100)}\n      />\n      {open && (\n        <ul role=\"listbox\" id={`${id}-listbox`}>\n          {filtered.length ? (\n            filtered.map((o, i) => (\n              <li\n                key={o}\n                role=\"option\"\n                aria-selected={i === activeIndex}\n                onMouseDown={(e) => e.preventDefault()}\n                onClick={() => commit(o)}\n              >\n                {o}\n              </li>\n            ))\n          ) : (\n            <li role=\"option\" aria-disabled=\"true\">No matches</li>\n          )}\n        </ul>\n      )}\n    </div>\n  );\n}",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Combobox } from \"../Combobox\";\n\ntest(\"filters and selects with keyboard\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Combobox options={[\"React\", \"Redux\", \"TypeScript\"]} onSelect={onSelect} />);\n\n  const cb = screen.getByRole(\"combobox\", { name: /choose/i });\n  await user.type(cb, \"re\");\n  const list = screen.getByRole(\"listbox\");\n  expect(list).toBeInTheDocument();\n\n  await user.keyboard(\"{ArrowDown}{Enter}\");\n  expect(onSelect).toHaveBeenCalledWith(\"React\");\n  expect(screen.queryByRole(\"listbox\")).not.toBeInTheDocument();\n});\n\ntest(\"shows no matches\", async () => {\n  const user = userEvent.setup();\n  render(<Combobox options={[\"apple\"]} onSelect={() => {}} />);\n  const cb = screen.getByRole(\"combobox\", { name: /choose/i });\n  await user.type(cb, \"zz\");\n  expect(screen.getByRole(\"option\", { name: /no matches/i })).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface Row {\n  id: string;\n  name: string;\n  age: number;\n}\ninterface DataTableProps {\n  rows: Row[];\n  pageSize?: number;\n}\n\nexport function DataTable({ rows, pageSize = 5 }: DataTableProps) {\n  const [query, setQuery] = React.useState(\"\");\n  const [sort, setSort] = React.useState<{ key: \"name\" | \"age\"; dir: \"asc\" | \"desc\" }> ({\n    key: \"name\",\n    dir: \"asc\",\n  });\n  const [page, setPage] = React.useState(1);\n\n  const filtered = React.useMemo(\n    () => rows.filter(r => r.name.toLowerCase().includes(query.toLowerCase())),\n    [rows, query]\n  );\n\n  const sorted = React.useMemo(() => {\n    return [...filtered].sort((a, b) => {\n      const aV = a[sort.key];\n      const bV = b[sort.key];\n      const cmp = aV < bV ? -1 : aV > bV ? 1 : 0;\n      return sort.dir === \"asc\" ? cmp : -cmp;\n    });\n  }, [filtered, sort]);\n\n  const totalPages = Math.max(1, Math.ceil(sorted.length / pageSize));\n  const pageRows = sorted.slice((page - 1) * pageSize, page * pageSize);\n\n  React.useEffect(() => {\n    setPage(1);\n  }, [query, pageSize]);\n\n  return (\n    <div>\n      <label htmlFor=\"filter\">Filter</label>\n      <input\n        id=\"filter\"\n        placeholder=\"Search name…\"\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n      />\n\n      <table>\n        <thead>\n          <tr>\n            <th>\n              <button\n                aria-label=\"Sort by name\"\n                onClick={() =>\n                  setSort((s) => ({ key: \"name\", dir: s.key === \"name\" && s.dir === \"asc\" ? \"desc\" : \"asc\" }))\n                }\n              >\n                Name {sort.key === \"name\" ? (sort.dir === \"asc\" ? \"▲\" : \"▼\") : \"\"}\n              </button>\n            </th>\n            <th>\n              <button\n                aria-label=\"Sort by age\"\n                onClick={() =>\n                  setSort((s) => ({ key: \"age\", dir: s.key === \"age\" && s.dir === \"asc\" ? \"desc\" : \"asc\" }))\n                }\n              >\n                Age {sort.key === \"age\" ? (sort.dir === \"asc\" ? \"▲\" : \"▼\") : \"\"}\n              </button>\n            </th>\n          </tr>\n        </thead>\n        <tbody>\n          {pageRows.length ? (\n            pageRows.map((r) => (\n              <tr key={r.id}>\n                <td>{r.name}</td>\n                <td>{r.age}</td>\n              </tr>\n            ))\n          ) : (\n            <tr>\n              <td colSpan={2}>No results</td>\n            </tr>\n          )}\n        </tbody>\n      </table>\n\n      <nav aria-label=\"Pagination\">\n        <button onClick={() => setPage((p) => Math.max(1, p - 1))} disabled={page === 1}>\n          Prev\n        </button>\n        <span aria-live=\"polite\" style={{ padding: \"0 8px\" }}>\n          Page {page} of {totalPages}\n        </span>\n        <button onClick={() => setPage((p) => Math.min(totalPages, p + 1))} disabled={page === totalPages}>\n          Next\n        </button>\n      </nav>\n    </div>\n  );\n}",
    "output": "import { render, screen, within } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { DataTable } from \"../DataTable\";\n\nconst rows = [\n  { id: \"1\", name: \"Ada\", age: 30 },\n  { id: \"2\", name: \"Grace\", age: 28 },\n  { id: \"3\", name: \"Linus\", age: 35 },\n  { id: \"4\", name: \"Brendan\", age: 33 },\n  { id: \"5\", name: \"Ken\", age: 40 },\n  { id: \"6\", name: \"Dennis\", age: 45 },\n];\n\ntest(\"filters by name and shows 'No results' when empty\", async () => {\n  const user = userEvent.setup();\n  render(<DataTable rows={rows} pageSize={5} />);\n\n  await user.type(screen.getByPlaceholderText(/search name/i), \"xyz\");\n  expect(screen.getByText(/no results/i)).toBeInTheDocument();\n});\n\ntest(\"sorts by column and paginates\", async () => {\n  const user = userEvent.setup();\n  render(<DataTable rows={rows} pageSize={2} />);\n\n  const body = screen.getByRole(\"table\").querySelector(\"tbody\")!;\n  expect(within(body).getAllByRole(\"row\")[0]).toHaveTextContent(/ada/i);\n\n  await user.click(screen.getByRole(\"button\", { name: /sort by age/i }));\n  expect(within(body).getAllByRole(\"row\")[0]).toHaveTextContent(/grace/i);\n\n  await user.click(screen.getByRole(\"button\", { name: /next/i }));\n  expect(screen.getByText(/page 2 of/i)).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface Row {\n  id: string;\n  name: string;\n  age: number;\n}\ninterface DataTableProps {\n  rows: Row[];\n  pageSize?: number;\n}\n\nexport function DataTable({ rows, pageSize = 5 }: DataTableProps) {\n  const [query, setQuery] = React.useState(\"\");\n  const [sort, setSort] = React.useState<{ key: \"name\" | \"age\"; dir: \"asc\" | \"desc\" }> ({\n    key: \"name\",\n    dir: \"asc\",\n  });\n  const [page, setPage] = React.useState(1);\n\n  const filtered = React.useMemo(\n    () => rows.filter(r => r.name.toLowerCase().includes(query.toLowerCase())),\n    [rows, query]\n  );\n\n  const sorted = React.useMemo(() => {\n    return [...filtered].sort((a, b) => {\n      const aV = a[sort.key];\n      const bV = b[sort.key];\n      const cmp = aV < bV ? -1 : aV > bV ? 1 : 0;\n      return sort.dir === \"asc\" ? cmp : -cmp;\n    });\n  }, [filtered, sort]);\n\n  const totalPages = Math.max(1, Math.ceil(sorted.length / pageSize));\n  const pageRows = sorted.slice((page - 1) * pageSize, page * pageSize);\n\n  React.useEffect(() => {\n    setPage(1);\n  }, [query, pageSize]);\n\n  return (\n    <div>\n      <label htmlFor=\"filter\">Filter</label>\n      <input\n        id=\"filter\"\n        placeholder=\"Search name…\"\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n      />\n\n      <table>\n        <thead>\n          <tr>\n            <th>\n              <button\n                aria-label=\"Sort by name\"\n                onClick={() =>\n                  setSort((s) => ({ key: \"name\", dir: s.key === \"name\" && s.dir === \"asc\" ? \"desc\" : \"asc\" }))\n                }\n              >\n                Name {sort.key === \"name\" ? (sort.dir === \"asc\" ? \"▲\" : \"▼\") : \"\"}\n              </button>\n            </th>\n            <th>\n              <button\n                aria-label=\"Sort by age\"\n                onClick={() =>\n                  setSort((s) => ({ key: \"age\", dir: s.key === \"age\" && s.dir === \"asc\" ? \"desc\" : \"asc\" }))\n                }\n              >\n                Age {sort.key === \"age\" ? (sort.dir === \"asc\" ? \"▲\" : \"▼\") : \"\"}\n              </button>\n            </th>\n          </tr>\n        </thead>\n        <tbody>\n          {pageRows.length ? (\n            pageRows.map((r) => (\n              <tr key={r.id}>\n                <td>{r.name}</td>\n                <td>{r.age}</td>\n              </tr>\n            ))\n          ) : (\n            <tr>\n              <td colSpan={2}>No results</td>\n            </tr>\n          )}\n        </tbody>\n      </table>\n\n      <nav aria-label=\"Pagination\">\n        <button onClick={() => setPage((p) => Math.max(1, p - 1))} disabled={page === 1}>\n          Prev\n        </button>\n        <span aria-live=\"polite\" style={{ padding: \"0 8px\" }}>\n          Page {page} of {totalPages}\n        </span>\n        <button onClick={() => setPage((p) => Math.min(totalPages, p + 1))} disabled={page === totalPages}>\n          Next\n        </button>\n      </nav>\n    </div>\n  );\n}",
    "output": "import { render, screen, within } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { DataTable } from \"../DataTable\";\n\nconst rows = [\n  { id: \"1\", name: \"Ada\", age: 30 },\n  { id: \"2\", name: \"Grace\", age: 28 },\n  { id: \"3\", name: \"Linus\", age: 35 },\n  { id: \"4\", name: \"Brendan\", age: 33 },\n  { id: \"5\", name: \"Ken\", age: 40 },\n  { id: \"6\", name: \"Dennis\", age: 45 },\n];\n\ntest(\"filters by name and shows 'No results' when empty\", async () => {\n  const user = userEvent.setup();\n  render(<DataTable rows={rows} pageSize={5} />);\n\n  await user.type(screen.getByPlaceholderText(/search name/i), \"xyz\");\n  expect(screen.getByText(/no results/i)).toBeInTheDocument();\n});\n\ntest(\"sorts by column and paginates\", async () => {\n  const user = userEvent.setup();\n  render(<DataTable rows={rows} pageSize={2} />);\n\n  const body = screen.getByRole(\"table\").querySelector(\"tbody\")!;\n  expect(within(body).getAllByRole(\"row\")[0]).toHaveTextContent(/ada/i);\n\n  await user.click(screen.getByRole(\"button\", { name: /sort by age/i }));\n  expect(within(body).getAllByRole(\"row\")[0]).toHaveTextContent(/grace/i);\n\n  await user.click(screen.getByRole(\"button\", { name: /next/i }));\n  expect(screen.getByText(/page 2 of/i)).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface Row {\n  id: string;\n  name: string;\n  age: number;\n}\ninterface DataTableProps {\n  rows: Row[];\n  pageSize?: number;\n}\n\nexport function DataTable({ rows, pageSize = 5 }: DataTableProps) {\n  const [query, setQuery] = React.useState(\"\");\n  const [sort, setSort] = React.useState<{ key: \"name\" | \"age\"; dir: \"asc\" | \"desc\" }> ({\n    key: \"name\",\n    dir: \"asc\",\n  });\n  const [page, setPage] = React.useState(1);\n\n  const filtered = React.useMemo(\n    () => rows.filter(r => r.name.toLowerCase().includes(query.toLowerCase())),\n    [rows, query]\n  );\n\n  const sorted = React.useMemo(() => {\n    return [...filtered].sort((a, b) => {\n      const aV = a[sort.key];\n      const bV = b[sort.key];\n      const cmp = aV < bV ? -1 : aV > bV ? 1 : 0;\n      return sort.dir === \"asc\" ? cmp : -cmp;\n    });\n  }, [filtered, sort]);\n\n  const totalPages = Math.max(1, Math.ceil(sorted.length / pageSize));\n  const pageRows = sorted.slice((page - 1) * pageSize, page * pageSize);\n\n  React.useEffect(() => {\n    setPage(1);\n  }, [query, pageSize]);\n\n  return (\n    <div>\n      <label htmlFor=\"filter\">Filter</label>\n      <input\n        id=\"filter\"\n        placeholder=\"Search name…\"\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n      />\n\n      <table>\n        <thead>\n          <tr>\n            <th>\n              <button\n                aria-label=\"Sort by name\"\n                onClick={() =>\n                  setSort((s) => ({ key: \"name\", dir: s.key === \"name\" && s.dir === \"asc\" ? \"desc\" : \"asc\" }))\n                }\n              >\n                Name {sort.key === \"name\" ? (sort.dir === \"asc\" ? \"▲\" : \"▼\") : \"\"}\n              </button>\n            </th>\n            <th>\n              <button\n                aria-label=\"Sort by age\"\n                onClick={() =>\n                  setSort((s) => ({ key: \"age\", dir: s.key === \"age\" && s.dir === \"asc\" ? \"desc\" : \"asc\" }))\n                }\n              >\n                Age {sort.key === \"age\" ? (sort.dir === \"asc\" ? \"▲\" : \"▼\") : \"\"}\n              </button>\n            </th>\n          </tr>\n        </thead>\n        <tbody>\n          {pageRows.length ? (\n            pageRows.map((r) => (\n              <tr key={r.id}>\n                <td>{r.name}</td>\n                <td>{r.age}</td>\n              </tr>\n            ))\n          ) : (\n            <tr>\n              <td colSpan={2}>No results</td>\n            </tr>\n          )}\n        </tbody>\n      </table>\n\n      <nav aria-label=\"Pagination\">\n        <button onClick={() => setPage((p) => Math.max(1, p - 1))} disabled={page === 1}>\n          Prev\n        </button>\n        <span aria-live=\"polite\" style={{ padding: \"0 8px\" }}>\n          Page {page} of {totalPages}\n        </span>\n        <button onClick={() => setPage((p) => Math.min(totalPages, p + 1))} disabled={page === totalPages}>\n          Next\n        </button>\n      </nav>\n    </div>\n  );\n}",
    "output": "import { render, screen, within } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { DataTable } from \"../DataTable\";\n\nconst rows = [\n  { id: \"1\", name: \"Ada\", age: 30 },\n  { id: \"2\", name: \"Grace\", age: 28 },\n  { id: \"3\", name: \"Linus\", age: 35 },\n  { id: \"4\", name: \"Brendan\", age: 33 },\n  { id: \"5\", name: \"Ken\", age: 40 },\n  { id: \"6\", name: \"Dennis\", age: 45 },\n];\n\ntest(\"filters by name and shows 'No results' when empty\", async () => {\n  const user = userEvent.setup();\n  render(<DataTable rows={rows} pageSize={5} />);\n\n  await user.type(screen.getByPlaceholderText(/search name/i), \"xyz\");\n  expect(screen.getByText(/no results/i)).toBeInTheDocument();\n});\n\ntest(\"sorts by column and paginates\", async () => {\n  const user = userEvent.setup();\n  render(<DataTable rows={rows} pageSize={2} />);\n\n  const body = screen.getByRole(\"table\").querySelector(\"tbody\")!;\n  expect(within(body).getAllByRole(\"row\")[0]).toHaveTextContent(/ada/i);\n\n  await user.click(screen.getByRole(\"button\", { name: /sort by age/i }));\n  expect(within(body).getAllByRole(\"row\")[0]).toHaveTextContent(/grace/i);\n\n  await user.click(screen.getByRole(\"button\", { name: /next/i }));\n  expect(screen.getByText(/page 2 of/i)).toBeInTheDocument();\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import * as React from \"react\";\n\nexport interface DebouncedSearchInputProps\n  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, \"onChange\"> {\n  delay?: number;\n  onSearch: (value: string) => void | Promise<void>;\n  label?: string;\n  id?: string;\n}\n\nexport function DebouncedSearchInput({\n  delay = 300,\n  onSearch,\n  label = \"Search\",\n  id = \"search\",\n  ...rest\n}: DebouncedSearchInputProps) {\n  const [value, setValue] = React.useState(\"\");\n\n  React.useEffect(() => {\n    const handle = setTimeout(() => onSearch(value), delay);\n    return () => clearTimeout(handle);\n  }, [value, delay, onSearch]);\n\n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input\n        id={id}\n        role=\"searchbox\"\n        type=\"search\"\n        value={value}\n        onChange={(e) => setValue(e.target.value)}\n        {...rest}\n      />\n    </div>\n  );\n}",
    "output": "import { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { DebouncedSearchInput } from \"../DebouncedSearchInput\";\n\nbeforeEach(() => {\n  vi.useFakeTimers();\n});\nafterEach(() => {\n  vi.useRealTimers();\n});\n\ntest(\"calls onSearch after delay (debounced)\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<DebouncedSearchInput delay={500} onSearch={onSearch} />);\n\n  const box = screen.getByRole(\"searchbox\", { name: /search/i });\n  await user.type(box, \"react\");\n  vi.advanceTimersByTime(499);\n  expect(onSearch).not.toHaveBeenCalled();\n\n  vi.advanceTimersByTime(1);\n  await waitFor(() => expect(onSearch).toHaveBeenCalledTimes(1));\n  expect(onSearch).toHaveBeenLastCalledWith(\"react\");\n});\n\ntest(\"restarts timer on further typing\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<DebouncedSearchInput delay={300} onSearch={onSearch} />);\n\n  const box = screen.getByRole(\"searchbox\", { name: /search/i });\n  await user.type(box, \"re\");\n  vi.advanceTimersByTime(250);\n  await user.type(box, \"act\");\n  vi.advanceTimersByTime(299);\n  expect(onSearch).not.toHaveBeenCalled();\n\n  vi.advanceTimersByTime(1);\n  await waitFor(() => expect(onSearch).toHaveBeenCalledTimes(1));\n  expect(onSearch).toHaveBeenCalledWith(\"react\");\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface DebouncedSearchInputProps\n  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, \"onChange\"> {\n  delay?: number;\n  onSearch: (value: string) => void | Promise<void>;\n  label?: string;\n  id?: string;\n}\n\nexport function DebouncedSearchInput({\n  delay = 300,\n  onSearch,\n  label = \"Search\",\n  id = \"search\",\n  ...rest\n}: DebouncedSearchInputProps) {\n  const [value, setValue] = React.useState(\"\");\n\n  React.useEffect(() => {\n    const handle = setTimeout(() => onSearch(value), delay);\n    return () => clearTimeout(handle);\n  }, [value, delay, onSearch]);\n\n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input\n        id={id}\n        role=\"searchbox\"\n        type=\"search\"\n        value={value}\n        onChange={(e) => setValue(e.target.value)}\n        {...rest}\n      />\n    </div>\n  );\n}",
    "output": "import { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { DebouncedSearchInput } from \"../DebouncedSearchInput\";\n\nbeforeEach(() => {\n  vi.useFakeTimers();\n});\nafterEach(() => {\n  vi.useRealTimers();\n});\n\ntest(\"calls onSearch after delay (debounced)\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<DebouncedSearchInput delay={500} onSearch={onSearch} />);\n\n  const box = screen.getByRole(\"searchbox\", { name: /search/i });\n  await user.type(box, \"react\");\n  vi.advanceTimersByTime(499);\n  expect(onSearch).not.toHaveBeenCalled();\n\n  vi.advanceTimersByTime(1);\n  await waitFor(() => expect(onSearch).toHaveBeenCalledTimes(1));\n  expect(onSearch).toHaveBeenLastCalledWith(\"react\");\n});\n\ntest(\"restarts timer on further typing\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<DebouncedSearchInput delay={300} onSearch={onSearch} />);\n\n  const box = screen.getByRole(\"searchbox\", { name: /search/i });\n  await user.type(box, \"re\");\n  vi.advanceTimersByTime(250);\n  await user.type(box, \"act\");\n  vi.advanceTimersByTime(299);\n  expect(onSearch).not.toHaveBeenCalled();\n\n  vi.advanceTimersByTime(1);\n  await waitFor(() => expect(onSearch).toHaveBeenCalledTimes(1));\n  expect(onSearch).toHaveBeenCalledWith(\"react\");\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface DebouncedSearchInputProps\n  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, \"onChange\"> {\n  delay?: number;\n  onSearch: (value: string) => void | Promise<void>;\n  label?: string;\n  id?: string;\n}\n\nexport function DebouncedSearchInput({\n  delay = 300,\n  onSearch,\n  label = \"Search\",\n  id = \"search\",\n  ...rest\n}: DebouncedSearchInputProps) {\n  const [value, setValue] = React.useState(\"\");\n\n  React.useEffect(() => {\n    const handle = setTimeout(() => onSearch(value), delay);\n    return () => clearTimeout(handle);\n  }, [value, delay, onSearch]);\n\n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input\n        id={id}\n        role=\"searchbox\"\n        type=\"search\"\n        value={value}\n        onChange={(e) => setValue(e.target.value)}\n        {...rest}\n      />\n    </div>\n  );\n}",
    "output": "import { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { DebouncedSearchInput } from \"../DebouncedSearchInput\";\n\nbeforeEach(() => {\n  vi.useFakeTimers();\n});\nafterEach(() => {\n  vi.useRealTimers();\n});\n\ntest(\"calls onSearch after delay (debounced)\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<DebouncedSearchInput delay={500} onSearch={onSearch} />);\n\n  const box = screen.getByRole(\"searchbox\", { name: /search/i });\n  await user.type(box, \"react\");\n  vi.advanceTimersByTime(499);\n  expect(onSearch).not.toHaveBeenCalled();\n\n  vi.advanceTimersByTime(1);\n  await waitFor(() => expect(onSearch).toHaveBeenCalledTimes(1));\n  expect(onSearch).toHaveBeenLastCalledWith(\"react\");\n});\n\ntest(\"restarts timer on further typing\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<DebouncedSearchInput delay={300} onSearch={onSearch} />);\n\n  const box = screen.getByRole(\"searchbox\", { name: /search/i });\n  await user.type(box, \"re\");\n  vi.advanceTimersByTime(250);\n  await user.type(box, \"act\");\n  vi.advanceTimersByTime(299);\n  expect(onSearch).not.toHaveBeenCalled();\n\n  vi.advanceTimersByTime(1);\n  await waitFor(() => expect(onSearch).toHaveBeenCalledTimes(1));\n  expect(onSearch).toHaveBeenCalledWith(\"react\");\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\nexport interface FormProps {\n  onSubmit: (data: { email: string; password: string }) => Promise<void>;\n}\n\nexport function Form({ onSubmit }: FormProps) {\n  const [email, setEmail] = React.useState(\"\");\n  const [password, setPassword] = React.useState(\"\");\n  const [error, setError] = React.useState<string | null>(null);\n  const [loading, setLoading] = React.useState(false);\n  const isValid = /\\S+@\\S+\\.\\S+/.test(email) && password.length >= 6;\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!isValid) return;\n    setError(null);\n    setLoading(true);\n    try {\n      await onSubmit({ email, password });\n    } catch (err: any) {\n      setError(err?.message ?? \"Unknown error\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} aria-label=\"Sign in\">\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input\n          id=\"email\"\n          value={email}\n          type=\"email\"\n          onChange={(e) => setEmail(e.target.value)}\n          aria-invalid={email ? (!/\\S+@\\S+\\.\\S+/.test(email)).toString() : undefined}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password (min 6)</label>\n        <input\n          id=\"password\"\n          value={password}\n          type=\"password\"\n          onChange={(e) => setPassword(e.target.value)}\n          aria-invalid={password ? (password.length < 6).toString() : undefined}\n        />\n      </div>\n\n      {error && <div role=\"alert\">{error}</div>}\n\n      <button type=\"submit\" disabled={!isValid || loading} aria-busy={loading || undefined}>\n        {loading ? \"Signing in…\" : \"Sign in\"}\n      </button>\n    </form>\n  );\n}",
    "output": "import { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Form } from \"../Form\";\n\ntest(\"validation disables submit; enables when valid\", async () => {\n  const user = userEvent.setup();\n  const onSubmit = vi.fn().mockResolvedValue(undefined);\n  render(<Form onSubmit={onSubmit} />);\n\n  const submit = screen.getByRole(\"button\", { name: /sign in/i });\n  expect(submit).toBeDisabled();\n\n  await user.type(screen.getByLabelText(/email/i), \"user@example.com\");\n  await user.type(screen.getByLabelText(/password/i), \"secret1\");\n  expect(submit).toBeEnabled();\n\n  await user.click(submit);\n  await waitFor(() => expect(onSubmit).toHaveBeenCalledWith({ email: \"user@example.com\", password: \"secret1\" }));\n});\n\ntest(\"shows server error on rejected submit\", async () => {\n  const user = userEvent.setup();\n  const onSubmit = vi.fn().mockRejectedValue(new Error(\"Invalid credentials\"));\n  render(<Form onSubmit={onSubmit} />);\n\n  await user.type(screen.getByLabelText(/email/i), \"user@example.com\");\n  await user.type(screen.getByLabelText(/password/i), \"secret1\");\n  await user.click(screen.getByRole(\"button\", { name: /sign in/i }));\n\n  expect(screen.getByRole(\"button\", { name: /signing in…/i })).toBeDisabled();\n  await waitFor(() => expect(screen.getByRole(\"alert\")).toHaveTextContent(/invalid credentials/i));\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\nexport interface FormProps {\n  onSubmit: (data: { email: string; password: string }) => Promise<void>;\n}\n\nexport function Form({ onSubmit }: FormProps) {\n  const [email, setEmail] = React.useState(\"\");\n  const [password, setPassword] = React.useState(\"\");\n  const [error, setError] = React.useState<string | null>(null);\n  const [loading, setLoading] = React.useState(false);\n  const isValid = /\\S+@\\S+\\.\\S+/.test(email) && password.length >= 6;\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!isValid) return;\n    setError(null);\n    setLoading(true);\n    try {\n      await onSubmit({ email, password });\n    } catch (err: any) {\n      setError(err?.message ?? \"Unknown error\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} aria-label=\"Sign in\">\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input\n          id=\"email\"\n          value={email}\n          type=\"email\"\n          onChange={(e) => setEmail(e.target.value)}\n          aria-invalid={email ? (!/\\S+@\\S+\\.\\S+/.test(email)).toString() : undefined}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password (min 6)</label>\n        <input\n          id=\"password\"\n          value={password}\n          type=\"password\"\n          onChange={(e) => setPassword(e.target.value)}\n          aria-invalid={password ? (password.length < 6).toString() : undefined}\n        />\n      </div>\n\n      {error && <div role=\"alert\">{error}</div>}\n\n      <button type=\"submit\" disabled={!isValid || loading} aria-busy={loading || undefined}>\n        {loading ? \"Signing in…\" : \"Sign in\"}\n      </button>\n    </form>\n  );\n}",
    "output": "import { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Form } from \"../Form\";\n\ntest(\"validation disables submit; enables when valid\", async () => {\n  const user = userEvent.setup();\n  const onSubmit = vi.fn().mockResolvedValue(undefined);\n  render(<Form onSubmit={onSubmit} />);\n\n  const submit = screen.getByRole(\"button\", { name: /sign in/i });\n  expect(submit).toBeDisabled();\n\n  await user.type(screen.getByLabelText(/email/i), \"user@example.com\");\n  await user.type(screen.getByLabelText(/password/i), \"secret1\");\n  expect(submit).toBeEnabled();\n\n  await user.click(submit);\n  await waitFor(() => expect(onSubmit).toHaveBeenCalledWith({ email: \"user@example.com\", password: \"secret1\" }));\n});\n\ntest(\"shows server error on rejected submit\", async () => {\n  const user = userEvent.setup();\n  const onSubmit = vi.fn().mockRejectedValue(new Error(\"Invalid credentials\"));\n  render(<Form onSubmit={onSubmit} />);\n\n  await user.type(screen.getByLabelText(/email/i), \"user@example.com\");\n  await user.type(screen.getByLabelText(/password/i), \"secret1\");\n  await user.click(screen.getByRole(\"button\", { name: /sign in/i }));\n\n  expect(screen.getByRole(\"button\", { name: /signing in…/i })).toBeDisabled();\n  await waitFor(() => expect(screen.getByRole(\"alert\")).toHaveTextContent(/invalid credentials/i));\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\nexport interface FormProps {\n  onSubmit: (data: { email: string; password: string }) => Promise<void>;\n}\n\nexport function Form({ onSubmit }: FormProps) {\n  const [email, setEmail] = React.useState(\"\");\n  const [password, setPassword] = React.useState(\"\");\n  const [error, setError] = React.useState<string | null>(null);\n  const [loading, setLoading] = React.useState(false);\n  const isValid = /\\S+@\\S+\\.\\S+/.test(email) && password.length >= 6;\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!isValid) return;\n    setError(null);\n    setLoading(true);\n    try {\n      await onSubmit({ email, password });\n    } catch (err: any) {\n      setError(err?.message ?? \"Unknown error\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} aria-label=\"Sign in\">\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input\n          id=\"email\"\n          value={email}\n          type=\"email\"\n          onChange={(e) => setEmail(e.target.value)}\n          aria-invalid={email ? (!/\\S+@\\S+\\.\\S+/.test(email)).toString() : undefined}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password (min 6)</label>\n        <input\n          id=\"password\"\n          value={password}\n          type=\"password\"\n          onChange={(e) => setPassword(e.target.value)}\n          aria-invalid={password ? (password.length < 6).toString() : undefined}\n        />\n      </div>\n\n      {error && <div role=\"alert\">{error}</div>}\n\n      <button type=\"submit\" disabled={!isValid || loading} aria-busy={loading || undefined}>\n        {loading ? \"Signing in…\" : \"Sign in\"}\n      </button>\n    </form>\n  );\n}",
    "output": "import { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Form } from \"../Form\";\n\ntest(\"validation disables submit; enables when valid\", async () => {\n  const user = userEvent.setup();\n  const onSubmit = vi.fn().mockResolvedValue(undefined);\n  render(<Form onSubmit={onSubmit} />);\n\n  const submit = screen.getByRole(\"button\", { name: /sign in/i });\n  expect(submit).toBeDisabled();\n\n  await user.type(screen.getByLabelText(/email/i), \"user@example.com\");\n  await user.type(screen.getByLabelText(/password/i), \"secret1\");\n  expect(submit).toBeEnabled();\n\n  await user.click(submit);\n  await waitFor(() => expect(onSubmit).toHaveBeenCalledWith({ email: \"user@example.com\", password: \"secret1\" }));\n});\n\ntest(\"shows server error on rejected submit\", async () => {\n  const user = userEvent.setup();\n  const onSubmit = vi.fn().mockRejectedValue(new Error(\"Invalid credentials\"));\n  render(<Form onSubmit={onSubmit} />);\n\n  await user.type(screen.getByLabelText(/email/i), \"user@example.com\");\n  await user.type(screen.getByLabelText(/password/i), \"secret1\");\n  await user.click(screen.getByRole(\"button\", { name: /sign in/i }));\n\n  expect(screen.getByRole(\"button\", { name: /signing in…/i })).toBeDisabled();\n  await waitFor(() => expect(screen.getByRole(\"alert\")).toHaveTextContent(/invalid credentials/i));\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "tsx\nimport * as React from \"react\";\n\ninterface MenuPopoverProps {\n items: { id: string; label: string; onSelect: () => void }[];\n}\n\nexport function MenuPopover({ items }: MenuPopoverProps) {\n const [open, setOpen] = React.useState(false);\n const btnRef = React.useRef<HTMLButtonElement | null>(null);\n const popRef = React.useRef<HTMLDivElement | null>(null);\n\n React.useEffect(() => {\n if (!open) return;\n const onDocClick = (e: MouseEvent) => {\n if (!popRef.current || !btnRef.current) return;\n if (popRef.current.contains(e.target as Node) || btnRef.current.contains(e.target as Node)) return;\n setOpen(false);\n };\n const onKey = (e: KeyboardEvent) => { if (e.key === \"Escape\") setOpen(false); };\n document.addEventListener(\"mousedown\", onDocClick);\n document.addEventListener(\"keydown\", onKey);\n return () => {\n document.removeEventListener(\"mousedown\", onDocClick);\n document.removeEventListener(\"keydown\", onKey);\n };\n }, [open]);\n\n return (\n <div>\n <button ref={btnRef} aria-haspopup=\"menu\" aria-expanded={open} onClick={() => setOpen((o) => !o)}>\n Actions\n </button>\n {open && (\n <div role=\"menu\" ref={popRef}>\n {items.map((it) => (\n <button\n key={it.id}\n role=\"menuitem\"\n onClick={() => { it.onSelect(); setOpen(false); }}\n >\n {it.label}\n </button>\n ))}\n </div>\n )}\n </div>\n );\n}\n",
    "output": "tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { MenuPopover } from \"../MenuPopover\";\n\ntest(\"opens, selects item, and closes\", async () => {\n const user = userEvent.setup();\n const save = vi.fn();\n render(<MenuPopover items={[{ id: \"save\", label: \"Save\", onSelect: save }]} />);\n\n await user.click(screen.getByRole(\"button\", { name: /actions/i }));\n await user.click(screen.getByRole(\"menuitem\", { name: /save/i }));\n expect(save).toHaveBeenCalled();\n expect(screen.queryByRole(\"menu\")).not.toBeInTheDocument();\n});\n\ntest(\"closes on escape and outside click\", async () => {\n const user = userEvent.setup();\n render(\n <div>\n <MenuPopover items={[{ id: \"x\", label: \"X\", onSelect: () => {} }]} />\n <button>Outside</button>\n </div>\n );\n\n await user.click(screen.getByRole(\"button\", { name: /actions/i }));\n expect(screen.getByRole(\"menu\")).toBeInTheDocument();\n\n await user.keyboard(\"{Escape}\");\n expect(screen.queryByRole(\"menu\")).not.toBeInTheDocument();\n\n await user.click(screen.getByRole(\"button\", { name: /actions/i }));\n await user.click(screen.getByRole(\"button\", { name: /outside/i }));\n expect(screen.queryByRole(\"menu\")).not.toBeInTheDocument();\n});\n"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "tsx\nimport * as React from \"react\";\n\ninterface MenuPopoverProps {\n items: { id: string; label: string; onSelect: () => void }[];\n}\n\nexport function MenuPopover({ items }: MenuPopoverProps) {\n const [open, setOpen] = React.useState(false);\n const btnRef = React.useRef<HTMLButtonElement | null>(null);\n const popRef = React.useRef<HTMLDivElement | null>(null);\n\n React.useEffect(() => {\n if (!open) return;\n const onDocClick = (e: MouseEvent) => {\n if (!popRef.current || !btnRef.current) return;\n if (popRef.current.contains(e.target as Node) || btnRef.current.contains(e.target as Node)) return;\n setOpen(false);\n };\n const onKey = (e: KeyboardEvent) => { if (e.key === \"Escape\") setOpen(false); };\n document.addEventListener(\"mousedown\", onDocClick);\n document.addEventListener(\"keydown\", onKey);\n return () => {\n document.removeEventListener(\"mousedown\", onDocClick);\n document.removeEventListener(\"keydown\", onKey);\n };\n }, [open]);\n\n return (\n <div>\n <button ref={btnRef} aria-haspopup=\"menu\" aria-expanded={open} onClick={() => setOpen((o) => !o)}>\n Actions\n </button>\n {open && (\n <div role=\"menu\" ref={popRef}>\n {items.map((it) => (\n <button\n key={it.id}\n role=\"menuitem\"\n onClick={() => { it.onSelect(); setOpen(false); }}\n >\n {it.label}\n </button>\n ))}\n </div>\n )}\n </div>\n );\n}\n",
    "output": "tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { MenuPopover } from \"../MenuPopover\";\n\ntest(\"opens, selects item, and closes\", async () => {\n const user = userEvent.setup();\n const save = vi.fn();\n render(<MenuPopover items={[{ id: \"save\", label: \"Save\", onSelect: save }]} />);\n\n await user.click(screen.getByRole(\"button\", { name: /actions/i }));\n await user.click(screen.getByRole(\"menuitem\", { name: /save/i }));\n expect(save).toHaveBeenCalled();\n expect(screen.queryByRole(\"menu\")).not.toBeInTheDocument();\n});\n\ntest(\"closes on escape and outside click\", async () => {\n const user = userEvent.setup();\n render(\n <div>\n <MenuPopover items={[{ id: \"x\", label: \"X\", onSelect: () => {} }]} />\n <button>Outside</button>\n </div>\n );\n\n await user.click(screen.getByRole(\"button\", { name: /actions/i }));\n expect(screen.getByRole(\"menu\")).toBeInTheDocument();\n\n await user.keyboard(\"{Escape}\");\n expect(screen.queryByRole(\"menu\")).not.toBeInTheDocument();\n\n await user.click(screen.getByRole(\"button\", { name: /actions/i }));\n await user.click(screen.getByRole(\"button\", { name: /outside/i }));\n expect(screen.queryByRole(\"menu\")).not.toBeInTheDocument();\n});\n"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "tsx\nimport * as React from \"react\";\n\ninterface MenuPopoverProps {\n items: { id: string; label: string; onSelect: () => void }[];\n}\n\nexport function MenuPopover({ items }: MenuPopoverProps) {\n const [open, setOpen] = React.useState(false);\n const btnRef = React.useRef<HTMLButtonElement | null>(null);\n const popRef = React.useRef<HTMLDivElement | null>(null);\n\n React.useEffect(() => {\n if (!open) return;\n const onDocClick = (e: MouseEvent) => {\n if (!popRef.current || !btnRef.current) return;\n if (popRef.current.contains(e.target as Node) || btnRef.current.contains(e.target as Node)) return;\n setOpen(false);\n };\n const onKey = (e: KeyboardEvent) => { if (e.key === \"Escape\") setOpen(false); };\n document.addEventListener(\"mousedown\", onDocClick);\n document.addEventListener(\"keydown\", onKey);\n return () => {\n document.removeEventListener(\"mousedown\", onDocClick);\n document.removeEventListener(\"keydown\", onKey);\n };\n }, [open]);\n\n return (\n <div>\n <button ref={btnRef} aria-haspopup=\"menu\" aria-expanded={open} onClick={() => setOpen((o) => !o)}>\n Actions\n </button>\n {open && (\n <div role=\"menu\" ref={popRef}>\n {items.map((it) => (\n <button\n key={it.id}\n role=\"menuitem\"\n onClick={() => { it.onSelect(); setOpen(false); }}\n >\n {it.label}\n </button>\n ))}\n </div>\n )}\n </div>\n );\n}\n",
    "output": "tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { MenuPopover } from \"../MenuPopover\";\n\ntest(\"opens, selects item, and closes\", async () => {\n const user = userEvent.setup();\n const save = vi.fn();\n render(<MenuPopover items={[{ id: \"save\", label: \"Save\", onSelect: save }]} />);\n\n await user.click(screen.getByRole(\"button\", { name: /actions/i }));\n await user.click(screen.getByRole(\"menuitem\", { name: /save/i }));\n expect(save).toHaveBeenCalled();\n expect(screen.queryByRole(\"menu\")).not.toBeInTheDocument();\n});\n\ntest(\"closes on escape and outside click\", async () => {\n const user = userEvent.setup();\n render(\n <div>\n <MenuPopover items={[{ id: \"x\", label: \"X\", onSelect: () => {} }]} />\n <button>Outside</button>\n </div>\n );\n\n await user.click(screen.getByRole(\"button\", { name: /actions/i }));\n expect(screen.getByRole(\"menu\")).toBeInTheDocument();\n\n await user.keyboard(\"{Escape}\");\n expect(screen.queryByRole(\"menu\")).not.toBeInTheDocument();\n\n await user.click(screen.getByRole(\"button\", { name: /actions/i }));\n await user.click(screen.getByRole(\"button\", { name: /outside/i }));\n expect(screen.queryByRole(\"menu\")).not.toBeInTheDocument();\n});\n"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "tsx\nimport * as React from \"react\";\nimport { createPortal } from \"react-dom\";\n\ninterface ModalProps {\n open: boolean;\n onClose: () => void;\n title?: string;\n children: React.ReactNode;\n}\n\nexport function Modal({ open, onClose, title = \"Dialog\", children }: ModalProps) {\n const ref = React.useRef<HTMLDivElement | null>(null);\n\n React.useEffect(() => {\n if (!open) return;\n const onKey = (e: KeyboardEvent) => {\n if (e.key === \"Escape\") onClose();\n };\n document.addEventListener(\"keydown\", onKey);\n return () => document.removeEventListener(\"keydown\", onKey);\n }, [open, onClose]);\n\n if (!open) return null;\n\n const content = (\n <div\n aria-hidden=\"true\"\n style={{\n position: \"fixed\",\n inset: 0,\n background: \"rgba(0,0,0,0.4)\",\n display: \"grid\",\n placeItems: \"center\",\n }}\n onClick={(e) => {\n if (e.target === e.currentTarget) onClose();\n }}\n >\n <div\n role=\"dialog\"\n aria-modal=\"true\"\n aria-labelledby=\"modal-title\"\n ref={ref}\n style={{ background: \"white\", padding: 16, minWidth: 320, borderRadius: 8 }}\n >\n <h2 id=\"modal-title\" style={{ marginTop: 0 }}>{title}</h2>\n <div>{children}</div>\n <button onClick={onClose} aria-label=\"Close\">Close</button>\n </div>\n </div>\n );\n\n return typeof document !== \"undefined\"\n ? createPortal(content, document.body)\n : content;\n}\n",
    "output": "tsx\nimport * as React from \"react\";\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Modal } from \"../Modal\";\n\nfunction Wrapper() {\n const [open, setOpen] = React.useState(false);\n return (\n <div>\n <button onClick={() => setOpen(true)}>Open</button>\n <Modal open={open} onClose={() => setOpen(false)} title=\"Confirm\">\n <p>Are you sure?</p>\n </Modal>\n </div>\n );\n}\n\ntest(\"opens and closes via button and close button\", async () => {\n const user = userEvent.setup();\n render(<Wrapper />);\n\n await user.click(screen.getByRole(\"button\", { name: /open/i }));\n expect(screen.getByRole(\"dialog\", { name: /confirm/i })).toBeInTheDocument();\n\n await user.click(screen.getByRole(\"button\", { name: /close/i }));\n expect(screen.queryByRole(\"dialog\", { name: /confirm/i })).not.toBeInTheDocument();\n});\n\ntest(\"closes on backdrop click\", async () => {\n const user = userEvent.setup();\n render(<Wrapper />);\n\n await user.click(screen.getByRole(\"button\", { name: /open/i }));\n const dialog = screen.getByRole(\"dialog\", { name: /confirm/i });\n\n await user.click(dialog.parentElement as HTMLElement);\n expect(screen.queryByRole(\"dialog\", { name: /confirm/i })).not.toBeInTheDocument();\n});\n\ntest(\"closes on Escape\", async () => {\n const user = userEvent.setup();\n render(<Wrapper />);\n\n await user.click(screen.getByRole(\"button\", { name: /open/i }));\n await user.keyboard(\"{Escape}\");\n expect(screen.queryByRole(\"dialog\", { name: /confirm/i })).not.toBeInTheDocument();\n});\n"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "tsx\nimport * as React from \"react\";\nimport { createPortal } from \"react-dom\";\n\ninterface ModalProps {\n open: boolean;\n onClose: () => void;\n title?: string;\n children: React.ReactNode;\n}\n\nexport function Modal({ open, onClose, title = \"Dialog\", children }: ModalProps) {\n const ref = React.useRef<HTMLDivElement | null>(null);\n\n React.useEffect(() => {\n if (!open) return;\n const onKey = (e: KeyboardEvent) => {\n if (e.key === \"Escape\") onClose();\n };\n document.addEventListener(\"keydown\", onKey);\n return () => document.removeEventListener(\"keydown\", onKey);\n }, [open, onClose]);\n\n if (!open) return null;\n\n const content = (\n <div\n aria-hidden=\"true\"\n style={{\n position: \"fixed\",\n inset: 0,\n background: \"rgba(0,0,0,0.4)\",\n display: \"grid\",\n placeItems: \"center\",\n }}\n onClick={(e) => {\n if (e.target === e.currentTarget) onClose();\n }}\n >\n <div\n role=\"dialog\"\n aria-modal=\"true\"\n aria-labelledby=\"modal-title\"\n ref={ref}\n style={{ background: \"white\", padding: 16, minWidth: 320, borderRadius: 8 }}\n >\n <h2 id=\"modal-title\" style={{ marginTop: 0 }}>{title}</h2>\n <div>{children}</div>\n <button onClick={onClose} aria-label=\"Close\">Close</button>\n </div>\n </div>\n );\n\n return typeof document !== \"undefined\"\n ? createPortal(content, document.body)\n : content;\n}\n",
    "output": "tsx\nimport * as React from \"react\";\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Modal } from \"../Modal\";\n\nfunction Wrapper() {\n const [open, setOpen] = React.useState(false);\n return (\n <div>\n <button onClick={() => setOpen(true)}>Open</button>\n <Modal open={open} onClose={() => setOpen(false)} title=\"Confirm\">\n <p>Are you sure?</p>\n </Modal>\n </div>\n );\n}\n\ntest(\"opens and closes via button and close button\", async () => {\n const user = userEvent.setup();\n render(<Wrapper />);\n\n await user.click(screen.getByRole(\"button\", { name: /open/i }));\n expect(screen.getByRole(\"dialog\", { name: /confirm/i })).toBeInTheDocument();\n\n await user.click(screen.getByRole(\"button\", { name: /close/i }));\n expect(screen.queryByRole(\"dialog\", { name: /confirm/i })).not.toBeInTheDocument();\n});\n\ntest(\"closes on backdrop click\", async () => {\n const user = userEvent.setup();\n render(<Wrapper />);\n\n await user.click(screen.getByRole(\"button\", { name: /open/i }));\n const dialog = screen.getByRole(\"dialog\", { name: /confirm/i });\n\n await user.click(dialog.parentElement as HTMLElement);\n expect(screen.queryByRole(\"dialog\", { name: /confirm/i })).not.toBeInTheDocument();\n});\n\ntest(\"closes on Escape\", async () => {\n const user = userEvent.setup();\n render(<Wrapper />);\n\n await user.click(screen.getByRole(\"button\", { name: /open/i }));\n await user.keyboard(\"{Escape}\");\n expect(screen.queryByRole(\"dialog\", { name: /confirm/i })).not.toBeInTheDocument();\n});\n"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "tsx\nimport * as React from \"react\";\nimport { createPortal } from \"react-dom\";\n\ninterface ModalProps {\n open: boolean;\n onClose: () => void;\n title?: string;\n children: React.ReactNode;\n}\n\nexport function Modal({ open, onClose, title = \"Dialog\", children }: ModalProps) {\n const ref = React.useRef<HTMLDivElement | null>(null);\n\n React.useEffect(() => {\n if (!open) return;\n const onKey = (e: KeyboardEvent) => {\n if (e.key === \"Escape\") onClose();\n };\n document.addEventListener(\"keydown\", onKey);\n return () => document.removeEventListener(\"keydown\", onKey);\n }, [open, onClose]);\n\n if (!open) return null;\n\n const content = (\n <div\n aria-hidden=\"true\"\n style={{\n position: \"fixed\",\n inset: 0,\n background: \"rgba(0,0,0,0.4)\",\n display: \"grid\",\n placeItems: \"center\",\n }}\n onClick={(e) => {\n if (e.target === e.currentTarget) onClose();\n }}\n >\n <div\n role=\"dialog\"\n aria-modal=\"true\"\n aria-labelledby=\"modal-title\"\n ref={ref}\n style={{ background: \"white\", padding: 16, minWidth: 320, borderRadius: 8 }}\n >\n <h2 id=\"modal-title\" style={{ marginTop: 0 }}>{title}</h2>\n <div>{children}</div>\n <button onClick={onClose} aria-label=\"Close\">Close</button>\n </div>\n </div>\n );\n\n return typeof document !== \"undefined\"\n ? createPortal(content, document.body)\n : content;\n}\n",
    "output": "tsx\nimport * as React from \"react\";\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Modal } from \"../Modal\";\n\nfunction Wrapper() {\n const [open, setOpen] = React.useState(false);\n return (\n <div>\n <button onClick={() => setOpen(true)}>Open</button>\n <Modal open={open} onClose={() => setOpen(false)} title=\"Confirm\">\n <p>Are you sure?</p>\n </Modal>\n </div>\n );\n}\n\ntest(\"opens and closes via button and close button\", async () => {\n const user = userEvent.setup();\n render(<Wrapper />);\n\n await user.click(screen.getByRole(\"button\", { name: /open/i }));\n expect(screen.getByRole(\"dialog\", { name: /confirm/i })).toBeInTheDocument();\n\n await user.click(screen.getByRole(\"button\", { name: /close/i }));\n expect(screen.queryByRole(\"dialog\", { name: /confirm/i })).not.toBeInTheDocument();\n});\n\ntest(\"closes on backdrop click\", async () => {\n const user = userEvent.setup();\n render(<Wrapper />);\n\n await user.click(screen.getByRole(\"button\", { name: /open/i }));\n const dialog = screen.getByRole(\"dialog\", { name: /confirm/i });\n\n await user.click(dialog.parentElement as HTMLElement);\n expect(screen.queryByRole(\"dialog\", { name: /confirm/i })).not.toBeInTheDocument();\n});\n\ntest(\"closes on Escape\", async () => {\n const user = userEvent.setup();\n render(<Wrapper />);\n\n await user.click(screen.getByRole(\"button\", { name: /open/i }));\n await user.keyboard(\"{Escape}\");\n expect(screen.queryByRole(\"dialog\", { name: /confirm/i })).not.toBeInTheDocument();\n});\n"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "tsx\nimport * as React from \"react\";\n\nexport interface SwitchProps {\n checked: boolean;\n onChange: (checked: boolean) => void;\n id?: string;\n label?: string;\n disabled?: boolean;\n}\n\nexport function Switch({ checked, onChange, id, label, disabled }: SwitchProps) {\n const handleKeyDown = (e: React.KeyboardEvent) => {\n if (disabled) return;\n if (e.key === \" \" || e.key === \"Enter\") {\n e.preventDefault();\n onChange(!checked);\n }\n };\n\n return (\n <div>\n {label && (\n <label htmlFor={id} style={{ marginRight: 8 }}>\n {label}\n </label>\n )}\n <div\n id={id}\n role=\"switch\"\n aria-checked={checked}\n aria-disabled={disabled || undefined}\n tabIndex={disabled ? -1 : 0}\n onClick={() => !disabled && onChange(!checked)}\n onKeyDown={handleKeyDown}\n style={{\n width: 44,\n height: 24,\n borderRadius: 12,\n background: disabled ? \"#ccc\" : checked ? \"#4ade80\" : \"#e5e7eb\",\n position: \"relative\",\n cursor: disabled ? \"not-allowed\" : \"pointer\",\n outline: \"none\",\n }}\n >\n <span\n aria-hidden=\"true\"\n style={{\n position: \"absolute\",\n top: 2,\n left: checked ? 22 : 2,\n width: 20,\n height: 20,\n borderRadius: \"50%\",\n background: \"white\",\n transition: \"left 120ms\",\n }}\n />\n </div>\n </div>\n );\n}\n",
    "output": "tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Switch } from \"../Switch\";\n\ntest(\"click toggles the switch\", async () => {\n const user = userEvent.setup();\n const handle = vi.fn();\n render(<Switch checked={false} onChange={handle} label=\"Notifications\" id=\"notif\" />);\n\n const sw = screen.getByRole(\"switch\", { name: /notifications/i });\n await user.click(sw);\n expect(handle).toHaveBeenCalledWith(true);\n});\n\ntest(\"keyboard space/enter toggles\", async () => {\n const user = userEvent.setup();\n const handle = vi.fn();\n render(<Switch checked={true} onChange={handle} label=\"Wifi\" id=\"wifi\" />);\n\n const sw = screen.getByRole(\"switch\", { name: /wifi/i });\n await user.keyboard(\"[Space]\");\n await user.keyboard(\"{Enter}\");\n expect(handle).toHaveBeenCalledWith(false);\n expect(handle).toHaveBeenCalledWith(false);\n});\n\ntest(\"disabled cannot be toggled\", async () => {\n const user = userEvent.setup();\n const handle = vi.fn();\n render(<Switch checked={false} onChange={handle} label=\"Airplane mode\" disabled />);\n\n const sw = screen.getByRole(\"switch\", { name: /airplane mode/i });\n expect(sw).toHaveAttribute(\"aria-disabled\", \"true\");\n await user.click(sw);\n await user.keyboard(\"[Space]\");\n expect(handle).not.toHaveBeenCalled();\n});\n"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "tsx\nimport * as React from \"react\";\n\nexport interface SwitchProps {\n checked: boolean;\n onChange: (checked: boolean) => void;\n id?: string;\n label?: string;\n disabled?: boolean;\n}\n\nexport function Switch({ checked, onChange, id, label, disabled }: SwitchProps) {\n const handleKeyDown = (e: React.KeyboardEvent) => {\n if (disabled) return;\n if (e.key === \" \" || e.key === \"Enter\") {\n e.preventDefault();\n onChange(!checked);\n }\n };\n\n return (\n <div>\n {label && (\n <label htmlFor={id} style={{ marginRight: 8 }}>\n {label}\n </label>\n )}\n <div\n id={id}\n role=\"switch\"\n aria-checked={checked}\n aria-disabled={disabled || undefined}\n tabIndex={disabled ? -1 : 0}\n onClick={() => !disabled && onChange(!checked)}\n onKeyDown={handleKeyDown}\n style={{\n width: 44,\n height: 24,\n borderRadius: 12,\n background: disabled ? \"#ccc\" : checked ? \"#4ade80\" : \"#e5e7eb\",\n position: \"relative\",\n cursor: disabled ? \"not-allowed\" : \"pointer\",\n outline: \"none\",\n }}\n >\n <span\n aria-hidden=\"true\"\n style={{\n position: \"absolute\",\n top: 2,\n left: checked ? 22 : 2,\n width: 20,\n height: 20,\n borderRadius: \"50%\",\n background: \"white\",\n transition: \"left 120ms\",\n }}\n />\n </div>\n </div>\n );\n}\n",
    "output": "tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Switch } from \"../Switch\";\n\ntest(\"click toggles the switch\", async () => {\n const user = userEvent.setup();\n const handle = vi.fn();\n render(<Switch checked={false} onChange={handle} label=\"Notifications\" id=\"notif\" />);\n\n const sw = screen.getByRole(\"switch\", { name: /notifications/i });\n await user.click(sw);\n expect(handle).toHaveBeenCalledWith(true);\n});\n\ntest(\"keyboard space/enter toggles\", async () => {\n const user = userEvent.setup();\n const handle = vi.fn();\n render(<Switch checked={true} onChange={handle} label=\"Wifi\" id=\"wifi\" />);\n\n const sw = screen.getByRole(\"switch\", { name: /wifi/i });\n await user.keyboard(\"[Space]\");\n await user.keyboard(\"{Enter}\");\n expect(handle).toHaveBeenCalledWith(false);\n expect(handle).toHaveBeenCalledWith(false);\n});\n\ntest(\"disabled cannot be toggled\", async () => {\n const user = userEvent.setup();\n const handle = vi.fn();\n render(<Switch checked={false} onChange={handle} label=\"Airplane mode\" disabled />);\n\n const sw = screen.getByRole(\"switch\", { name: /airplane mode/i });\n expect(sw).toHaveAttribute(\"aria-disabled\", \"true\");\n await user.click(sw);\n await user.keyboard(\"[Space]\");\n expect(handle).not.toHaveBeenCalled();\n});\n"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "tsx\nimport * as React from \"react\";\n\nexport interface SwitchProps {\n checked: boolean;\n onChange: (checked: boolean) => void;\n id?: string;\n label?: string;\n disabled?: boolean;\n}\n\nexport function Switch({ checked, onChange, id, label, disabled }: SwitchProps) {\n const handleKeyDown = (e: React.KeyboardEvent) => {\n if (disabled) return;\n if (e.key === \" \" || e.key === \"Enter\") {\n e.preventDefault();\n onChange(!checked);\n }\n };\n\n return (\n <div>\n {label && (\n <label htmlFor={id} style={{ marginRight: 8 }}>\n {label}\n </label>\n )}\n <div\n id={id}\n role=\"switch\"\n aria-checked={checked}\n aria-disabled={disabled || undefined}\n tabIndex={disabled ? -1 : 0}\n onClick={() => !disabled && onChange(!checked)}\n onKeyDown={handleKeyDown}\n style={{\n width: 44,\n height: 24,\n borderRadius: 12,\n background: disabled ? \"#ccc\" : checked ? \"#4ade80\" : \"#e5e7eb\",\n position: \"relative\",\n cursor: disabled ? \"not-allowed\" : \"pointer\",\n outline: \"none\",\n }}\n >\n <span\n aria-hidden=\"true\"\n style={{\n position: \"absolute\",\n top: 2,\n left: checked ? 22 : 2,\n width: 20,\n height: 20,\n borderRadius: \"50%\",\n background: \"white\",\n transition: \"left 120ms\",\n }}\n />\n </div>\n </div>\n );\n}\n",
    "output": "tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Switch } from \"../Switch\";\n\ntest(\"click toggles the switch\", async () => {\n const user = userEvent.setup();\n const handle = vi.fn();\n render(<Switch checked={false} onChange={handle} label=\"Notifications\" id=\"notif\" />);\n\n const sw = screen.getByRole(\"switch\", { name: /notifications/i });\n await user.click(sw);\n expect(handle).toHaveBeenCalledWith(true);\n});\n\ntest(\"keyboard space/enter toggles\", async () => {\n const user = userEvent.setup();\n const handle = vi.fn();\n render(<Switch checked={true} onChange={handle} label=\"Wifi\" id=\"wifi\" />);\n\n const sw = screen.getByRole(\"switch\", { name: /wifi/i });\n await user.keyboard(\"[Space]\");\n await user.keyboard(\"{Enter}\");\n expect(handle).toHaveBeenCalledWith(false);\n expect(handle).toHaveBeenCalledWith(false);\n});\n\ntest(\"disabled cannot be toggled\", async () => {\n const user = userEvent.setup();\n const handle = vi.fn();\n render(<Switch checked={false} onChange={handle} label=\"Airplane mode\" disabled />);\n\n const sw = screen.getByRole(\"switch\", { name: /airplane mode/i });\n expect(sw).toHaveAttribute(\"aria-disabled\", \"true\");\n await user.click(sw);\n await user.keyboard(\"[Space]\");\n expect(handle).not.toHaveBeenCalled();\n});\n"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "tsx\nimport * as React from \"react\";\n\nexport interface Tab {\n id: string;\n label: string;\n panel: React.ReactNode;\n}\n\ninterface TabsProps {\n tabs: Tab[];\n defaultTabId?: string;\n}\n\nexport function Tabs({ tabs, defaultTabId }: TabsProps) {\n const [active, setActive] = React.useState(defaultTabId ?? tabs?.id);\n const tabRefs = React.useRef<Array<HTMLButtonElement | null>>([]);\n\n const index = tabs.findIndex(t => t.id === active);\n\n const onKeyDown = (e: React.KeyboardEvent) => {\n const count = tabs.length;\n if (!count) return;\n let next = index;\n if (e.key === \"ArrowRight\") next = (index + 1) % count;\n if (e.key === \"ArrowLeft\") next = (index - 1 + count) % count;\n if (next !== index) {\n e.preventDefault();\n const id = tabs[next].id;\n setActive(id);\n tabRefs.current[next]?.focus();\n }\n };\n\n return (\n <div>\n <div role=\"tablist\" aria-label=\"Sections\" onKeyDown={onKeyDown}>\n {tabs.map((t, i) => {\n const selected = t.id === active;\n return (\n <button\n key={t.id}\n role=\"tab\"\n aria-selected={selected}\n aria-controls={`${t.id}-panel`}\n id={`${t.id}-tab`}\n ref={(el) => (tabRefs.current[i] = el)}\n tabIndex={selected ? 0 : -1}\n onClick={() => setActive(t.id)}\n style={{\n padding: \"6px 10px\",\n borderBottom: selected ? \"2px solid black\" : \"2px solid transparent\",\n }}\n >\n {t.label}\n </button>\n );\n })}\n </div>\n\n {tabs.map((t) =>\n t.id === active ? (\n <div\n key={t.id}\n role=\"tabpanel\"\n id={`${t.id}-panel`}\n aria-labelledby={`${t.id}-tab`}\n style={{ paddingTop: 8 }}\n >\n {t.panel}\n </div>\n ) : null\n )}\n </div>\n );\n}\n",
    "output": "tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Tabs } from \"../Tabs\";\n\nconst tabs = [\n { id: \"general\", label: \"General\", panel: <p>General panel</p> },\n { id: \"billing\", label: \"Billing\", panel: <p>Billing panel</p> },\n { id: \"team\", label: \"Team\", panel: <p>Team panel</p> },\n];\n\ntest(\"click changes active tab and panel\", async () => {\n const user = userEvent.setup();\n render(<Tabs tabs={tabs} />);\n\n expect(screen.getByRole(\"tabpanel\")).toHaveTextContent(/general panel/i);\n\n await user.click(screen.getByRole(\"tab\", { name: /billing/i }));\n expect(screen.getByRole(\"tabpanel\")).toHaveTextContent(/billing panel/i);\n});\n\ntest(\"arrow keys move selection and focus\", async () => {\n const user = userEvent.setup();\n render(<Tabs tabs={tabs} />);\n\n const first = screen.getByRole(\"tab\", { name: /general/i });\n first.focus();\n expect(first).toHaveFocus();\n\n await user.keyboard(\"{ArrowRight}\");\n expect(screen.getByRole(\"tab\", { name: /billing/i })).toHaveFocus();\n expect(screen.getByRole(\"tabpanel\")).toHaveTextContent(/billing panel/i);\n\n await user.keyboard(\"{ArrowLeft}\");\n expect(screen.getByRole(\"tab\", { name: /general/i })).toHaveFocus();\n});\n"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "tsx\nimport * as React from \"react\";\n\nexport interface Tab {\n id: string;\n label: string;\n panel: React.ReactNode;\n}\n\ninterface TabsProps {\n tabs: Tab[];\n defaultTabId?: string;\n}\n\nexport function Tabs({ tabs, defaultTabId }: TabsProps) {\n const [active, setActive] = React.useState(defaultTabId ?? tabs?.id);\n const tabRefs = React.useRef<Array<HTMLButtonElement | null>>([]);\n\n const index = tabs.findIndex(t => t.id === active);\n\n const onKeyDown = (e: React.KeyboardEvent) => {\n const count = tabs.length;\n if (!count) return;\n let next = index;\n if (e.key === \"ArrowRight\") next = (index + 1) % count;\n if (e.key === \"ArrowLeft\") next = (index - 1 + count) % count;\n if (next !== index) {\n e.preventDefault();\n const id = tabs[next].id;\n setActive(id);\n tabRefs.current[next]?.focus();\n }\n };\n\n return (\n <div>\n <div role=\"tablist\" aria-label=\"Sections\" onKeyDown={onKeyDown}>\n {tabs.map((t, i) => {\n const selected = t.id === active;\n return (\n <button\n key={t.id}\n role=\"tab\"\n aria-selected={selected}\n aria-controls={`${t.id}-panel`}\n id={`${t.id}-tab`}\n ref={(el) => (tabRefs.current[i] = el)}\n tabIndex={selected ? 0 : -1}\n onClick={() => setActive(t.id)}\n style={{\n padding: \"6px 10px\",\n borderBottom: selected ? \"2px solid black\" : \"2px solid transparent\",\n }}\n >\n {t.label}\n </button>\n );\n })}\n </div>\n\n {tabs.map((t) =>\n t.id === active ? (\n <div\n key={t.id}\n role=\"tabpanel\"\n id={`${t.id}-panel`}\n aria-labelledby={`${t.id}-tab`}\n style={{ paddingTop: 8 }}\n >\n {t.panel}\n </div>\n ) : null\n )}\n </div>\n );\n}\n",
    "output": "tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Tabs } from \"../Tabs\";\n\nconst tabs = [\n { id: \"general\", label: \"General\", panel: <p>General panel</p> },\n { id: \"billing\", label: \"Billing\", panel: <p>Billing panel</p> },\n { id: \"team\", label: \"Team\", panel: <p>Team panel</p> },\n];\n\ntest(\"click changes active tab and panel\", async () => {\n const user = userEvent.setup();\n render(<Tabs tabs={tabs} />);\n\n expect(screen.getByRole(\"tabpanel\")).toHaveTextContent(/general panel/i);\n\n await user.click(screen.getByRole(\"tab\", { name: /billing/i }));\n expect(screen.getByRole(\"tabpanel\")).toHaveTextContent(/billing panel/i);\n});\n\ntest(\"arrow keys move selection and focus\", async () => {\n const user = userEvent.setup();\n render(<Tabs tabs={tabs} />);\n\n const first = screen.getByRole(\"tab\", { name: /general/i });\n first.focus();\n expect(first).toHaveFocus();\n\n await user.keyboard(\"{ArrowRight}\");\n expect(screen.getByRole(\"tab\", { name: /billing/i })).toHaveFocus();\n expect(screen.getByRole(\"tabpanel\")).toHaveTextContent(/billing panel/i);\n\n await user.keyboard(\"{ArrowLeft}\");\n expect(screen.getByRole(\"tab\", { name: /general/i })).toHaveFocus();\n});\n"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "tsx\nimport * as React from \"react\";\n\nexport interface Tab {\n id: string;\n label: string;\n panel: React.ReactNode;\n}\n\ninterface TabsProps {\n tabs: Tab[];\n defaultTabId?: string;\n}\n\nexport function Tabs({ tabs, defaultTabId }: TabsProps) {\n const [active, setActive] = React.useState(defaultTabId ?? tabs?.id);\n const tabRefs = React.useRef<Array<HTMLButtonElement | null>>([]);\n\n const index = tabs.findIndex(t => t.id === active);\n\n const onKeyDown = (e: React.KeyboardEvent) => {\n const count = tabs.length;\n if (!count) return;\n let next = index;\n if (e.key === \"ArrowRight\") next = (index + 1) % count;\n if (e.key === \"ArrowLeft\") next = (index - 1 + count) % count;\n if (next !== index) {\n e.preventDefault();\n const id = tabs[next].id;\n setActive(id);\n tabRefs.current[next]?.focus();\n }\n };\n\n return (\n <div>\n <div role=\"tablist\" aria-label=\"Sections\" onKeyDown={onKeyDown}>\n {tabs.map((t, i) => {\n const selected = t.id === active;\n return (\n <button\n key={t.id}\n role=\"tab\"\n aria-selected={selected}\n aria-controls={`${t.id}-panel`}\n id={`${t.id}-tab`}\n ref={(el) => (tabRefs.current[i] = el)}\n tabIndex={selected ? 0 : -1}\n onClick={() => setActive(t.id)}\n style={{\n padding: \"6px 10px\",\n borderBottom: selected ? \"2px solid black\" : \"2px solid transparent\",\n }}\n >\n {t.label}\n </button>\n );\n })}\n </div>\n\n {tabs.map((t) =>\n t.id === active ? (\n <div\n key={t.id}\n role=\"tabpanel\"\n id={`${t.id}-panel`}\n aria-labelledby={`${t.id}-tab`}\n style={{ paddingTop: 8 }}\n >\n {t.panel}\n </div>\n ) : null\n )}\n </div>\n );\n}\n",
    "output": "tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Tabs } from \"../Tabs\";\n\nconst tabs = [\n { id: \"general\", label: \"General\", panel: <p>General panel</p> },\n { id: \"billing\", label: \"Billing\", panel: <p>Billing panel</p> },\n { id: \"team\", label: \"Team\", panel: <p>Team panel</p> },\n];\n\ntest(\"click changes active tab and panel\", async () => {\n const user = userEvent.setup();\n render(<Tabs tabs={tabs} />);\n\n expect(screen.getByRole(\"tabpanel\")).toHaveTextContent(/general panel/i);\n\n await user.click(screen.getByRole(\"tab\", { name: /billing/i }));\n expect(screen.getByRole(\"tabpanel\")).toHaveTextContent(/billing panel/i);\n});\n\ntest(\"arrow keys move selection and focus\", async () => {\n const user = userEvent.setup();\n render(<Tabs tabs={tabs} />);\n\n const first = screen.getByRole(\"tab\", { name: /general/i });\n first.focus();\n expect(first).toHaveFocus();\n\n await user.keyboard(\"{ArrowRight}\");\n expect(screen.getByRole(\"tab\", { name: /billing/i })).toHaveFocus();\n expect(screen.getByRole(\"tabpanel\")).toHaveTextContent(/billing panel/i);\n\n await user.keyboard(\"{ArrowLeft}\");\n expect(screen.getByRole(\"tab\", { name: /general/i })).toHaveFocus();\n});\n"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "tsx\nimport * as React from \"react\";\n\nexport function Toast({ message, duration = 2000 }: { message: string; duration?: number }) {\n const [open, setOpen] = React.useState(true);\n const hoverRef = React.useRef(false);\n React.useEffect(() => {\n if (!open) return;\n let remaining = duration;\n let start = Date.now();\n let timer: number | undefined;\n\n const tick = () => {\n timer = window.setTimeout(() => {\n if (hoverRef.current) {\n start = Date.now();\n tick();\n } else {\n const elapsed = Date.now() - start;\n remaining -= elapsed;\n if (remaining <= 0) setOpen(false);\n else {\n start = Date.now();\n tick();\n }\n }\n }, 50);\n };\n tick();\n return () => clearTimeout(timer);\n }, [duration, open]);\n\n if (!open) return null;\n return (\n <div\n role=\"status\"\n onMouseEnter={() => (hoverRef.current = true)}\n onMouseLeave={() => (hoverRef.current = false)}\n >\n {message}\n </div>\n );\n}\n",
    "output": "tsx\nimport { render, screen } from \"@testing-library/react\";\nimport { Toast } from \"../Toast\";\n\nbeforeEach(() => vi.useFakeTimers());\nafterEach(() => vi.useRealTimers());\n\ntest(\"auto-dismisses after duration\", () => {\n render(<Toast message=\"Saved\" duration={200} />);\n expect(screen.getByRole(\"status\", { name: /saved/i })).toBeInTheDocument();\n vi.advanceTimersByTime(500);\n expect(screen.queryByRole(\"status\")).not.toBeInTheDocument();\n});\n\ntest(\"pauses while hovered\", () => {\n render(<Toast message=\"Saved\" duration={200} />);\n const toast = screen.getByRole(\"status\");\n toast.dispatchEvent(new MouseEvent(\"mouseenter\", { bubbles: true }));\n vi.advanceTimersByTime(1000);\n expect(screen.getByRole(\"status\")).toBeInTheDocument();\n toast.dispatchEvent(new MouseEvent(\"mouseleave\", { bubbles: true }));\n vi.advanceTimersByTime(300);\n expect(screen.queryByRole(\"status\")).not.toBeInTheDocument();\n});\n"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "tsx\nimport * as React from \"react\";\n\nexport function Toast({ message, duration = 2000 }: { message: string; duration?: number }) {\n const [open, setOpen] = React.useState(true);\n const hoverRef = React.useRef(false);\n React.useEffect(() => {\n if (!open) return;\n let remaining = duration;\n let start = Date.now();\n let timer: number | undefined;\n\n const tick = () => {\n timer = window.setTimeout(() => {\n if (hoverRef.current) {\n start = Date.now();\n tick();\n } else {\n const elapsed = Date.now() - start;\n remaining -= elapsed;\n if (remaining <= 0) setOpen(false);\n else {\n start = Date.now();\n tick();\n }\n }\n }, 50);\n };\n tick();\n return () => clearTimeout(timer);\n }, [duration, open]);\n\n if (!open) return null;\n return (\n <div\n role=\"status\"\n onMouseEnter={() => (hoverRef.current = true)}\n onMouseLeave={() => (hoverRef.current = false)}\n >\n {message}\n </div>\n );\n}\n",
    "output": "tsx\nimport { render, screen } from \"@testing-library/react\";\nimport { Toast } from \"../Toast\";\n\nbeforeEach(() => vi.useFakeTimers());\nafterEach(() => vi.useRealTimers());\n\ntest(\"auto-dismisses after duration\", () => {\n render(<Toast message=\"Saved\" duration={200} />);\n expect(screen.getByRole(\"status\", { name: /saved/i })).toBeInTheDocument();\n vi.advanceTimersByTime(500);\n expect(screen.queryByRole(\"status\")).not.toBeInTheDocument();\n});\n\ntest(\"pauses while hovered\", () => {\n render(<Toast message=\"Saved\" duration={200} />);\n const toast = screen.getByRole(\"status\");\n toast.dispatchEvent(new MouseEvent(\"mouseenter\", { bubbles: true }));\n vi.advanceTimersByTime(1000);\n expect(screen.getByRole(\"status\")).toBeInTheDocument();\n toast.dispatchEvent(new MouseEvent(\"mouseleave\", { bubbles: true }));\n vi.advanceTimersByTime(300);\n expect(screen.queryByRole(\"status\")).not.toBeInTheDocument();\n});\n"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "tsx\nimport * as React from \"react\";\n\nexport function Toast({ message, duration = 2000 }: { message: string; duration?: number }) {\n const [open, setOpen] = React.useState(true);\n const hoverRef = React.useRef(false);\n React.useEffect(() => {\n if (!open) return;\n let remaining = duration;\n let start = Date.now();\n let timer: number | undefined;\n\n const tick = () => {\n timer = window.setTimeout(() => {\n if (hoverRef.current) {\n start = Date.now();\n tick();\n } else {\n const elapsed = Date.now() - start;\n remaining -= elapsed;\n if (remaining <= 0) setOpen(false);\n else {\n start = Date.now();\n tick();\n }\n }\n }, 50);\n };\n tick();\n return () => clearTimeout(timer);\n }, [duration, open]);\n\n if (!open) return null;\n return (\n <div\n role=\"status\"\n onMouseEnter={() => (hoverRef.current = true)}\n onMouseLeave={() => (hoverRef.current = false)}\n >\n {message}\n </div>\n );\n}\n",
    "output": "tsx\nimport { render, screen } from \"@testing-library/react\";\nimport { Toast } from \"../Toast\";\n\nbeforeEach(() => vi.useFakeTimers());\nafterEach(() => vi.useRealTimers());\n\ntest(\"auto-dismisses after duration\", () => {\n render(<Toast message=\"Saved\" duration={200} />);\n expect(screen.getByRole(\"status\", { name: /saved/i })).toBeInTheDocument();\n vi.advanceTimersByTime(500);\n expect(screen.queryByRole(\"status\")).not.toBeInTheDocument();\n});\n\ntest(\"pauses while hovered\", () => {\n render(<Toast message=\"Saved\" duration={200} />);\n const toast = screen.getByRole(\"status\");\n toast.dispatchEvent(new MouseEvent(\"mouseenter\", { bubbles: true }));\n vi.advanceTimersByTime(1000);\n expect(screen.getByRole(\"status\")).toBeInTheDocument();\n toast.dispatchEvent(new MouseEvent(\"mouseleave\", { bubbles: true }));\n vi.advanceTimersByTime(300);\n expect(screen.queryByRole(\"status\")).not.toBeInTheDocument();\n});\n"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import * as React from \"react\";\n\ninterface VirtualListProps<T> {\n  items: T[];\n  itemHeight: number;\n  height: number;\n  renderItem: (item: T, index: number) => React.ReactNode;\n}\n\nexport function VirtualList<T>({ items, itemHeight, height, renderItem }: VirtualListProps<T>) {\n  const [scrollTop, setScrollTop] = React.useState(0);\n  const total = items.length * itemHeight;\n  const start = Math.floor(scrollTop / itemHeight);\n  const visibleCount = Math.ceil(height / itemHeight) + 1;\n  const end = Math.min(items.length, start + visibleCount);\n  const offsetY = start * itemHeight;\n\n  return (\n    <div\n      role=\"list\"\n      style={{ overflow: \"auto\", position: \"relative\", height }}\n      onScroll={(e) => setScrollTop((e.target as HTMLDivElement).scrollTop)}\n    >\n      <div style={{ height: total, position: \"relative\" }}>\n        <div style={{ position: \"absolute\", top: offsetY, left: 0, right: 0 }}>\n          {items.slice(start, end).map((item, i) => (\n            <div role=\"listitem\" key={start + i} style={{ height: itemHeight }}>\n              {renderItem(item, start + i)}\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { VirtualList } from \"../VirtualList\";\n\nfunction make(n: number) {\n  return Array.from({ length: n }, (_, i) => `Row ${i}`);\n}\n\ntest(\"renders only visible items and updates on scroll\", async () => {\n  const user = userEvent.setup();\n  render(\n    <VirtualList\n      items={make(100)}\n      itemHeight={20}\n      height={100}\n      renderItem={(item) => <span>{item}</span>}\n    />\n  );\n\n  const items = screen.getAllByRole(\"listitem\");\n  expect(items.length).toBeGreaterThanOrEqual(5);\n  expect(items).toHaveTextContent(\"Row 0\");\n\n  const list = screen.getByRole(\"list\");\n  list.scrollTop = 200;\n  list.dispatchEvent(new Event(\"scroll\"));\n  const after = screen.getAllByRole(\"listitem\");\n  expect(after).toHaveTextContent(/row 10/i);\n});"
  },
  {
    "instruction": "Create unit tests that check rendering, props, and events using React Testing Library.",
    "input": "import * as React from \"react\";\n\ninterface VirtualListProps<T> {\n  items: T[];\n  itemHeight: number;\n  height: number;\n  renderItem: (item: T, index: number) => React.ReactNode;\n}\n\nexport function VirtualList<T>({ items, itemHeight, height, renderItem }: VirtualListProps<T>) {\n  const [scrollTop, setScrollTop] = React.useState(0);\n  const total = items.length * itemHeight;\n  const start = Math.floor(scrollTop / itemHeight);\n  const visibleCount = Math.ceil(height / itemHeight) + 1;\n  const end = Math.min(items.length, start + visibleCount);\n  const offsetY = start * itemHeight;\n\n  return (\n    <div\n      role=\"list\"\n      style={{ overflow: \"auto\", position: \"relative\", height }}\n      onScroll={(e) => setScrollTop((e.target as HTMLDivElement).scrollTop)}\n    >\n      <div style={{ height: total, position: \"relative\" }}>\n        <div style={{ position: \"absolute\", top: offsetY, left: 0, right: 0 }}>\n          {items.slice(start, end).map((item, i) => (\n            <div role=\"listitem\" key={start + i} style={{ height: itemHeight }}>\n              {renderItem(item, start + i)}\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { VirtualList } from \"../VirtualList\";\n\nfunction make(n: number) {\n  return Array.from({ length: n }, (_, i) => `Row ${i}`);\n}\n\ntest(\"renders only visible items and updates on scroll\", async () => {\n  const user = userEvent.setup();\n  render(\n    <VirtualList\n      items={make(100)}\n      itemHeight={20}\n      height={100}\n      renderItem={(item) => <span>{item}</span>}\n    />\n  );\n\n  const items = screen.getAllByRole(\"listitem\");\n  expect(items.length).toBeGreaterThanOrEqual(5);\n  expect(items).toHaveTextContent(\"Row 0\");\n\n  const list = screen.getByRole(\"list\");\n  list.scrollTop = 200;\n  list.dispatchEvent(new Event(\"scroll\"));\n  const after = screen.getAllByRole(\"listitem\");\n  expect(after).toHaveTextContent(/row 10/i);\n});"
  },
  {
    "instruction": "Generate Jest tests ensuring the component behaves correctly with different props.",
    "input": "import * as React from \"react\";\n\ninterface VirtualListProps<T> {\n  items: T[];\n  itemHeight: number;\n  height: number;\n  renderItem: (item: T, index: number) => React.ReactNode;\n}\n\nexport function VirtualList<T>({ items, itemHeight, height, renderItem }: VirtualListProps<T>) {\n  const [scrollTop, setScrollTop] = React.useState(0);\n  const total = items.length * itemHeight;\n  const start = Math.floor(scrollTop / itemHeight);\n  const visibleCount = Math.ceil(height / itemHeight) + 1;\n  const end = Math.min(items.length, start + visibleCount);\n  const offsetY = start * itemHeight;\n\n  return (\n    <div\n      role=\"list\"\n      style={{ overflow: \"auto\", position: \"relative\", height }}\n      onScroll={(e) => setScrollTop((e.target as HTMLDivElement).scrollTop)}\n    >\n      <div style={{ height: total, position: \"relative\" }}>\n        <div style={{ position: \"absolute\", top: offsetY, left: 0, right: 0 }}>\n          {items.slice(start, end).map((item, i) => (\n            <div role=\"listitem\" key={start + i} style={{ height: itemHeight }}>\n              {renderItem(item, start + i)}\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { VirtualList } from \"../VirtualList\";\n\nfunction make(n: number) {\n  return Array.from({ length: n }, (_, i) => `Row ${i}`);\n}\n\ntest(\"renders only visible items and updates on scroll\", async () => {\n  const user = userEvent.setup();\n  render(\n    <VirtualList\n      items={make(100)}\n      itemHeight={20}\n      height={100}\n      renderItem={(item) => <span>{item}</span>}\n    />\n  );\n\n  const items = screen.getAllByRole(\"listitem\");\n  expect(items.length).toBeGreaterThanOrEqual(5);\n  expect(items).toHaveTextContent(\"Row 0\");\n\n  const list = screen.getByRole(\"list\");\n  list.scrollTop = 200;\n  list.dispatchEvent(new Event(\"scroll\"));\n  const after = screen.getAllByRole(\"listitem\");\n  expect(after).toHaveTextContent(/row 10/i);\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen, fireEvent } from '@testing-library/react';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/Count:/)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button is clicked', () => {\n    render(<Counter />);\n    fireEvent.click(screen.getByText(/Increment/));\n    expect(screen.getByText(/Count:/)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and user interactions.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with name', () => {\n    render(<Greeting name=\"John\" />);\n    expect(screen.getByRole('heading')).toHaveTextContent('Hello, John!');\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return (\n    <div>\n      <button onClick={() => setOn(!on)}>{on ? 'ON' : 'OFF'}</button>\n    </div>\n  );\n}",
    "output": "import { render, screen, fireEvent } from '@testing-library/react';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders OFF initially', () => {\n    render(<Toggle />);\n    expect(screen.getByText('OFF')).toBeInTheDocument();\n  });\n\n  it('toggles ON/OFF when button is clicked', () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button');\n    fireEvent.click(btn);\n    expect(btn).toHaveTextContent('ON');\n    fireEvent.click(btn);\n    expect(btn).toHaveTextContent('OFF');\n  });\n});"
  },

  {
    "instruction": "Write RTL + Jest tests that verify rendering and user-interaction using accessible queries and user-event.",
    "input": "import React, { useState } from 'react';\n\nfunction ToggleSwitch({ initialOn = false }) {\n  const [on, setOn] = useState(initialOn);\n  return (\n    <div>\n      <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>\n    </div>\n  );\n}\n\nexport default ToggleSwitch;",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport ToggleSwitch from './ToggleSwitch';\n\ndescribe('ToggleSwitch', () => {\n  it('renders with initial state Off when initialOn is false', () => {\n    render(<ToggleSwitch initialOn={false} />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    expect(btn).toHaveTextContent('Off');\n  });\n\n  it('toggles state when button clicked', async () => {\n    render(<ToggleSwitch initialOn={false} />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Generate a test suite with React Testing Library & Jest that covers component rendering, props, and async behavior using findByRole.",
    "input": "import React, { useEffect, useState } from 'react';\n\nfunction GreetingLoader({ userId }) {\n  const [name, setName] = useState('');\n  useEffect(() => {\n    setTimeout(() => {\n      setName('User ' + userId);\n    }, 500);\n  }, [userId]);\n  return <h1>{name ? `Hello, ${name}` : 'Loading...'}</h1>;\n}\n\nexport default GreetingLoader;",
    "output": "import { render, screen } from '@testing-library/react';\nimport GreetingLoader from './GreetingLoader';\n\ndescribe('GreetingLoader', () => {\n  it('shows loading initially then greeting after async update', async () => {\n    render(<GreetingLoader userId={42} />);\n    expect(screen.getByText(/loading.../i)).toBeInTheDocument();\n    const heading = await screen.findByRole('heading', { name: /hello, user 42/i });\n    expect(heading).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Create unit tests using accessible queries, screen, and user-event for a form component.",
    "input": "import React, { useState } from 'react';\n\nfunction LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={(e) => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={(e) => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={(e) => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n\nexport default LoginForm;",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('renders form fields and submits with correct values', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    const usernameInput = screen.getByLabelText(/username/i);\n    const passwordInput = screen.getByLabelText(/password/i);\n    await user.type(usernameInput, 'alice');\n    await user.type(passwordInput, 'secret');\n    const btn = screen.getByRole('button', { name: /login/i });\n    await user.click(btn);\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'alice', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Write tests that check conditional rendering using getByRole and queryByRole correctly.",
    "input": "import React, { useState } from 'react';\n\nfunction ExpandableText({ text }) {\n  const [expanded, setExpanded] = useState(false);\n  return (\n    <div>\n      <p>{expanded ? text : text.substring(0, 100) + '...'}</p>\n      <button onClick={() => setExpanded(!expanded)}>\n        {expanded ? 'Show Less' : 'Read More'}\n      </button>\n    </div>\n  );\n}\n\nexport default ExpandableText;",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport ExpandableText from './ExpandableText';\n\ndescribe('ExpandableText', () => {\n  const longText = 'A'.repeat(200);\n  it('shows truncated text and Read More button initially', () => {\n    render(<ExpandableText text={longText} />);\n    const btn = screen.getByRole('button', { name: /read more/i });\n    expect(btn).toBeInTheDocument();\n    expect(screen.getByText(/...$/)).toBeInTheDocument();\n  });\n\n  it('shows full text and Show Less when button clicked', async () => {\n    render(<ExpandableText text={longText} />);\n    const btn = screen.getByRole('button', { name: /read more/i });\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /show less/i })).toBeInTheDocument();\n    expect(screen.getByText(longText)).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Generate tests verifying that a button becomes disabled under certain prop conditions using Jest-DOM matchers.",
    "input": "import React from 'react';\n\nfunction SubmitButton({ disabled }) {\n  return <button disabled={disabled}>Submit</button>;\n}\n\nexport default SubmitButton;",
    "output": "import { render, screen } from '@testing-library/react';\nimport SubmitButton from './SubmitButton';\n\ndescribe('SubmitButton', () => {\n  it('is enabled by default', () => {\n    render(<SubmitButton disabled={false} />);\n    const btn = screen.getByRole('button', { name: /submit/i });\n    expect(btn).not.toBeDisabled();\n  });\n\n  it('is disabled when disabled prop is true', () => {\n    render(<SubmitButton disabled={true} />);\n    const btn = screen.getByRole('button', { name: /submit/i });\n    expect(btn).toBeDisabled();\n  });\n});"
  },

  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React from 'react';\n\nexport default function SubmitButton({ disabled }) {\n  return <button disabled={disabled}>Submit</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport SubmitButton from './SubmitButton';\n\ndescribe('SubmitButton', () => {\n  it('is enabled when disabled prop is false', () => {\n    render(<SubmitButton disabled={false} />);\n    expect(screen.getByRole('button', { name: /submit/i })).not.toBeDisabled();\n  });\n  it('is disabled when disabled prop is true', () => {\n    render(<SubmitButton disabled />);\n    expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React from 'react';\n\nexport default function SubmitButton({ disabled }) {\n  return <button disabled={disabled}>Submit</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport SubmitButton from './SubmitButton';\n\ndescribe('SubmitButton', () => {\n  it('is enabled when disabled prop is false', () => {\n    render(<SubmitButton disabled={false} />);\n    expect(screen.getByRole('button', { name: /submit/i })).not.toBeDisabled();\n  });\n  it('is disabled when disabled prop is true', () => {\n    render(<SubmitButton disabled />);\n    expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and interactions.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and interactions.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and interactions.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React from 'react';\n\nexport default function SubmitButton({ disabled }) {\n  return <button disabled={disabled}>Submit</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport SubmitButton from './SubmitButton';\n\ndescribe('SubmitButton', () => {\n  it('is enabled when disabled prop is false', () => {\n    render(<SubmitButton disabled={false} />);\n    expect(screen.getByRole('button', { name: /submit/i })).not.toBeDisabled();\n  });\n  it('is disabled when disabled prop is true', () => {\n    render(<SubmitButton disabled />);\n    expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and interactions.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React from 'react';\n\nexport default function SubmitButton({ disabled }) {\n  return <button disabled={disabled}>Submit</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport SubmitButton from './SubmitButton';\n\ndescribe('SubmitButton', () => {\n  it('is enabled when disabled prop is false', () => {\n    render(<SubmitButton disabled={false} />);\n    expect(screen.getByRole('button', { name: /submit/i })).not.toBeDisabled();\n  });\n  it('is disabled when disabled prop is true', () => {\n    render(<SubmitButton disabled />);\n    expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React from 'react';\n\nexport default function SubmitButton({ disabled }) {\n  return <button disabled={disabled}>Submit</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport SubmitButton from './SubmitButton';\n\ndescribe('SubmitButton', () => {\n  it('is enabled when disabled prop is false', () => {\n    render(<SubmitButton disabled={false} />);\n    expect(screen.getByRole('button', { name: /submit/i })).not.toBeDisabled();\n  });\n  it('is disabled when disabled prop is true', () => {\n    render(<SubmitButton disabled />);\n    expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and interactions.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React from 'react';\n\nexport default function SubmitButton({ disabled }) {\n  return <button disabled={disabled}>Submit</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport SubmitButton from './SubmitButton';\n\ndescribe('SubmitButton', () => {\n  it('is enabled when disabled prop is false', () => {\n    render(<SubmitButton disabled={false} />);\n    expect(screen.getByRole('button', { name: /submit/i })).not.toBeDisabled();\n  });\n  it('is disabled when disabled prop is true', () => {\n    render(<SubmitButton disabled />);\n    expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and interactions.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and interactions.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and interactions.",
    "input": "import React from 'react';\n\nexport default function SubmitButton({ disabled }) {\n  return <button disabled={disabled}>Submit</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport SubmitButton from './SubmitButton';\n\ndescribe('SubmitButton', () => {\n  it('is enabled when disabled prop is false', () => {\n    render(<SubmitButton disabled={false} />);\n    expect(screen.getByRole('button', { name: /submit/i })).not.toBeDisabled();\n  });\n  it('is disabled when disabled prop is true', () => {\n    render(<SubmitButton disabled />);\n    expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function LoginForm({ onSubmit }) {\n  const [username, setUsername] = useState('');\n  const [password, setPassword] = useState('');\n  return (\n    <form onSubmit={e => { e.preventDefault(); onSubmit({ username, password }); }}>\n      <label htmlFor=\"username\">Username</label>\n      <input id=\"username\" value={username} onChange={e => setUsername(e.target.value)} />\n      <label htmlFor=\"password\">Password</label>\n      <input id=\"password\" type=\"password\" value={password} onChange={e => setPassword(e.target.value)} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginForm from './LoginForm';\n\ndescribe('LoginForm', () => {\n  it('submits username and password', async () => {\n    const handleSubmit = jest.fn();\n    render(<LoginForm onSubmit={handleSubmit} />);\n    const user = userEvent.setup();\n    await user.type(screen.getByLabelText(/username/i), 'bob');\n    await user.type(screen.getByLabelText(/password/i), 'secret');\n    await user.click(screen.getByRole('button', { name: /login/i }));\n    expect(handleSubmit).toHaveBeenCalledWith({ username: 'bob', password: 'secret' });\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React from 'react';\n\nexport default function SubmitButton({ disabled }) {\n  return <button disabled={disabled}>Submit</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport SubmitButton from './SubmitButton';\n\ndescribe('SubmitButton', () => {\n  it('is enabled when disabled prop is false', () => {\n    render(<SubmitButton disabled={false} />);\n    expect(screen.getByRole('button', { name: /submit/i })).not.toBeDisabled();\n  });\n  it('is disabled when disabled prop is true', () => {\n    render(<SubmitButton disabled />);\n    expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and interactions.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React from 'react';\n\nexport default function SubmitButton({ disabled }) {\n  return <button disabled={disabled}>Submit</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport SubmitButton from './SubmitButton';\n\ndescribe('SubmitButton', () => {\n  it('is enabled when disabled prop is false', () => {\n    render(<SubmitButton disabled={false} />);\n    expect(screen.getByRole('button', { name: /submit/i })).not.toBeDisabled();\n  });\n  it('is disabled when disabled prop is true', () => {\n    render(<SubmitButton disabled />);\n    expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();\n  });\n});"
  },
  {
    "instruction": "Create tests using screen queries and user-event to simulate user behavior.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React from 'react';\n\nexport default function Greeting({ name }) {\n  return <h1>Hello, {name}!</h1>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport Greeting from './Greeting';\n\ndescribe('Greeting', () => {\n  it('renders greeting with provided name', () => {\n    render(<Greeting name=\"Alice\" />);\n    expect(screen.getByRole('heading', { name: /hello, alice/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write unit tests using React Testing Library and Jest for this component.",
    "input": "import React from 'react';\n\nexport default function SubmitButton({ disabled }) {\n  return <button disabled={disabled}>Submit</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport SubmitButton from './SubmitButton';\n\ndescribe('SubmitButton', () => {\n  it('is enabled when disabled prop is false', () => {\n    render(<SubmitButton disabled={false} />);\n    expect(screen.getByRole('button', { name: /submit/i })).not.toBeDisabled();\n  });\n  it('is disabled when disabled prop is true', () => {\n    render(<SubmitButton disabled />);\n    expect(screen.getByRole('button', { name: /submit/i })).toBeDisabled();\n  });\n});"
  },
  {
    "instruction": "Generate RTL + Jest tests that verify rendering and interactions.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  },
  {
    "instruction": "Write tests that check rendering, props, and events using accessible queries.",
    "input": "import React, { useState } from 'react';\n\nexport default function Counter() {\n  const [count, setCount] = useState(0);\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Counter from './Counter';\n\ndescribe('Counter', () => {\n  it('renders initial count', () => {\n    render(<Counter />);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 0');\n  });\n\n  it('increments count when button clicked', async () => {\n    render(<Counter />);\n    const btn = screen.getByRole('button', { name: /increment/i });\n    await userEvent.click(btn);\n    expect(screen.getByText(/count:/i)).toHaveTextContent('Count: 1');\n  });\n});"
  },
  {
    "instruction": "Produce a Jest test suite with @testing-library/react for the given component.",
    "input": "import React, { useState } from 'react';\n\nexport default function Toggle() {\n  const [on, setOn] = useState(false);\n  return <button onClick={() => setOn(!on)}>{on ? 'On' : 'Off'}</button>;\n}",
    "output": "import { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Toggle from './Toggle';\n\ndescribe('Toggle', () => {\n  it('renders Off initially and toggles', async () => {\n    render(<Toggle />);\n    const btn = screen.getByRole('button', { name: /off/i });\n    expect(btn).toBeInTheDocument();\n    await userEvent.click(btn);\n    expect(screen.getByRole('button', { name: /on/i })).toBeInTheDocument();\n  });\n});"
  }
]
