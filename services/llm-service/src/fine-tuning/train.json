[
  {
    "instruction": "Generate a comprehensive Jest unit test for the following React component using React Testing Library.\n\nFollow these critical best practices and avoid common mistakes:\n\n• **Query by User-Facing Attributes**: Prioritize querying elements the way a user would find them. Use roles, labels, and text (getByRole, getByLabelText, getByText). Avoid implementation details like class names or relying on data-testid as a first resort.\n• **Use screen for Queries**: Always use the screen object for querying the DOM (screen.getByRole(...)). Do not destructure query methods from render.\n• **Prefer user-event over fireEvent**: Use @testing-library/user-event for simulating user interactions as it more closely resembles real browser behavior.\n• **Use *By for Presence, queryBy for Absence**: Use getBy.../getAllBy... to assert an element is present (throws error if not found). Use queryBy.../queryAllBy... to assert an element is NOT present (returns null if not found).\n• **Use findBy for Asynchronous Appearance**: Use findBy.../findAllBy... to find elements that will appear asynchronously after an action.\n• **Avoid Testing Implementation Details**: Don't test internal state, class names, or component structure. Focus on user-observable behavior.\n• **Don't Use container.querySelector**: Avoid DOM traversal APIs that bypass accessibility.\n• **Test Accessibility**: Verify ARIA attributes, roles, and semantic HTML when relevant to user experience.\n• **Avoid Unnecessary act()**: RTL handles most async operations automatically.\n\nGenerate only the test code with proper imports.",
    "input": "```tsx\nimport * as React from \"react\";\n\ntype ButtonVariant = \"primary\" | \"secondary\" | \"ghost\";\n\nexport interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  variant?: ButtonVariant;\n  isLoading?: boolean;\n}\n\nconst classesByVariant: Record<ButtonVariant, string> = {\n  primary: \"btn btn-primary\",\n  secondary: \"btn btn-secondary\",\n  ghost: \"btn btn-ghost\",\n};\n\nexport const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(\n  ({ variant = \"primary\", isLoading = false, disabled, children, ...rest }, ref) => {\n    const isDisabled = disabled || isLoading;\n    return (\n      <button\n        {...rest}\n        ref={ref}\n        className={classesByVariant[variant]}\n        disabled={isDisabled}\n        aria-busy={isLoading || undefined}\n      >\n        {isLoading ? \"Loading…\" : children}\n      </button>\n    );\n  }\n);\nButton.displayName = \"Button\";\n```",
    "output": "import { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Button } from \"../Button\";\n\ntest(\"renders with children and handles click\", async () => {\n  const user = userEvent.setup();\n  const onClick = vi.fn();\n  render(<Button onClick={onClick}>Save</Button>);\n\n  await user.click(screen.getByRole(\"button\", { name: /save/i }));\n  expect(onClick).toHaveBeenCalledTimes(1);\n});\n\ntest(\"shows loading state disables button\", async () => {\n  const user = userEvent.setup();\n  const onClick = vi.fn();\n  render(<Button isLoading onClick={onClick}>Save</Button>);\n\n  const btn = screen.getByRole(\"button\", { name: /loading…/i });\n  expect(btn).toBeDisabled();\n  expect(btn).toHaveAttribute(\"aria-busy\", \"true\");\n\n  await user.click(btn);\n  expect(onClick).not.toHaveBeenCalled();\n});\n\ntest(\"variant applies class\", () => {\n  render(<Button variant=\"secondary\">Go</Button>);\n  expect(screen.getByRole(\"button\", { name: /go/i })).toHaveClass(\"btn\", \"btn-secondary\");\n});"
  },
  {
    "instruction": "Generate a Jest unit test for the following React component using React Testing Library.\n\nFollow these critical best practices for writing effective tests and avoid common mistakes:\n\n* **Query by User-Facing Attributes:** Prioritize querying elements the way a user would find them. Use roles, labels, and text (`getByRole`, `getByLabelText`, `getByText`). Avoid implementation details like class names or relying on `data-testid` as a first resort.\n* **Use `screen` for Queries:** Always use the `screen` object for querying the DOM (`screen.getByRole(...)`). Do not destructure query methods from `render`.\n* **Prefer `user-event` over `fireEvent`:** Use `@testing-library/user-event` for simulating user interactions as it more closely resembles real browser behavior.\n* **Use `*By` for Presence, `queryBy` for Absence:**\n    * Use `getBy...` or `getAllBy...` to assert an element is present (it throws an error if not found).\n    * Use `queryBy...` or `queryAllBy...` to assert an element is *not* present (it returns `null` if not found).\n* **Use `findBy` for Asynchronous Appearance:** Use `findBy...` or `findAllBy...` to find elements that will appear asynchronously after an action.\n\n```tsx\nimport * as React from \"react\";\n\ninterface ComboboxProps {\n  options: string[];\n  onSelect: (value: string) => void;\n  label?: string;\n  id?: string;\n}\n\nexport function Combobox({ options, onSelect, label = \"Choose\", id = \"combo\" }: ComboboxProps) {\n  const [input, setInput] = React.useState(\"\");\n  const [open, setOpen] = React.useState(false);\n  const [activeIndex, setActiveIndex] = React.useState<number>(-1);\n\n  const filtered = options.filter(o => o.toLowerCase().includes(input.toLowerCase()));\n\n  const commit = (value: string) => {\n    setInput(value);\n    setOpen(false);\n    onSelect(value);\n  };\n\n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input\n        id={id}\n        role=\"combobox\"\n        aria-expanded={open}\n        aria-controls={`${id}-listbox`}\n        aria-autocomplete=\"list\"\n        value={input}\n        onChange={(e) => { setInput(e.target.value); setOpen(true); setActiveIndex(-1); }}\n        onKeyDown={(e) => {\n          if (!open && (e.key === \"ArrowDown\" || e.key === \"ArrowUp\")) setOpen(true);\n          if (e.key === \"ArrowDown\") setActiveIndex((i) => Math.min(i + 1, filtered.length - 1));\n          if (e.key === \"ArrowUp\") setActiveIndex((i) => Math.max(i - 1, 0));\n          if (e.key === \"Enter\" && activeIndex >= 0) commit(filtered[activeIndex]);\n          if (e.key === \"Escape\") setOpen(false);\n        }}\n        onBlur={() => setTimeout(() => setOpen(false), 100)}\n      />\n      {open && (\n        <ul role=\"listbox\" id={`${id}-listbox`}>\n          {filtered.length ? (\n            filtered.map((o, i) => (\n              <li\n                key={o}\n                role=\"option\"\n                aria-selected={i === activeIndex}\n                onMouseDown={(e) => e.preventDefault()}\n                onClick={() => commit(o)}\n              >\n                {o}\n              </li>\n            ))\n          ) : (\n            <li role=\"option\" aria-disabled=\"true\">No matches</li>\n          )}\n        </ul>\n      )}\n    </div>\n  );\n}\n```",
    "output": "```tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Combobox } from \"../Combobox\";\n\ntest(\"filters and selects with keyboard\", async () => {\n  const user = userEvent.setup();\n  const onSelect = vi.fn();\n  render(<Combobox options={[\"React\", \"Redux\", \"TypeScript\"]} onSelect={onSelect} />);\n\n  const cb = screen.getByRole(\"combobox\", { name: /choose/i });\n  await user.type(cb, \"re\");\n  const list = screen.getByRole(\"listbox\");\n  expect(list).toBeInTheDocument();\n\n  await user.keyboard(\"{ArrowDown}{Enter}\");\n  expect(onSelect).toHaveBeenCalledWith(\"React\");\n  expect(screen.queryByRole(\"listbox\")).not.toBeInTheDocument();\n});\n\ntest(\"shows no matches\", async () => {\n  const user = userEvent.setup();\n  render(<Combobox options={[\"apple\"]} onSelect={() => {}} />);\n  const cb = screen.getByRole(\"combobox\", { name: /choose/i });\n  await user.type(cb, \"zz\");\n  expect(screen.getByRole(\"option\", { name: /no matches/i })).toBeInTheDocument();\n});\n```"
  },
  {
    "instruction": "Generate a Jest unit test for the following React component using React Testing Library.\n\nFollow these critical best practices for writing effective tests and avoid common mistakes:\n\n* **Query by User-Facing Attributes:** Prioritize querying elements the way a user would find them. Use roles, labels, and text (`getByRole`, `getByLabelText`, `getByText`). Avoid implementation details like class names or relying on `data-testid` as a first resort.\n* **Use `screen` for Queries:** Always use the `screen` object for querying the DOM (`screen.getByRole(...)`). Do not destructure query methods from `render`.\n* **Prefer `user-event` over `fireEvent`:** Use `@testing-library/user-event` for simulating user interactions as it more closely resembles real browser behavior.\n* **Use `*By` for Presence, `queryBy` for Absence:**\n    * Use `getBy...` or `getAllBy...` to assert an element is present (it throws an error if not found).\n    * Use `queryBy...` or `queryAllBy...` to assert an element is *not* present (it returns `null` if not found).\n* **Use `findBy` for Asynchronous Appearance:** Use `findBy...` or `findAllBy...` to find elements that will appear asynchronously after an action.\n\n```tsx\nimport * as React from \"react\";\n\nexport interface Row {\n  id: string;\n  name: string;\n  age: number;\n}\ninterface DataTableProps {\n  rows: Row[];\n  pageSize?: number;\n}\n\nexport function DataTable({ rows, pageSize = 5 }: DataTableProps) {\n  const [query, setQuery] = React.useState(\"\");\n  const [sort, setSort] = React.useState<{ key: \"name\" | \"age\"; dir: \"asc\" | \"desc\" }> ({\n    key: \"name\",\n    dir: \"asc\",\n  });\n  const [page, setPage] = React.useState(1);\n\n  const filtered = React.useMemo(\n    () => rows.filter(r => r.name.toLowerCase().includes(query.toLowerCase())),\n    [rows, query]\n  );\n\n  const sorted = React.useMemo(() => {\n    return [...filtered].sort((a, b) => {\n      const aV = a[sort.key];\n      const bV = b[sort.key];\n      const cmp = aV < bV ? -1 : aV > bV ? 1 : 0;\n      return sort.dir === \"asc\" ? cmp : -cmp;\n    });\n  }, [filtered, sort]);\n\n  const totalPages = Math.max(1, Math.ceil(sorted.length / pageSize));\n  const pageRows = sorted.slice((page - 1) * pageSize, page * pageSize);\n\n  React.useEffect(() => {\n    setPage(1);\n  }, [query, pageSize]);\n\n  return (\n    <div>\n      <label htmlFor=\"filter\">Filter</label>\n      <input\n        id=\"filter\"\n        placeholder=\"Search name…\"\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n      />\n\n      <table>\n        <thead>\n          <tr>\n            <th>\n              <button\n                aria-label=\"Sort by name\"\n                onClick={() =>\n                  setSort((s) => ({ key: \"name\", dir: s.key === \"name\" && s.dir === \"asc\" ? \"desc\" : \"asc\" }))\n                }\n              >\n                Name {sort.key === \"name\" ? (sort.dir === \"asc\" ? \"▲\" : \"▼\") : \"\"}\n              </button>\n            </th>\n            <th>\n              <button\n                aria-label=\"Sort by age\"\n                onClick={() =>\n                  setSort((s) => ({ key: \"age\", dir: s.key === \"age\" && s.dir === \"asc\" ? \"desc\" : \"asc\" }))\n                }\n              >\n                Age {sort.key === \"age\" ? (sort.dir === \"asc\" ? \"▲\" : \"▼\") : \"\"}\n              </button>\n            </th>\n          </tr>\n        </thead>\n        <tbody>\n          {pageRows.length ? (\n            pageRows.map((r) => (\n              <tr key={r.id}>\n                <td>{r.name}</td>\n                <td>{r.age}</td>\n              </tr>\n            ))\n          ) : (\n            <tr>\n              <td colSpan={2}>No results</td>\n            </tr>\n          )}\n        </tbody>\n      </table>\n\n      <nav aria-label=\"Pagination\">\n        <button onClick={() => setPage((p) => Math.max(1, p - 1))} disabled={page === 1}>\n          Prev\n        </button>\n        <span aria-live=\"polite\" style={{ padding: \"0 8px\" }}>\n          Page {page} of {totalPages}\n        </span>\n        <button onClick={() => setPage((p) => Math.min(totalPages, p + 1))} disabled={page === totalPages}>\n          Next\n        </button>\n      </nav>\n    </div>\n  );\n}\n```",
    "output": "```ts\nimport { render, screen, within } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { DataTable } from \"../DataTable\";\n\nconst rows = [\n  { id: \"1\", name: \"Ada\", age: 30 },\n  { id: \"2\", name: \"Grace\", age: 28 },\n  { id: \"3\", name: \"Linus\", age: 35 },\n  { id: \"4\", name: \"Brendan\", age: 33 },\n  { id: \"5\", name: \"Ken\", age: 40 },\n  { id: \"6\", name: \"Dennis\", age: 45 },\n];\n\ntest(\"filters by name and shows 'No results' when empty\", async () => {\n  const user = userEvent.setup();\n  render(<DataTable rows={rows} pageSize={5} />);\n\n  await user.type(screen.getByPlaceholderText(/search name/i), \"xyz\");\n  expect(screen.getByText(/no results/i)).toBeInTheDocument();\n});\n\ntest(\"sorts by column and paginates\", async () => {\n  const user = userEvent.setup();\n  render(<DataTable rows={rows} pageSize={2} />);\n\n  const body = screen.getByRole(\"table\").querySelector(\"tbody\")!;\n  expect(within(body).getAllByRole(\"row\")[0]).toHaveTextContent(/ada/i);\n\n  await user.click(screen.getByRole(\"button\", { name: /sort by age/i }));\n  expect(within(body).getAllByRole(\"row\")[0]).toHaveTextContent(/grace/i);\n\n  await user.click(screen.getByRole(\"button\", { name: /next/i }));\n  expect(screen.getByText(/page 2 of/i)).toBeInTheDocument();\n});\n```"
  },
  {
    "instruction": "Generate a Jest unit test for the following React component using React Testing Library.\n\nFollow these critical best practices for writing effective tests and avoid common mistakes:\n\n* **Query by User-Facing Attributes:** Prioritize querying elements the way a user would find them. Use roles, labels, and text (`getByRole`, `getByLabelText`, `getByText`). Avoid implementation details like class names or relying on `data-testid` as a first resort.\n* **Use `screen` for Queries:** Always use the `screen` object for querying the DOM (`screen.getByRole(...)`). Do not destructure query methods from `render`.\n* **Prefer `user-event` over `fireEvent`:** Use `@testing-library/user-event` for simulating user interactions as it more closely resembles real browser behavior.\n* **Use `*By` for Presence, `queryBy` for Absence:**\n    * Use `getBy...` or `getAllBy...` to assert an element is present (it throws an error if not found).\n    * Use `queryBy...` or `queryAllBy...` to assert an element is *not* present (it returns `null` if not found).\n* **Use `findBy` for Asynchronous Appearance:** Use `findBy...` or `findAllBy...` to find elements that will appear asynchronously after an action.\n\n```tsx\nimport * as React from \"react\";\n\nexport interface DebouncedSearchInputProps\n  extends Omit<React.InputHTMLAttributes<HTMLInputElement>, \"onChange\"> {\n  delay?: number;\n  onSearch: (value: string) => void | Promise<void>;\n  label?: string;\n  id?: string;\n}\n\nexport function DebouncedSearchInput({\n  delay = 300,\n  onSearch,\n  label = \"Search\",\n  id = \"search\",\n  ...rest\n}: DebouncedSearchInputProps) {\n  const [value, setValue] = React.useState(\"\");\n\n  React.useEffect(() => {\n    const handle = setTimeout(() => onSearch(value), delay);\n    return () => clearTimeout(handle);\n  }, [value, delay, onSearch]);\n\n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input\n        id={id}\n        role=\"searchbox\"\n        type=\"search\"\n        value={value}\n        onChange={(e) => setValue(e.target.value)}\n        {...rest}\n      />\n    </div>\n  );\n}\n```",
    "output": "```tsx\nimport { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { DebouncedSearchInput } from \"../DebouncedSearchInput\";\n\nbeforeEach(() => {\n  vi.useFakeTimers();\n});\nafterEach(() => {\n  vi.useRealTimers();\n});\n\ntest(\"calls onSearch after delay (debounced)\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<DebouncedSearchInput delay={500} onSearch={onSearch} />);\n\n  const box = screen.getByRole(\"searchbox\", { name: /search/i });\n  await user.type(box, \"react\");\n  vi.advanceTimersByTime(499);\n  expect(onSearch).not.toHaveBeenCalled();\n\n  vi.advanceTimersByTime(1);\n  await waitFor(() => expect(onSearch).toHaveBeenCalledTimes(1));\n  expect(onSearch).toHaveBeenLastCalledWith(\"react\");\n});\n\ntest(\"restarts timer on further typing\", async () => {\n  const user = userEvent.setup();\n  const onSearch = vi.fn();\n  render(<DebouncedSearchInput delay={300} onSearch={onSearch} />);\n\n  const box = screen.getByRole(\"searchbox\", { name: /search/i });\n  await user.type(box, \"re\");\n  vi.advanceTimersByTime(250);\n  await user.type(box, \"act\");\n  vi.advanceTimersByTime(299);\n  expect(onSearch).not.toHaveBeenCalled();\n\n  vi.advanceTimersByTime(1);\n  await waitFor(() => expect(onSearch).toHaveBeenCalledTimes(1));\n  expect(onSearch).toHaveBeenCalledWith(\"react\");\n});\n```"
  },
  {
    "instruction": "Generate a Jest unit test for the following React component using React Testing Library.\n\nFollow these critical best practices for writing effective tests and avoid common mistakes:\n\n* **Query by User-Facing Attributes:** Prioritize querying elements the way a user would find them. Use roles, labels, and text (`getByRole`, `getByLabelText`, `getByText`). Avoid implementation details like class names or relying on `data-testid` as a first resort.\n* **Use `screen` for Queries:** Always use the `screen` object for querying the DOM (`screen.getByRole(...)`). Do not destructure query methods from `render`.\n* **Prefer `user-event` over `fireEvent`:** Use `@testing-library/user-event` for simulating user interactions as it more closely resembles real browser behavior.\n* **Use `*By` for Presence, `queryBy` for Absence:**\n    * Use `getBy...` or `getAllBy...` to assert an element is present (it throws an error if not found).\n    * Use `queryBy...` or `queryAllBy...` to assert an element is *not* present (it returns `null` if not found).\n* **Use `findBy` for Asynchronous Appearance:** Use `findBy...` or `findAllBy...` to find elements that will appear asynchronously after an action.\n\n```tsx\nimport * as React from \"react\";\n\nexport interface FormProps {\n  onSubmit: (data: { email: string; password: string }) => Promise<void>;\n}\n\nexport function Form({ onSubmit }: FormProps) {\n  const [email, setEmail] = React.useState(\"\");\n  const [password, setPassword] = React.useState(\"\");\n  const [error, setError] = React.useState<string | null>(null);\n  const [loading, setLoading] = React.useState(false);\n  const isValid = /\\S+@\\S+\\.\\S+/.test(email) && password.length >= 6;\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (!isValid) return;\n    setError(null);\n    setLoading(true);\n    try {\n      await onSubmit({ email, password });\n    } catch (err: any) {\n      setError(err?.message ?? \"Unknown error\");\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} aria-label=\"Sign in\">\n      <div>\n        <label htmlFor=\"email\">Email</label>\n        <input\n          id=\"email\"\n          value={email}\n          type=\"email\"\n          onChange={(e) => setEmail(e.target.value)}\n          aria-invalid={email ? (!/\\S+@\\S+\\.\\S+/.test(email)).toString() : undefined}\n        />\n      </div>\n      <div>\n        <label htmlFor=\"password\">Password (min 6)</label>\n        <input\n          id=\"password\"\n          value={password}\n          type=\"password\"\n          onChange={(e) => setPassword(e.target.value)}\n          aria-invalid={password ? (password.length < 6).toString() : undefined}\n        />\n      </div>\n\n      {error && <div role=\"alert\">{error}</div>}\n\n      <button type=\"submit\" disabled={!isValid || loading} aria-busy={loading || undefined}>\n        {loading ? \"Signing in…\" : \"Sign in\"}\n      </button>\n    </form>\n  );\n}\n```",
    "output": "```tsx\nimport { render, screen, waitFor } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Form } from \"../Form\";\n\ntest(\"validation disables submit; enables when valid\", async () => {\n  const user = userEvent.setup();\n  const onSubmit = vi.fn().mockResolvedValue(undefined);\n  render(<Form onSubmit={onSubmit} />);\n\n  const submit = screen.getByRole(\"button\", { name: /sign in/i });\n  expect(submit).toBeDisabled();\n\n  await user.type(screen.getByLabelText(/email/i), \"user@example.com\");\n  await user.type(screen.getByLabelText(/password/i), \"secret1\");\n  expect(submit).toBeEnabled();\n\n  await user.click(submit);\n  await waitFor(() => expect(onSubmit).toHaveBeenCalledWith({ email: \"user@example.com\", password: \"secret1\" }));\n});\n\ntest(\"shows server error on rejected submit\", async () => {\n  const user = userEvent.setup();\n  const onSubmit = vi.fn().mockRejectedValue(new Error(\"Invalid credentials\"));\n  render(<Form onSubmit={onSubmit} />);\n\n  await user.type(screen.getByLabelText(/email/i), \"user@example.com\");\n  await user.type(screen.getByLabelText(/password/i), \"secret1\");\n  await user.click(screen.getByRole(\"button\", { name: /sign in/i }));\n\n  expect(screen.getByRole(\"button\", { name: /signing in…/i })).toBeDisabled();\n  await waitFor(() => expect(screen.getByRole(\"alert\")).toHaveTextContent(/invalid credentials/i));\n});\n```"
  },
  {
    "instruction": "Generate a Jest unit test for the following React component using React Testing Library.\n\nFollow these critical best practices for writing effective tests and avoid common mistakes:\n\n* **Query by User-Facing Attributes:** Prioritize querying elements the way a user would find them. Use roles, labels, and text (`getByRole`, `getByLabelText`, `getByText`). Avoid implementation details like class names or relying on `data-testid` as a first resort.\n* **Use `screen` for Queries:** Always use the `screen` object for querying the DOM (`screen.getByRole(...)`). Do not destructure query methods from `render`.\n* **Prefer `user-event` over `fireEvent`:** Use `@testing-library/user-event` for simulating user interactions as it more closely resembles real browser behavior.\n* **Use `*By` for Presence, `queryBy` for Absence:**\n    * Use `getBy...` or `getAllBy...` to assert an element is present (it throws an error if not found).\n    * Use `queryBy...` or `queryAllBy...` to assert an element is *not* present (it returns `null` if not found).\n* **Use `findBy` for Asynchronous Appearance:** Use `findBy...` or `findAllBy...` to find elements that will appear asynchronously after an action.\n\n```tsx\nimport * as React from \"react\";\n\ninterface MenuPopoverProps {\n  items: { id: string; label: string; onSelect: () => void }[];\n}\n\nexport function MenuPopover({ items }: MenuPopoverProps) {\n  const [open, setOpen] = React.useState(false);\n  const btnRef = React.useRef<HTMLButtonElement | null>(null);\n  const popRef = React.useRef<HTMLDivElement | null>(null);\n\n  React.useEffect(() => {\n    if (!open) return;\n    const onDocClick = (e: MouseEvent) => {\n      if (!popRef.current || !btnRef.current) return;\n      if (popRef.current.contains(e.target as Node) || btnRef.current.contains(e.target as Node)) return;\n      setOpen(false);\n    };\n    const onKey = (e: KeyboardEvent) => { if (e.key === \"Escape\") setOpen(false); };\n    document.addEventListener(\"mousedown\", onDocClick);\n    document.addEventListener(\"keydown\", onKey);\n    return () => {\n      document.removeEventListener(\"mousedown\", onDocClick);\n      document.removeEventListener(\"keydown\", onKey);\n    };\n  }, [open]);\n\n  return (\n    <div>\n      <button ref={btnRef} aria-haspopup=\"menu\" aria-expanded={open} onClick={() => setOpen((o) => !o)}>\n        Actions\n      </button>\n      {open && (\n        <div role=\"menu\" ref={popRef}>\n          {items.map((it) => (\n            <button\n              key={it.id}\n              role=\"menuitem\"\n              onClick={() => { it.onSelect(); setOpen(false); }}\n            >\n              {it.label}\n            </button>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n```",
    "output": "```tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { MenuPopover } from \"../MenuPopover\";\n\ntest(\"opens, selects item, and closes\", async () => {\n  const user = userEvent.setup();\n  const save = vi.fn();\n  render(<MenuPopover items={[{ id: \"save\", label: \"Save\", onSelect: save }]} />);\n\n  await user.click(screen.getByRole(\"button\", { name: /actions/i }));\n  await user.click(screen.getByRole(\"menuitem\", { name: /save/i }));\n  expect(save).toHaveBeenCalled();\n  expect(screen.queryByRole(\"menu\")).not.toBeInTheDocument();\n});\n\ntest(\"closes on escape and outside click\", async () => {\n  const user = userEvent.setup();\n  render(\n    <div>\n      <MenuPopover items={[{ id: \"x\", label: \"X\", onSelect: () => {} }]} />\n      <button>Outside</button>\n    </div>\n  );\n\n  await user.click(screen.getByRole(\"button\", { name: /actions/i }));\n  expect(screen.getByRole(\"menu\")).toBeInTheDocument();\n\n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"menu\")).not.toBeInTheDocument();\n\n  await user.click(screen.getByRole(\"button\", { name: /actions/i }));\n  await user.click(screen.getByRole(\"button\", { name: /outside/i }));\n  expect(screen.queryByRole(\"menu\")).not.toBeInTheDocument();\n});\n```"
  },
  {
    "instruction": "Generate a Jest unit test for the following React component using React Testing Library.\n\nFollow these critical best practices for writing effective tests and avoid common mistakes:\n\n* **Query by User-Facing Attributes:** Prioritize querying elements the way a user would find them. Use roles, labels, and text (`getByRole`, `getByLabelText`, `getByText`). Avoid implementation details like class names or relying on `data-testid` as a first resort.\n* **Use `screen` for Queries:** Always use the `screen` object for querying the DOM (`screen.getByRole(...)`). Do not destructure query methods from `render`.\n* **Prefer `user-event` over `fireEvent`:** Use `@testing-library/user-event` for simulating user interactions as it more closely resembles real browser behavior.\n* **Use `*By` for Presence, `queryBy` for Absence:**\n    * Use `getBy...` or `getAllBy...` to assert an element is present (it throws an error if not found).\n    * Use `queryBy...` or `queryAllBy...` to assert an element is *not* present (it returns `null` if not found).\n* **Use `findBy` for Asynchronous Appearance:** Use `findBy...` or `findAllBy...` to find elements that will appear asynchronously after an action.\n\n```tsx\nimport * as React from \"react\";\nimport { createPortal } from \"react-dom\";\n\ninterface ModalProps {\n  open: boolean;\n  onClose: () => void;\n  title?: string;\n  children: React.ReactNode;\n}\n\nexport function Modal({ open, onClose, title = \"Dialog\", children }: ModalProps) {\n  const ref = React.useRef<HTMLDivElement | null>(null);\n\n  React.useEffect(() => {\n    if (!open) return;\n    const onKey = (e: KeyboardEvent) => {\n      if (e.key === \"Escape\") onClose();\n    };\n    document.addEventListener(\"keydown\", onKey);\n    return () => document.removeEventListener(\"keydown\", onKey);\n  }, [open, onClose]);\n\n  if (!open) return null;\n\n  const content = (\n    <div\n      aria-hidden=\"true\"\n      style={{\n        position: \"fixed\",\n        inset: 0,\n        background: \"rgba(0,0,0,0.4)\",\n        display: \"grid\",\n        placeItems: \"center\",\n      }}\n      onClick={(e) => {\n        if (e.target === e.currentTarget) onClose();\n      }}\n    >\n      <div\n        role=\"dialog\"\n        aria-modal=\"true\"\n        aria-labelledby=\"modal-title\"\n        ref={ref}\n        style={{ background: \"white\", padding: 16, minWidth: 320, borderRadius: 8 }}\n      >\n        <h2 id=\"modal-title\" style={{ marginTop: 0 }}>{title}</h2>\n        <div>{children}</div>\n        <button onClick={onClose} aria-label=\"Close\">Close</button>\n      </div>\n    </div>\n  );\n\n  return typeof document !== \"undefined\"\n    ? createPortal(content, document.body)\n    : content;\n}\n```",
    "output": "```tsx\nimport * as React from \"react\";\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Modal } from \"../Modal\";\n\nfunction Wrapper() {\n  const [open, setOpen] = React.useState(false);\n  return (\n    <div>\n      <button onClick={() => setOpen(true)}>Open</button>\n      <Modal open={open} onClose={() => setOpen(false)} title=\"Confirm\">\n        <p>Are you sure?</p>\n      </Modal>\n    </div>\n  );\n}\n\ntest(\"opens and closes via button and close button\", async () => {\n  const user = userEvent.setup();\n  render(<Wrapper />);\n\n  await user.click(screen.getByRole(\"button\", { name: /open/i }));\n  expect(screen.getByRole(\"dialog\", { name: /confirm/i })).toBeInTheDocument();\n\n  await user.click(screen.getByRole(\"button\", { name: /close/i }));\n  expect(screen.queryByRole(\"dialog\", { name: /confirm/i })).not.toBeInTheDocument();\n});\n\ntest(\"closes on backdrop click\", async () => {\n  const user = userEvent.setup();\n  render(<Wrapper />);\n\n  await user.click(screen.getByRole(\"button\", { name: /open/i }));\n  const dialog = screen.getByRole(\"dialog\", { name: /confirm/i });\n\n  await user.click(dialog.parentElement as HTMLElement);\n  expect(screen.queryByRole(\"dialog\", { name: /confirm/i })).not.toBeInTheDocument();\n});\n\ntest(\"closes on Escape\", async () => {\n  const user = userEvent.setup();\n  render(<Wrapper />);\n\n  await user.click(screen.getByRole(\"button\", { name: /open/i }));\n  await user.keyboard(\"{Escape}\");\n  expect(screen.queryByRole(\"dialog\", { name: /confirm/i })).not.toBeInTheDocument();\n});\n```"
  },
  {
    "instruction": "Generate a Jest unit test for the following React component using React Testing Library.\n\nFollow these critical best practices for writing effective tests and avoid common mistakes:\n\n* **Query by User-Facing Attributes:** Prioritize querying elements the way a user would find them. Use roles, labels, and text (`getByRole`, `getByLabelText`, `getByText`). Avoid implementation details like class names or relying on `data-testid` as a first resort.\n* **Use `screen` for Queries:** Always use the `screen` object for querying the DOM (`screen.getByRole(...)`). Do not destructure query methods from `render`.\n* **Prefer `user-event` over `fireEvent`:** Use `@testing-library/user-event` for simulating user interactions as it more closely resembles real browser behavior.\n* **Use `*By` for Presence, `queryBy` for Absence:**\n    * Use `getBy...` or `getAllBy...` to assert an element is present (it throws an error if not found).\n    * Use `queryBy...` or `queryAllBy...` to assert an element is *not* present (it returns `null` if not found).\n* **Use `findBy` for Asynchronous Appearance:** Use `findBy...` or `findAllBy...` to find elements that will appear asynchronously after an action.\n\n```tsx\nimport * as React from \"react\";\n\nexport interface SwitchProps {\n  checked: boolean;\n  onChange: (checked: boolean) => void;\n  id?: string;\n  label?: string;\n  disabled?: boolean;\n}\n\nexport function Switch({ checked, onChange, id, label, disabled }: SwitchProps) {\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (disabled) return;\n    if (e.key === \" \" || e.key === \"Enter\") {\n      e.preventDefault();\n      onChange(!checked);\n    }\n  };\n\n  return (\n    <div>\n      {label && (\n        <label htmlFor={id} style={{ marginRight: 8 }}>\n          {label}\n        </label>\n      )}\n      <div\n        id={id}\n        role=\"switch\"\n        aria-checked={checked}\n        aria-disabled={disabled || undefined}\n        tabIndex={disabled ? -1 : 0}\n        onClick={() => !disabled && onChange(!checked)}\n        onKeyDown={handleKeyDown}\n        style={{\n          width: 44,\n          height: 24,\n          borderRadius: 12,\n          background: disabled ? \"#ccc\" : checked ? \"#4ade80\" : \"#e5e7eb\",\n          position: \"relative\",\n          cursor: disabled ? \"not-allowed\" : \"pointer\",\n          outline: \"none\",\n        }}\n      >\n        <span\n          aria-hidden=\"true\"\n          style={{\n            position: \"absolute\",\n            top: 2,\n            left: checked ? 22 : 2,\n            width: 20,\n            height: 20,\n            borderRadius: \"50%\",\n            background: \"white\",\n            transition: \"left 120ms\",\n          }}\n        />\n      </div>\n    </div>\n  );\n}\n```",
    "output": "```tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Switch } from \"../Switch\";\n\ntest(\"click toggles the switch\", async () => {\n  const user = userEvent.setup();\n  const handle = vi.fn();\n  render(<Switch checked={false} onChange={handle} label=\"Notifications\" id=\"notif\" />);\n\n  const sw = screen.getByRole(\"switch\", { name: /notifications/i });\n  await user.click(sw);\n  expect(handle).toHaveBeenCalledWith(true);\n});\n\ntest(\"keyboard space/enter toggles\", async () => {\n  const user = userEvent.setup();\n  const handle = vi.fn();\n  render(<Switch checked={true} onChange={handle} label=\"Wifi\" id=\"wifi\" />);\n\n  const sw = screen.getByRole(\"switch\", { name: /wifi/i });\n  await user.keyboard(\"[Space]\");\n  await user.keyboard(\"{Enter}\");\n  expect(handle).toHaveBeenCalledWith(false);\n  expect(handle).toHaveBeenCalledWith(false);\n});\n\ntest(\"disabled cannot be toggled\", async () => {\n  const user = userEvent.setup();\n  const handle = vi.fn();\n  render(<Switch checked={false} onChange={handle} label=\"Airplane mode\" disabled />);\n\n  const sw = screen.getByRole(\"switch\", { name: /airplane mode/i });\n  expect(sw).toHaveAttribute(\"aria-disabled\", \"true\");\n  await user.click(sw);\n  await user.keyboard(\"[Space]\");\n  expect(handle).not.toHaveBeenCalled();\n});\n```"
  },
  {
    "instruction": "Generate a Jest unit test for the following React component using React Testing Library.\n\nFollow these critical best practices for writing effective tests and avoid common mistakes:\n\n* **Query by User-Facing Attributes:** Prioritize querying elements the way a user would find them. Use roles, labels, and text (`getByRole`, `getByLabelText`, `getByText`). Avoid implementation details like class names or relying on `data-testid` as a first resort.\n* **Use `screen` for Queries:** Always use the `screen` object for querying the DOM (`screen.getByRole(...)`). Do not destructure query methods from `render`.\n* **Prefer `user-event` over `fireEvent`:** Use `@testing-library/user-event` for simulating user interactions as it more closely resembles real browser behavior.\n* **Use `*By` for Presence, `queryBy` for Absence:**\n    * Use `getBy...` or `getAllBy...` to assert an element is present (it throws an error if not found).\n    * Use `queryBy...` or `queryAllBy...` to assert an element is *not* present (it returns `null` if not found).\n* **Use `findBy` for Asynchronous Appearance:** Use `findBy...` or `findAllBy...` to find elements that will appear asynchronously after an action.\n\n```tsx\nimport * as React from \"react\";\n\nexport interface Tab {\n  id: string;\n  label: string;\n  panel: React.ReactNode;\n}\n\ninterface TabsProps {\n  tabs: Tab[];\n  defaultTabId?: string;\n}\n\nexport function Tabs({ tabs, defaultTabId }: TabsProps) {\n  const [active, setActive] = React.useState(defaultTabId ?? tabs[0]?.id);\n  const tabRefs = React.useRef<Array<HTMLButtonElement | null>>([]);\n\n  const index = tabs.findIndex(t => t.id === active);\n\n  const onKeyDown = (e: React.KeyboardEvent) => {\n    const count = tabs.length;\n    if (!count) return;\n    let next = index;\n    if (e.key === \"ArrowRight\") next = (index + 1) % count;\n    if (e.key === \"ArrowLeft\") next = (index - 1 + count) % count;\n    if (next !== index) {\n      e.preventDefault();\n      const id = tabs[next].id;\n      setActive(id);\n      tabRefs.current[next]?.focus();\n    }\n  };\n\n  return (\n    <div>\n      <div role=\"tablist\" aria-label=\"Sections\" onKeyDown={onKeyDown}>\n        {tabs.map((t, i) => {\n          const selected = t.id === active;\n          return (\n            <button\n              key={t.id}\n              role=\"tab\"\n              aria-selected={selected}\n              aria-controls={`${t.id}-panel`}\n              id={`${t.id}-tab`}\n              ref={(el) => (tabRefs.current[i] = el)}\n              tabIndex={selected ? 0 : -1}\n              onClick={() => setActive(t.id)}\n              style={{\n                padding: \"6px 10px\",\n                borderBottom: selected ? \"2px solid black\" : \"2px solid transparent\",\n              }}\n            >\n              {t.label}\n            </button>\n          );\n        })}\n      </div>\n\n      {tabs.map((t) =>\n        t.id === active ? (\n          <div\n            key={t.id}\n            role=\"tabpanel\"\n            id={`${t.id}-panel`}\n            aria-labelledby={`${t.id}-tab`}\n            style={{ paddingTop: 8 }}\n          >\n            {t.panel}\n          </div>\n        ) : null\n      )}\n    </div>\n  );\n}\n```",
    "output": "```tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { Tabs } from \"../Tabs\";\n\nconst tabs = [\n  { id: \"general\", label: \"General\", panel: <p>General panel</p> },\n  { id: \"billing\", label: \"Billing\", panel: <p>Billing panel</p> },\n  { id: \"team\", label: \"Team\", panel: <p>Team panel</p> },\n];\n\ntest(\"click changes active tab and panel\", async () => {\n  const user = userEvent.setup();\n  render(<Tabs tabs={tabs} />);\n\n  expect(screen.getByRole(\"tabpanel\")).toHaveTextContent(/general panel/i);\n\n  await user.click(screen.getByRole(\"tab\", { name: /billing/i }));\n  expect(screen.getByRole(\"tabpanel\")).toHaveTextContent(/billing panel/i);\n});\n\ntest(\"arrow keys move selection and focus\", async () => {\n  const user = userEvent.setup();\n  render(<Tabs tabs={tabs} />);\n\n  const first = screen.getByRole(\"tab\", { name: /general/i });\n  first.focus();\n  expect(first).toHaveFocus();\n\n  await user.keyboard(\"{ArrowRight}\");\n  expect(screen.getByRole(\"tab\", { name: /billing/i })).toHaveFocus();\n  expect(screen.getByRole(\"tabpanel\")).toHaveTextContent(/billing panel/i);\n\n  await user.keyboard(\"{ArrowLeft}\");\n  expect(screen.getByRole(\"tab\", { name: /general/i })).toHaveFocus();\n});\n```"
  },
  {
    "instruction": "Generate a Jest unit test for the following React component using React Testing Library.\n\nFollow these critical best practices for writing effective tests and avoid common mistakes:\n\n* **Query by User-Facing Attributes:** Prioritize querying elements the way a user would find them. Use roles, labels, and text (`getByRole`, `getByLabelText`, `getByText`). Avoid implementation details like class names or relying on `data-testid` as a first resort.\n* **Use `screen` for Queries:** Always use the `screen` object for querying the DOM (`screen.getByRole(...)`). Do not destructure query methods from `render`.\n* **Prefer `user-event` over `fireEvent`:** Use `@testing-library/user-event` for simulating user interactions as it more closely resembles real browser behavior.\n* **Use `*By` for Presence, `queryBy` for Absence:**\n    * Use `getBy...` or `getAllBy...` to assert an element is present (it throws an error if not found).\n    * Use `queryBy...` or `queryAllBy...` to assert an element is *not* present (it returns `null` if not found).\n* **Use `findBy` for Asynchronous Appearance:** Use `findBy...` or `findAllBy...` to find elements that will appear asynchronously after an action.\n\n```tsx\nimport * as React from \"react\";\n\nexport function Toast({ message, duration = 2000 }: { message: string; duration?: number }) {\n  const [open, setOpen] = React.useState(true);\n  const hoverRef = React.useRef(false);\n  React.useEffect(() => {\n    if (!open) return;\n    let remaining = duration;\n    let start = Date.now();\n    let timer: number | undefined;\n\n    const tick = () => {\n      timer = window.setTimeout(() => {\n        if (hoverRef.current) {\n          start = Date.now();\n          tick();\n        } else {\n          const elapsed = Date.now() - start;\n          remaining -= elapsed;\n          if (remaining <= 0) setOpen(false);\n          else {\n            start = Date.now();\n            tick();\n          }\n        }\n      }, 50);\n    };\n    tick();\n    return () => clearTimeout(timer);\n  }, [duration, open]);\n\n  if (!open) return null;\n  return (\n    <div\n      role=\"status\"\n      onMouseEnter={() => (hoverRef.current = true)}\n      onMouseLeave={() => (hoverRef.current = false)}\n    >\n      {message}\n    </div>\n  );\n}\n```",
    "output": "```tsx\nimport { render, screen } from \"@testing-library/react\";\nimport { Toast } from \"../Toast\";\n\nbeforeEach(() => vi.useFakeTimers());\nafterEach(() => vi.useRealTimers());\n\ntest(\"auto-dismisses after duration\", () => {\n  render(<Toast message=\"Saved\" duration={200} />);\n  expect(screen.getByRole(\"status\", { name: /saved/i })).toBeInTheDocument();\n  vi.advanceTimersByTime(500);\n  expect(screen.queryByRole(\"status\")).not.toBeInTheDocument();\n});\n\ntest(\"pauses while hovered\", () => {\n  render(<Toast message=\"Saved\" duration={200} />);\n  const toast = screen.getByRole(\"status\");\n  toast.dispatchEvent(new MouseEvent(\"mouseenter\", { bubbles: true }));\n  vi.advanceTimersByTime(1000);\n  expect(screen.getByRole(\"status\")).toBeInTheDocument();\n  toast.dispatchEvent(new MouseEvent(\"mouseleave\", { bubbles: true }));\n  vi.advanceTimersByTime(300);\n  expect(screen.queryByRole(\"status\")).not.toBeInTheDocument();\n});\n```"
  },
  {
    "instruction": "Generate a Jest unit test for the following React component using React Testing Library.\n\nFollow these critical best practices for writing effective tests and avoid common mistakes:\n\n* **Query by User-Facing Attributes:** Prioritize querying elements the way a user would find them. Use roles, labels, and text (`getByRole`, `getByLabelText`, `getByText`). Avoid implementation details like class names or relying on `data-testid` as a first resort.\n* **Use `screen` for Queries:** Always use the `screen` object for querying the DOM (`screen.getByRole(...)`). Do not destructure query methods from `render`.\n* **Prefer `user-event` over `fireEvent`:** Use `@testing-library/user-event` for simulating user interactions as it more closely resembles real browser behavior.\n* **Use `*By` for Presence, `queryBy` for Absence:**\n    * Use `getBy...` or `getAllBy...` to assert an element is present (it throws an error if not found).\n    * Use `queryBy...` or `queryAllBy...` to assert an element is *not* present (it returns `null` if not found).\n* **Use `findBy` for Asynchronous Appearance:** Use `findBy...` or `findAllBy...` to find elements that will appear asynchronously after an action.\n\n```tsx\nimport * as React from \"react\";\n\ninterface VirtualListProps<T> {\n  items: T[];\n  itemHeight: number;\n  height: number;\n  renderItem: (item: T, index: number) => React.ReactNode;\n}\n\nexport function VirtualList<T>({ items, itemHeight, height, renderItem }: VirtualListProps<T>) {\n  const [scrollTop, setScrollTop] = React.useState(0);\n  const total = items.length * itemHeight;\n  const start = Math.floor(scrollTop / itemHeight);\n  const visibleCount = Math.ceil(height / itemHeight) + 1;\n  const end = Math.min(items.length, start + visibleCount);\n  const offsetY = start * itemHeight;\n\n  return (\n    <div\n      role=\"list\"\n      style={{ overflow: \"auto\", position: \"relative\", height }}\n      onScroll={(e) => setScrollTop((e.target as HTMLDivElement).scrollTop)}\n    >\n      <div style={{ height: total, position: \"relative\" }}>\n        <div style={{ position: \"absolute\", top: offsetY, left: 0, right: 0 }}>\n          {items.slice(start, end).map((item, i) => (\n            <div role=\"listitem\" key={start + i} style={{ height: itemHeight }}>\n              {renderItem(item, start + i)}\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}\n```",
    "output": "```tsx\nimport { render, screen } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport { VirtualList } from \"../VirtualList\";\n\nfunction make(n: number) {\n  return Array.from({ length: n }, (_, i) => `Row ${i}`);\n}\n\ntest(\"renders only visible items and updates on scroll\", async () => {\n  const user = userEvent.setup();\n  render(\n    <VirtualList\n      items={make(100)}\n      itemHeight={20}\n      height={100}\n      renderItem={(item) => <span>{item}</span>}\n    />\n  );\n\n  const items = screen.getAllByRole(\"listitem\");\n  expect(items.length).toBeGreaterThanOrEqual(5);\n  expect(items[0]).toHaveTextContent(\"Row 0\");\n\n  const list = screen.getByRole(\"list\");\n  list.scrollTop = 200;\n  list.dispatchEvent(new Event(\"scroll\"));\n  const after = screen.getAllByRole(\"listitem\")[0];\n  expect(after).toHaveTextContent(/row 10/i);\n});\n```"
  }
]
